- en: Chapter 10. Useful Flask Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen throughout this book, Flask is designed to be as small as possible
    while still giving you the flexibility and tools needed to create web applications.
    However, there are a lot of features that are common to many web applications,
    which means that many applications will require writing code that does the same
    task for each web application. To solve this problem, people have created extensions
    to Flask to avoid reinventing the wheel, and we have seen many Flask extensions
    already throughout the book. This chapter will focus on some of the more useful
    Flask extensions that don't have enough content to separate them out into their
    own chapter, but will save you a lot of time and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*, we
    created a basic manage script with the Flask extension Flask Script to allow easy
    running of the server and debugging with the shell. In this chapter, we will cover
    the features that were not covered in that basic introduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Flask Script, you can create custom commands to be run within the application
    context. All that is needed is to create a command to decorate a normal Python
    function with a decorator function provided by Flask Script. For example, if we
    wanted a task that would return the string "Hello, World!" we would add the following
    to `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the command line, the `test` command can now be run using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the test command, and let''s create a simple command to help set up
    new developers on our application by creating their SQLite database and filling
    it with test data. This command is partially lifted from the script created in
    [Chapter 4](ch04.html "Chapter 4. Creating Controllers with Blueprints"), *Creating
    Controllers with Blueprints*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now if a new developer is assigned the project, they could download the `git
    repo` from our server, install the `pip` libraries, run the `setup_db` command,
    and would be able to run the project with everything they need.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Script also provides two utility functions that can be easily added to
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `show-urls` command lists all of the routes registered on the `app` object
    and the URL tied to that route. This is very useful while debugging Flask extensions,
    as it becomes trivial to see whether the registration of its blueprints is working
    or not. The Clean command just removes the `.pyc` and `.pyo` compiled Python files
    from our working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Debug Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask Debug Toolbar is a Flask extension that aids development by adding debugging
    tools into the web view of your application. It gives you information such as
    the bottlenecks in your view rendering code, and how many SQLAlchemy queries it
    took to render the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we will use `pip` to install Flask Debug Toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add Flask Debug Toolbar to the `extensions.py` file. As we
    will be modifying this file a lot in this chapter, here is the start of the file
    so far along with the code to initialize Flask Debug Toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the initialization function needs to be called in our `create_app` function
    in `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is all that is needed to get Flask Debug Toolbar up and running. If the
    `DEBUG` variable in your app's `config` is set to *true*, the toolbar will appear.
    If `DEBUG` is not set to *true*, the toolbar will not be injected into the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flask Debug Toolbar](img/B03929_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the right-hand side of the screen, you will see the toolbar. Each section
    is a link that will display a table of values on the page. To get a list of all
    the functions that were called in order to render the view, click the checkmark
    next to **Profiler** to enable it, reload the page, and click on **Profiler**.
    This view easily allows you to quickly diagnose which parts of your apps are the
    slowest or are called the most.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Flask Debug Toolbar intercepts `HTTP 302 redirect` requests. To
    disable this, add the following to your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you are using Flask-MongoEngine, you can view all of the queries that
    were made to render the page by overriding which panels are rendered and adding
    MongoEngine's custom panel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will add a panel to the toolbar that is very similar to the default SQLAlchemy
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Using NoSQL with Flask"), *Using NoSQL
    with Flask*, we learned that page load time is one of the most important factors
    to determine the success of your web app. Despite the fact that our pages do not
    change very often and due to the fact that new posts will not be made very often,
    we still render the template and query the database every single time the page
    is asked for by our user's browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask Cache solves this problem by allowing us to store the results of our
    view functions and return the stored results rather than render the template again.
    First, we need to install Flask Cache from `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize it in `extensions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, register the `Cache` object on the application, in the `create_app` function
    in `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Before we can start caching our views, there is a need to tell Flash Cache how
    we want to store the results of our new functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `simple` option tells Flask Cache to store the results in memory in a Python
    dictionary, which for the vast majority of Flask apps is adequate. We'll cover
    more types of Cache backends later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Caching views and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to cache the results of a view function, simply add a decorator to
    any function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `timeout` parameter specifies how many seconds the cached result should
    last before the function should be run again and stored again. To confirm that
    the view is actually being cached, check the SQLAlchemy section on the Debug Toolbar.
    Also, we can see that the impact caching has on page load times by activating
    the profiler and comparing the times before and after. On the author's top of
    the line laptop, the main blog page takes 34 ms to render, mainly due to the eight
    different queries that are made to the database. But after the cache is activated,
    this decreases to .08 ms. That's a 462.5 percent increase in speed!
  prefs: []
  type: TYPE_NORMAL
- en: 'View functions are not the only thing that can be cached. To cache any Python
    function, simply add a similar decorator to the function definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The keyword argument `key_prefix` is necessary for non view functions in order
    for Flask Cache to properly store the results of the function. This needs to be
    unique for every function cached, or the results of the functions will override
    each other. Also, note that the timeout for this function is set to 2 hours rather
    than the 60 seconds in the previous examples. This is because the results for
    this function are less likely to change than the view functions, and if the data
    is stale, it is not as big an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Caching functions with parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, the normal cache decorator does not take function parameters into
    account. If we cached a function that took parameters with the normal cache decorator,
    it would return the same result for every parameter set. In order to fix this,
    we use the `memoize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Memoize` stores the parameters passed to the function as well as the result.
    In the preceding example, `memoize` is being used to store the result of the `verify_auth_token`
    method, which is called many times and queries the database every single time.
    This method can safely be memoized because it returns the same result every time
    if the same token is passed to it. The only exception to this rule is if the user
    object gets deleted during the 60 seconds that the function is stored, but this
    is very unlikely.'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to `memoize` or cache functions that rely on either globally
    scoped variables or on constantly changing data. This can lead to some very subtle
    bugs, and in the worst case, data race. The best candidates for memoization are
    what are referred to as pure functions. Pure functions are functions that will
    produce the same result when the same parameters are passed to them. It does not
    matter how many times the function is run. Pure functions also do not have any
    side effects, which means that they do not change globally scoped variables. This
    also means that pure functions cannot do any IO operations. While the `verify_auth_token`
    function is not pure because it does database IO, it is ok because as was stated
    before it is very unlikely that the underlying data will change.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are developing the application, we do not want the view functions
    to be cached because results will be changing all the time. To fix this, set the
    `CACHE_TYPE` variable to null and set the `CACHE_TYPE` variable to simple in the
    production configuration, so when the app is deployed everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Caching routes with query strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some routes, such as our home and `post` routes, take the parameters through
    the URL and return content specific to those parameters. We run into a problem
    if routes like these are cached, as the first rendering of the route will be returned
    for all requests regardless of the URL parameters. The solution is rather simple.
    The `key_prefix` keyword argument in the cache method can be either a string or
    a function, which will be executed to dynamically generate a key. This means that
    a function can be created to generate a key that is tied to the URL parameters,
    so each request only returns a cached page if that specific combination of parameters
    has been called before. In the `blog.py` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, each individual post page will be cached for 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis as a cache backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the amount of view functions or the number of unique parameters passed to
    your cached functions becomes too large for memory, you can use a different backend
    for the cache. As was mentioned in [Chapter 7](ch07.html "Chapter 7. Using NoSQL
    with Flask"), *Using NoSQL with Flask*, Redis can be used as a backend for the
    cache. To implement that functionality, all that needs to be done is to add the
    following configuration variables to the `ProdConfig` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you replace the values of the variables with your own data, Flask Cache
    will automatically create a connection to your `redis` database and use it to
    store the results of the functions. All that is needed is to install the Python
    `redis` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using memcached as a cache backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like the `redis` backend, the `memcached` backend provides an alternative
    way of storing results if the memory option is too limiting. In contrast to `redis`,
    `memcached` is designed to `cache` objects for later use and reduce load on the
    database. Both `redis` and `memcached` can serve the same purpose, and choosing
    one over the other comes down to personal preference. To use `memcached`, we need
    to install its Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Connecting to your `memcached` server is handled in the configuration object,
    just like the `redis` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Flask Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another bottleneck in web applications are the amount of HTTP requests required
    to download the CSS and JavaScript libraries for the page. The extra files can
    only be downloaded after HTML for the page has been loaded and parsed. To combat
    this, many modern browsers download many of these libraries at once, but there
    is a limit to how many simultaneous requests the browser makes.
  prefs: []
  type: TYPE_NORMAL
- en: Several things can be done on the server to reduce the amount of time spent
    downloading these files. The main technique that developers use is to concatenate
    all of the JavaScript libraries into one file and all of the CSS libraries into
    another while removing all of the whitespace and carriage returns from the resulting
    files. This reduces the overhead of multiple HTTP requests, and removing the unnecessary
    whitespace and carriage returns can reduce a file's size by up to 30 percent.
    Another technique is to tell the browser to cache the files locally with specialized
    HTTP headers, so the file is only loaded again once it changes. These can be tedious
    to do manually because they need to be done after every deployment to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, Flask Assets implements all the above techniques. Flask Assets
    works by giving it a list of files and a way to concatenate them, and then adding
    a special control block into your templates in place of the normal link and script
    tags. Flask Assets will then add in a link or a script tag that links to the newly
    generated file. To get started, Flask Assets needs to be installed. We also need
    to install `cssmin` and `jsmin`, which are Python libraries that handle the modification
    of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the collections of files to be concatenated, named bundles, need to be
    created. In `extensions.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each `Bundle` object takes an infinite number of files as positional arguments
    to define the files to be bundled, a keyword argument `filters` to define the
    filters to send the files through, and an `output` that defines the filename in
    the `static` folder to save the result to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `filters` keyword can be a single value or a list. To get the full list
    of available filters, including automatic Less and CSS compliers, see the docs
    at [http://webassets.readthedocs.org/en/latest/](http://webassets.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: While it's true that because our site is light on styles the CSS bundle has
    only one file in it. It's still a good idea to put the file in a bundle for two
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: While we are in development, we can use the un-minified versions of the libraries,
    which makes debugging easier. When the app is deployed to production, the libraries
    are automatically minified.
  prefs: []
  type: TYPE_NORMAL
- en: These libraries will be sent to the browser with the cache headers, when linking
    them in HTML normally would not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Flask Assets can be tested, three more changes need to be made. First,
    in the `__init__.py` format, the extension and bundles need to be registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `DevConfig` class needs an extra variable to tell Flask Assets to
    not compile the libraries while in development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the link and script tags in both of the `base.html` files need to
    be replaced with the control block from Flask Assets. We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you reload the page, all of the CSS and JavaScript will now be handled
    by Flask Assets.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html "Chapter 6. Securing Your App"), *Securing Your App*,
    we created an interface to allow users to create and edit blog posts without having
    to use the command line. This was adequate to demonstrate the security measures
    presented in the chapter, but there is still no way for posts to be deleted or
    tags assigned to them using the interface. We also do not have a way to delete
    or edit comments that we would rather not have common users see. What our app
    needs is a fully featured administrator interface in the same vein as the WordPress
    interface. This is such a common requirement for apps that a Flask extension name
    Flask Admin was created to easily create administrator interfaces. To get started,
    install Flask Admin with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we need to create the `extension` object in `extensions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the object needs to be registered on the `app` object in `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to `localhost:5000/admin`, you should now see the empty Flask
    Admin interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flask Admin](img/B03929_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Flask Admin works by registering view classes on the `admin` object that define
    one or more routes. Flask Admin has three main types of views: the `ModelView`,
    `FileAdmin`, and `BaseView` views.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic admin pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `BaseView` class allows normal Flask pages to be added to your `admin`
    interface. This is normally the least used type of view in Flask Admin setups,
    but if you wish to include something like custom reporting with JavaScript charting
    libraries, you would do it with just a base view. In a new file in the controllers
    folder named `admin.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In a subclass of `BaseView`, multiple views can be registered at once if they
    are defined together. Keep in mind, however, that each subclass of `BaseView`
    requires at least one exposed method on the path `/`. Also, methods other than
    the method within the path `/` will not be in the navigation of the administrator
    interface, and will have to be linked to the other pages in the class. The `expose`
    and `self.render` functions work exactly the same as their counterparts in the
    normal Flask API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have your templates inherit the default styles of Flask Admin, create a
    new folder in the templates directory named `admin` with a file named `custom.html`
    and add the following Jinja code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To view this template, an instance of `CustomView` needs to be registered on
    the `admin` object. This will be done in the `create_app` function rather than
    in the `extensions.py` file because some of our admin pages will need the database
    object, which would lead to circular imports if the registrations were in `extensions.py`.
    In `__init__.py`, add the following code to register the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `name` keyword argument specifies that the label used in the navigation
    bar on the top of the `admin` interface should read `Custom`. After you have registered
    `CustomView` to the `admin` object, your `admin` interface should now have a second
    link in the navigation bar as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating basic admin pages](img/B03929_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating database admin pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main power of Flask Admin comes from the fact that you can automatically
    create administrator pages for your data by giving Flask Admin your SQLAlchemy
    or MongoEngine models. Creating these pages is very easy; in `admin.py`, just
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `__init__.py`, register the class with the model you wish to use and
    the database `session` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `category` keyword tells Flask Admin to put all of the views with the same
    category value into the same dropdown on the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the browser now, you will see a new drop-down menu labeled **Models**
    with links to the admin pages of all of the tables in the database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating database admin pages](img/B03929_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The generated interface for each model provides a lot of functionality. New
    posts can be created, and the existing posts can be deleted in bulk. All of the
    fields can be set from this interface, including the relationship fields, which
    are implemented as searchable drop-down menus. The `date` and `datetime` fields
    even have custom JavaScript inputs with calendar dropdowns. Overall, this is a
    huge improvement to the hand-created interface that was created in [Chapter 6](ch06.html
    "Chapter 6. Securing Your App"), *Securing Your App*.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the post's administration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this interface is a huge step-up in quality, there are some features missing.
    We no longer have the WYSIWYG editor that was available in the original interface,
    and this page can be improved by enabling some of the more powerful Flask Admin
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the WYSIWYG editor back into the `post` creation page, we will need
    a new `WTForms` field, as Flask Admin constructs its forms with Flask WTF. We
    will also need to override the `textarea` field in the `post` edit and creation
    page with this new field type. The first thing that needs to be done is to create
    the new field type in `forms.py` by using the `textarea` field as a base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we created a new field type `CKTextAreaField` that adds a widget
    to the `textarea`, and all that the widget does is adds a class to the HTML tag.
    Now, to add this field to the `Post` admin page, the `Post` will need its own
    `ModelView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several new things in this code. First, the `form_overrides` class
    variable tells Flask Admin to override the field type of the name text with this
    new field type. The `column_searchable_list` function defines which columns are
    searchable via text. Adding this will allow Flask Admin to include a search field
    on the overview page that searches the values of the defined fields. Next, the
    `column_filters` class variable tells Flask Admin to create a `filters` interface
    on the overview page of this model. The `filters` interface allows columns that
    are not text to be filtered down by adding conditions to the shown rows. An example
    with the preceding code is to create a filter that shows all rows with `publish_date`
    values greater than January 1, 2015\. Finally, the `create_template` and `edit_template`
    class variables allow you to define custom templates for Flask Admin to use. For
    the custom template that we will be using, we need to create a new file `post_edit.html`
    in the admin folder. In this template, we will include the same JavaScript library
    that was used in [Chapter 6](ch06.html "Chapter 6. Securing Your App"), *Securing
    Your App*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The tail block of the inherited template is located at the end of the file.
    Once the template is created, your `post` edit and creation page should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing the post''s administration](img/B03929_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating file system admin pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common function that most `admin` interfaces cover is being able to
    access the server's file system from the web. Thankfully, Flask Admin includes
    this feature with the `FileAdmin` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Securing Flask Admin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the entire `admin` interface is accessible to the world; let''s
    fix that. The routes in the `CustomView` can be secured just like any other route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To secure the `ModeView` and `FileAdmin` subclasses, they need to have a method
    named `is_accessible` defined, which either returns *true* or *false*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Because we set up our authentication correctly in [Chapter 6](ch06.html "Chapter 6. Securing
    Your App"), *Securing Your App*, this task was trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Flask Mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final Flask extension that this chapter will cover is Flask Mail, which
    allows you to connect and configure your SMTP client from Flask''s configuration.
    Flask Mail will also help to simplify application testing in [Chapter 12](ch12.html
    "Chapter 12. Testing Flask Apps"), *Testing Flask Apps*. The first step is to
    install Flask Mail with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `Mail` object needs to be initialized in the `extentions.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`flask_mail` will connect to our SMTP server of choice by reading the configuration
    variables in our `app` object, so we need to add those values to our `config`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `mail` object is initialized on the `app` object in `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how Flask Mail can simplify our e-mailing code, this is the remind task
    created in [Chapter 9](ch09.html "Chapter 9. Creating Asynchronous Tasks with
    Celery"), *Creating Asynchronous Tasks with Celery*, but using Flask Mail instead
    of the standard library SMTP module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has created a large increase in the functionality of our app. We
    now have a fully featured administrator interface, a useful debugging tool in
    the browser, two tools that greatly speed up page load times, and a utility to
    make sending e-mails less of a headache.
  prefs: []
  type: TYPE_NORMAL
- en: As was stated at the start of this chapter, Flask is bare-bones and allows you
    to pick and choose the functionality that you want. Therefore, it is important
    to keep in mind that it is not necessary to include all of these extensions in
    you app. If you are the only content creator of your app, maybe the command-line
    interface is all you need because adding in these features takes development time
    and maintenance time when they inevitably break. This warning is given at the
    end of the chapter because one of the main reasons many Flask apps become unwieldy
    is because they include so many extensions that testing and maintaining all of
    them becomes a very large task.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn the internals of how an extension works
    and how to create your own extension.
  prefs: []
  type: TYPE_NORMAL
