- en: Instant Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important feature of corporate software is the ability to communicate with
    staff. Thus, an internal instant messaging system is a crucial part of the software.
    By incorporating the networking module in Qt, we can easily create a chat system
    out of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt networking module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an instant messaging server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an instant messaging client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an instant messaging system using Qt is a lot easier than you think.
    Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The Qt networking module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will learn about the Qt networking module and how
    it can help us to achieve server-client communication via the TCP or UDP connection
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Connection protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The networking module in Qt is the module that offers both low-level networking
    functionality, such as TCP and UDP sockets, as well as high-level networking classes
    for web integration and network communication.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the **TCP** (**Transmission Control Protocol**)
    internet protocol for our program instead of the **UDP** (**User Datagram Protocol**)
    protocol. The main difference is that TCP is a connection-oriented protocol that
    requires all clients to establish a connection to the server before they are able
    to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: UDP on the other hand is a connectionless protocol that does not require a connection.
    The client will just send whatever data it needs to send to the destination, without
    checking if the data has been received by the other end. There are pros and cons
    for both protocols, but TCP is much more suitable for our sample project. We want
    to make sure every chat message is being received by the recipient, don't we?
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between both protocols are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection-oriented protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable for applications that require high reliability, and it is less critical
    toward its data transmission time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The speed for TCP is slower than UDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires acknowledgment of receipt from the receiving client before sending
    the next data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an absolute guarantee that the data transferred remains intact and
    arrives in the same order in which it was sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UDP:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectionless protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suitable for applications that need fast, efficient transmission, such as games
    and VOIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDP is lightweight and faster than TCP because error recovery is not attempted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also suitable for servers that answer small queries from huge numbers of clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no guarantee that the data sent reaches its destination at all as there
    is no tracking connections and no need for any acknowledgment from the receiving
    client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are not going for the peer-to-peer connection approach, our chat system
    will require two different pieces of software—the server program and the client
    program. The server program will act as the middleman (just like a postman) who
    receives all the messages from all the users and sends them to the targeted recipients
    accordingly. The server program will be locked away from the normal users in one
    of the computers in the server room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client program, on the other hand, is the instant messaging software that
    is used by all the users. This program is the one that is being installed on the
    users'' computers. Users can send their messages using this client program and
    see the messages sent by others as well. The overall architecture of our messaging
    system looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26bb7700-45cf-4482-9232-4eb2ce750839.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's proceed to setting up our project and enabling Qt's networking module!
    For this project, we will start on the server program before working on the client
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, create a new Qt Console Application project. Then, open up the project
    file (`.pro`) and add in the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should have noticed that this project doesn't have any `gui` module (we
    make sure it's explicitly removed) as we don't need any user interface for the
    server program. That is also the reason why we chose Qt Console Application instead
    of the usual Qt Widgets Application.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, that's it—you have successfully added the networking module to your
    project. In the next section, we will learn how to create the server program for
    our chat system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instant messaging server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will learn how to create an instant messaging server
    that receives messages sent by the users and redistributes them to their respective
    recipients.
  prefs: []
  type: TYPE_NORMAL
- en: Creating TCP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to create a TCP server that constantly listens
    to a specific port for incoming messages. For the sake of simplicity, we will
    just create a global chat room in which every user can see the messages sent by
    each and every user within the chat room, instead of a one-to-one messaging system
    with a friend list. You can easily improvise this system to the latter once you
    have understood how a chat system functions.
  prefs: []
  type: TYPE_NORMAL
- en: First, go to File | New File or Project and choose C++ Class under the C++ category.
    Then, name the class as `server` and select QObject as the base class. Make sure
    the Include QObject option is ticked before proceeding to create the custom class.
    You should have also noticed the absence of `mainwindow.ui`, `mainwindow.h`, and
    `mainwindow.cpp`. This is because there is no user interface in a console application
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the server class has been created, let''s open up `server.h` and add in
    the following headers, variables and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a function called `startServer()` and add the following code to
    the function definition in `server.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created a `QTcpServer` object called `chatServer` and made it constantly
    listen to port `8001`. You can choose any unused port number ranging from `1024`
    to `49151`. Other numbers outside of this range are usually reserved for common
    systems, such as HTTP or FTP services, so we better not use them to avoid conflicts.
    We also created a `QVector` array called `allClients` to store all the connected
    clients so that we can make use of it later to redirect incoming messages to all
    users.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `setMaxPendingConnections()` function to limit the maximum
    pending connections to 10 clients. You can use this method to keep the number
    of active clients to a specific amount so that your server's bandwidth is always
    within its limit. This can ensure good service quality and maintain a positive
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chatServer` will trigger the `newConnection()` signal whenever a client
    has connected to the server, so we connect that signal to our custom slot function
    called `newClientConnection()`. The slot function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every new client connected to the server is a `QTcpSocket` object, which can
    be obtained from the `QTcpServer` object by calling `nextPendingConnection()`.
    You can obtain information about the client such as its IP address and port number
    by calling `peerAddress()` and `peerPort()`, respectively. We then store each
    new client into the `allClients` array for future use. We also connect the client's
    `disconnected()`, `readyRead()` and `stateChanged()` signals to its respective
    slot function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a client is disconnected from the server, the `disconnected()` signal
    will be triggered, and subsequently the `socketDisconnected()`, `slot` function
    will be called. What we are doing in this function is just displaying the message
    on the server console whenever it happens, and nothing more. You can do anything
    you like here such as saving the user''s offline state to the database and so
    on. For the sake of simplicity, we will just print out the message on the console
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, whenever a client is sending in a message to the server, the `readyRead()`
    signal will be triggered. We have connected the signal to a slot function called
    `socketReadyRead()` and it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we simply redirect the message to a custom function called
    `sendMessageToClients()`, which handles passing the message to all connected clients.
    We will look at how this function works in a minute. We use `QObject::sender()`
    to get the pointer of the object that emitted the `readyRead` signal and convert
    it to the `QTcpSocket` class so that we can access its `readAll()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we also connected another signal called `stateChanged()` to the
    `socketStateChanged()` slot function. The slow function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function gets triggered whenever a client's network state has changed,
    such as connected, disconnected, listening, and so on. We will simply print out
    a relevant message according to its new state so that we can debug our program
    more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at what the `sendMessageToClients()` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we simply loop through the `allClients` array and pass
    the message data to all the connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, open up `main.cpp` and add the following code to start our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the program now, and you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07666326-5c7d-4633-8a02-641e3ae73af5.png)'
  prefs: []
  type: TYPE_IMG
- en: It doesn't look like anything is happening except showing that the server is
    listening to port `8001`. Don't worry, because we haven't created the client program
    yet. Let's proceed!
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instant messaging client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we will proceed to create our instant messaging client,
    which the users will be using to send and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to design the user interface for the instant
    messaging client and create functionality for it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create another Qt project by going to File | New File or Project. Then
    select Qt Widget Application under the Application category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the project has been created, open up `mainwindow.ui` and drag a Line
    Edit and Text Browser to the window canvas. Then, select the central widget and
    click the Lay Out Vertically button, located on the widget bar above, to apply
    the vertical layout effect to the widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e12c2a26-b9f7-4a29-be49-3e3e35eaa0c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, place a Horizontal Layout at the bottom and put the Line Edit into
    the layout. Then, pull a Push Button from the widget box into the Horizontal Layout
    and name it as `sendButton`; we also set its label as `Send`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6569033-78ae-4f24-8c92-52d0d24ce323.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''re finished, drag and drop another Horizontal Layout and place it
    on top of the text browser. After that, place a Label, Line Edit, and a Push Button
    into the horizontal layout, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65759c61-0e68-4ef7-803d-91247e04d7ae.png)'
  prefs: []
  type: TYPE_IMG
- en: We call the line edit widget `nameInput` and set a default text for it as `John
    Doe`, just so the user has a default name. Then, we call the push button `connectButton`
    and change its label to `Connect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have completed the user interface design for a very simple instant messaging
    program, which will do the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to a server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let a user set their name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can see messages sent by all users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user can type and send their messages for all to see
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile and run the project now, you should see your program looking something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b412d5d1-4f08-44fb-bcd5-3da628cdfb2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Do note that I also changed the window title to `Chat Client` so that it looks
    slightly more professional. You can do so by selecting the `MainWindow` object
    at the hierarchy window and change its `windowTitle` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start working on the programming part and implement
    the features mentioned in the list above.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing chat features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing any code, we must first enable the networking module
    by opening our project file (`.pro`) and add the `network` keyword there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open up `mainwindow.h` and add the following headers and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `connectedToHost` variable to `false` by default in `mainwindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, the first feature we need to implement is the server connection.
    Open up `mainwindow.ui`, right-click on the Connect button, then choose Go to
    slot..., and pick `clicked()`. After that, a slot function will be created for
    you automatically. Add in the following code to the `SLOT` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What we did in the preceding code was basically check for the `connectedToHost`
    variable. If the variable is `false` (meaning the client is not connected to the
    server), create a `QTcpSocket` object called `socket` and make it connect to a
    host at `127.0.0.1` on port `8801`. The IP address `127.0.0.1` stands for a localhost.
    Since this is only for testing purposes, we will connect the client to our test
    server, which is located on the same computer. If you're running the server on
    another computer, you may change the IP address to a LAN or WAN address, depending
    on your need.
  prefs: []
  type: TYPE_NORMAL
- en: We also connected the `socket` object to its respective slot functions when
    `connected()`, `disconnected()`, and `readReady()` signals were triggered. This
    is exactly the same as the server code, which we did previously. If the client
    is already connected to the server and the Connect (now labeled `Disconnect`)
    button is clicked, then send a disconnection message to the server and terminate
    the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at the slot functions, which we connected to the `socket`
    object in the previous step. The first one is the `socketConnected()` function,
    which will be called when the client has successfully connected to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, the client will display a `Connected to server.` message on both the
    application output and the text browser widget. We will see what the `printMessage()`
    function looks like in a minute. Then, we take the user's name from the input
    field and incorporate it into a text message and send it to the server so that
    all users are being notified. Finally, set the Connect button's label to `Disconnect`, and
    set the `connectedToHost` variable to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, let''s look at `socketDisconnected()`, which as its name implies,
    will be called whenever the client is disconnected from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is quite straightforward. All it does is show disconnected
    messages on both the application output and text browser widget, then sets the
    Disconnect button's label to `Connect` and the `connectedToHost` variable to `false`.
    Do note that since this function will only be called after the client has been
    disconnected from the server, we can no longer send any message to the server
    at that point to notify it of the disconnection. You should check for the disconnection
    at the server side and notify all users accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, there is the `socketReadyRead()` function,  which will be triggered whenever
    the server is sending data to the client. This function is even simpler than the
    previous ones, as all it does is pass the incoming data to the `printMessage()`
    function and nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s look at what the `printMessage()` function looks like. Actually,
    it is just as simple. All it does is to append the message to the text browser
    and it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, let''s check out how to implement the function for sending
    messages to the server. Open up `mainwindow.ui`, right-click on the Send button,
    select Go to slot..., and choose the `clicked()` option. Once the slot function
    has been created for you, add the following code to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we take the user's name and combine it with the message. Then, we set
    the name to a blue color before sending the entire thing to the server by calling
    `write()`. After that, clear the message input field, and we're done. Since the
    text browser accepts rich text by default, we can use that to color our text by
    placing the text within the `<font>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the project now; you should be able to chat among yourselves
    on different clients! Don''t forget to turn on the server before connecting the
    clients. If everything goes right, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e596014-2a86-4f29-b996-da0d30ff5cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Meanwhile, you should also see all the activities on the server side as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc60d96-fc57-4fe5-b4cd-a459653d6dcf.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it! We have successfully created a simple chat system using Qt. You are
    welcome to improvise on this and create a fully fledged messaging system!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create an instant messaging system using
    Qt's networking module. In the following chapter, we will dive into the wonders
    of graphics rendering using Qt.
  prefs: []
  type: TYPE_NORMAL
