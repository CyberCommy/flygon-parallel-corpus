- en: Data Structures Used in Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithms need necessary in-memory data structures that can hold temporary
    data while executing. Choosing the right data structures is essential for their
    efficient implementation. Certain classes of algorithms are recursive or iterative
    in logic and need data structures that are specially designed for them. For example,
    a recursive algorithm may be more easily implemented, exhibiting better performance,
    if nested data structures are used. In this chapter, data structures are discussed
    in the context of algorithms. As we are using Python in this book, this chapter
    focuses on Python data structures, but the concepts presented in this chapter
    can be used in other languages such as Java and C++.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand how Python handles
    complex data structures and which one should be used for a certain type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, here are the main points discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data structures in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring abstract data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring data structures in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any language, data structures are used to store and manipulate complex data.
    In Python, data structures are storage containers to manage, organize, and search
    data in an efficient way. They are used to store a group of data elements called
    *collections* that need to be stored and processed together. In Python, there
    are five various data structures that can be used to store collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lists**: Ordered mutable sequences of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples**: Ordered immutable sequences of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets**: Unordered bags of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionary**: Unordered bags of key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data frames**: Two-dimensional structures to store two-dimensional data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look into them in more detail in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a list is the main data structure used to store a mutable sequence
    of elements. The sequence of data elements stored in the list need not be of the
    same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a list, the data elements need to be enclosed in [ ] and they need
    to be separated by a comma. For example, the following code creates four data
    elements together that are of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In Python, a list is a handy way of creating one-dimensional writable data structures
    that are needed especially at different internal stages of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Using lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utility functions in data structures make them very useful as they can be used
    to manage data in lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into how we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List indexing**: As the position of an element is deterministic in a list,
    the index can be used to get an element at a particular position. The following
    code demonstrates the concept:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The four-element list created by this code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b74b3d8f-f1de-463d-8516-4eeb03b634b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the index starts from 0 and therefore **Green**, which is the second
    element, is retrieved by index **1**, that is, `bin_color[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**List slicing**: Retrieving a subset of the elements of a list by specifying
    a range of indexes is called **slicing**. The following code can be used to create
    a slice of the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that lists are one of the most popular single-dimensional data structures
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'While slicing a list, the range is indicated as follows: the first number (inclusive)
    and the second number (exclusive). For example, `bin_colors[0:2]` will include
    `bin_color[0]` and `bin_color[1]` but not `bin_color[2]`. While using lists, this
    should be kept in mind as some users of the Python language complain that this
    is not very intuitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the starting index is not specified, it means the beginning of the list,
    and if the ending index is not specified, it means the end of the list. The preceding
    code actually demonstrates this concept.
  prefs: []
  type: TYPE_NORMAL
- en: '**Negative indexing**: In Python, we also have negative indices, which count
    from the end of the list. This is demonstrated in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that negative indices are especially useful when we want to use the last
    element as a reference point instead of the first one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nesting**: An element of a list can be of a simple data type or a complex
    data type. This allows nesting in lists. For iterative and recursive algorithms,
    this provides important capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code, which is an example of a list within
    a list (nesting):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Iteration**: Python allows iterating over each element on a list by using
    a `for` loop. This is demonstrated in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code iterates through the list and prints each element.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a bunch of lambda functions that can be used on lists. They are specifically
    important in the context of algorithms and provide the ability to create a function
    on the fly. Sometimes, in the literature, they are also called *anonymous functions*.
    This section demonstrates their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering data**: To filter the data, first, we define a predicate, which
    is a function that inputs a single argument and returns a Boolean value. The following
    code demonstrates its use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this code, we filter a list using the `lambda` function, which
    specifies the filtering criteria. The filter function is designed to filter elements
    out of a sequence based on a defined criterion. The filter function in Python
    is usually used with `lambda`. In addition to lists, it can be used to filter
    elements from tuples or sets. For the preceding code, the defined criterion is
    `x > 100`. The code will iterate through all the elements of the list and will
    filter out the elements that do not pass this criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data transformation**: The `map()` function can be used for data transformation
    using a lambda function. An example is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the `map` function with a `lambda` function provides quite powerful functionality.
    When used with the `map` function, the `lambda` function can be used to specify
    a transformer that transforms each element of the given sequence. In the preceding
    code, the transformer is multiplication by two. So, we are using the `map` function
    to multiply each element in the list by two.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data aggregation**: For data aggregation, the `reduce()` function can be
    used, which recursively runs a function to pairs of values on each element of
    the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `reduce` function needs a data aggregation function to be defined.
    That data aggregation function in the preceding code is `functools`. It defines
    how it will aggregate the items of the given list. The aggregation will start
    from the first two elements and the result will replace the first two elements.
    This process of reduction is repeated until we reach the end, resulting in one
    aggregated number. `x1` and `x2` in the `doSum` function represent two numbers
    in each of these iterations and `doSum` represents the aggregation criterion for
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code block results in a single value (which is `270`).
  prefs: []
  type: TYPE_NORMAL
- en: The range function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `range` function can be used to easily generate a large list of numbers.
    It is used to auto-populate sequences of numbers in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range` function is simple to use. We can use it by just specifying the
    number of elements we want in the list. By default, it starts from zero and increments
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify the end number and the step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding range function will give us odd numbers starting from `3` to `29`.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The time complexity of various functions of a list can be summarized as follows
    using the Big O notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Different methods** | **Time complexity** |'
  prefs: []
  type: TYPE_TB
- en: '| Insert an element | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Delete an element | O(n) (as in the worst case may have to iterate the whole
    list) |'
  prefs: []
  type: TYPE_TB
- en: '| Slicing a list | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| Element retrieval | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| Copy | O(n) |'
  prefs: []
  type: TYPE_TB
- en: Please note that the time taken to add an individual element is independent
    of the size of the list. Other operations mentioned in the table are dependent
    on the size of the list. As the size of the list gets bigger, the impact on performance
    becomes more pronounced.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second data structure that can be used to store a collection is a tuple.
    In contrast to lists, tuples are immutable (read-only) data structures. Tuples
    consist of several elements surrounded by ( ).
  prefs: []
  type: TYPE_NORMAL
- en: Like lists, elements within a tuple can be of different types. They also allow
    complex data types for their elements. So, there can be a tuple within a tuple
    providing a way to create a nested data structure. The capability to create nested
    data structures is especially useful in iterative and recursive algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to create tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Wherever possible, immutable data structures (such as tuples) should be preferred
    over mutable data structures (such as lists) due to performance. Especially when
    dealing with big data, immutable data structures are considerably faster than
    mutable ones. There is a price we pay for the ability to change data elements
    in lists, for example, and we should carefully analyze that it is really needed
    so we can implement the code as read-only tuples, which will be much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the preceding code, `a[2]` refers to the third element, which
    is a tuple, `(100,200,300)`. `a[2][1]` refers to the second element within this
    tuple, which is `200`.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The time complexity of various functions of tuples can be summarized as follows
    (using Big O notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Time** **Complexity** |'
  prefs: []
  type: TYPE_TB
- en: '| `Append` | O(1) |'
  prefs: []
  type: TYPE_TB
- en: Note that `Append` is a function that adds an element toward the end of the
    already existing tuple. Its complexity is O(1).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Holding data as key-value pairs is important especially in distributed algorithms.
    In Python, a collection of these key-value pairs is stored as a data structure
    called a *dictionary*. To create a dictionary, a key should be chosen as an attribute
    that is best suited to identify data throughout data processing. The value can
    be an element of any type, for example, a number or string. Python also always
    uses complex data types such as lists as values. Nested dictionaries can be created
    by using a dictionary as the data type of a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple dictionary that assigns colors to various variables, the
    key-value pairs need to be enclosed in { }. For example, the following code creates
    a simple dictionary consisting of three key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The three key-value pairs created by the preceding piece of code are also illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5e368cad-172b-4e21-866a-ef187bebe372.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see how to retrieve and update a value associated with a key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve a value associated with a key, either the `get` function can be
    used or the key can be used as the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To update a value associated with a key, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code shows how we can update a value related to a particular
    key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of a dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table gives the time complexity of a dictionary using Big O notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dictionary** | **Time** **complexity** |'
  prefs: []
  type: TYPE_TB
- en: '| Get a value or a key | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Set a value or a key | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Copy a dictionary | O(n) |'
  prefs: []
  type: TYPE_TB
- en: An important thing to note from the complexity analysis of the dictionary is
    that the time taken to get or set a key-value is totally independent of the size
    of the dictionary. This means that the time taken to add a key-value pair to a
    dictionary of a size of three is the same as the time taken to add a key-value
    pair to a dictionary of a size of one million.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A set is defined as a collection of elements that can be of different types.
    The elements are enclosed within { }. For example, have a look at the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The defining characteristic of a set is that it only stores the distinct value
    of each element. If we try to add another redundant element, it will ignore that,
    as illustrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate what sort of operations can be done on sets, let''s define two
    sets:'
  prefs: []
  type: TYPE_NORMAL
- en: A set named yellow, which has things that are yellow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another set named red, which has things that are red
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that some things are common between these two sets. The two sets and their
    relationship can be represented with the help of the following Venn diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](assets/8cdd35a9-b222-4671-8917-7ace89de60fb.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to implement these two sets in Python, the code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s consider the following code, which demonstrates set operations
    using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, sets in Python can have operations
    such as unions and intersections. As we know, a union operation combines all of
    the elements of both sets, and the intersection operation will give a set of common
    elements between the two sets. Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yellow|red` is used to get the union of the preceding two defined sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yellow&red` is used to get the overlap between yellow and red.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time complexity analysis for sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following is the time complexity analysis for sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sets** | **Complexity** |'
  prefs: []
  type: TYPE_TB
- en: '| Add an element | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove an element | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Copy | O(n) |'
  prefs: []
  type: TYPE_TB
- en: An important thing to note from the complexity analysis of the sets is that
    the time taken to add an element is totally independent of the size of a particular
    set.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A DataFrame is a data structure used to store tabular data available in Python''s
    `pandas` package. It is one of the most important data structures for algorithms
    and is used to process traditional structured data. Let''s consider the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **id** | **name** | **age** | **decision** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Fares | 32 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Elena | 23 | False |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Steven | 40 | True |'
  prefs: []
  type: TYPE_TB
- en: Now, let's represent this using a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple DataFrame can be created by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the preceding code, `df.column` is a list that specifies the names
    of the columns.
  prefs: []
  type: TYPE_NORMAL
- en: The DataFrame is also used in other popular languages and frameworks to implement
    a tabular data structure. Examples are R and the Apache Spark framework.
  prefs: []
  type: TYPE_NORMAL
- en: Terminologies of DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look into some of the terminologies that are used in the context of
    a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axis**: In the pandas documentation, a single column or row of a DataFrame
    is called an axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Axes**: If there is more than one axis, they are called axes as a group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Label**: A DataFrame allows the naming of both columns and rows with what''s
    called a label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a subset of a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fundamentally, there are two main ways of creating the subset of a DataFrame
    (say the name of the subset is `myDF`):'
  prefs: []
  type: TYPE_NORMAL
- en: Column selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Column selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In machine learning algorithms, selecting the right set of features is an important
    task. Out of all of the features that we may have, not all of them may be needed
    at a particular stage of the algorithm. In Python, feature selection is achieved
    by column selection, which is explained in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A column may be retrieved by *name*, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The positioning of a column is deterministic in a DataFrame. A column can be
    retrieved by its position as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this code, we are retrieving the first three rows of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Row selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each row in a DataFrame corresponds to a data point in our problem space. We
    need to perform row selection if we want to create a subset of the data elements
    we have in our problem space. This subset can be created by using one of the two
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: By specifying their position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By specifying a filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A subset of rows can be retrieved by its position as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code will return the first two rows and all columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a subset by specifying the filter, we need to use one or more columns
    to define the selection criterion. For example, a subset of data elements can
    be selected by this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code creates a subset of rows that satisfies the condition stipulated
    in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A matrix is a two-dimensional data structure with a fixed number of columns
    and rows. Each element of a matrix can be referred to by its column and the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, a matrix can be created by using the `numpy` array, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding code will create a matrix that has three rows and three
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many operations available for matrix data manipulation. For example,
    let''s try to transpose the preceding matrix. We will use the `transpose()` function,
    which will convert columns into rows and rows into columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that matrix operations are used a lot in multimedia data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about data structures in Python, let's move onto the
    abstract data types in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring abstract data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstraction, in general, is a concept used to define complex systems in terms
    of their common core functions. The use of this concept to create generic data
    structures gives birth to **Abstract Data Types** (**ADT**). By hiding the implementation
    level details and giving the user a generic, implementation-independent data structure,
    the use of ADTs creates algorithms that result in simpler and cleaner code. ADTs
    can be implemented in any programming language such as C++, Java, and Scala. In
    this section, we shall implement ADTs using Python. Let's start with vectors first.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A vector is a single dimension structure to store data. They are one of the
    most popular data structures in Python. There are two ways of creating vectors
    in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a Python list: The simplest way of creating a vector is by using a Python
    list, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code will create a list with four elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `numpy` array: Another popular way of creating a vector is by using
    NumPy arrays, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that we created `myVector` using `np.array` in this code.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can represent integers using underscores to separate parts. It
    makes them more readable and less error-prone. This is especially useful when
    dealing with large numbers. So, one billion can be represented as a=1
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a linear data structure to store a one-dimensional list. It can store
    items either in **Last-In, First-Out** (**LIFO**) or **First-In, Last-Out** (**FILO**)
    manner. The defining characteristic of a stack is the way elements are added and
    removed from it. A new element is added at one end and an element is removed from
    that end only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the operations related to stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**isEmpty:** Returns true if the stack is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**push:** Adds a new element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pop**: Returns the element added most recently and removes it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how push and pop operations can be used to add
    and remove data from a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a9ce44cc-08ed-4e39-b3ba-6a5691b22a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: The top portion of the preceding diagram shows the use of push operations to
    add items to the stack. In steps **1.1**, **1.2**, and **1.3**, push operations
    are used three times to add three elements to the stack. The bottom portion of
    the preceding diagram is used to retrieve the stored values from the stack. In
    steps **2.2** and **2.3**, pop operations are used to retrieve two elements from
    the stack in LIFO format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class named `Stack` in Python, where we will define all of
    the operations related to the stack class. The code of this class will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To push four elements to the stack, the following code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/819b0842-cfd2-4d01-a306-19b01905bba9.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the preceding code creates a stack with four data elements.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look into the time complexity of stacks (using Big O notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Time Complexity** |'
  prefs: []
  type: TYPE_TB
- en: '| `push` | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| `pop` | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| `peek` | O(1) |'
  prefs: []
  type: TYPE_TB
- en: An important thing to note is that the performance of none of the four operations
    mentioned in the preceding table depends on the size of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is used as the data structure in many use cases. For example, when a
    user wants to browse the history in a web browser, it is a LIFO data access pattern
    and a stack can be used to store the history. Another example is when a user wants
    to perform an `Undo` operation in word processing software.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like stacks, a queue stores *n* elements in a single-dimensional structure.
    The elements are added and removed in **FIFO** format. One end of the queue is
    called the *rear* and the other is called the *front*. When elements are removed
    from the front, the operation is called *dequeue*. When elements are added at
    the rear, the operation is called *enqueue*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following diagram, the top portion shows the enqueue operation. Steps
    **1.1**, **1.2**, and **1.3** add three elements to the queue and the resultant
    queue is shown in **1.4**. Note that **Yellow** is the  *rear*  and **Red** is
    the  *front*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom portion of the following diagram shows a dequeue operation. Steps
    **2.2**, **2.3**, and **2.4** remove elements from the queue one by one from the
    front of the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0da2e641-e84f-4f35-bdea-2fe3d9366528.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The queue shown in the preceding diagram can be implemented by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s enqueue and dequeue elements as shown in the preceding diagram with
    the help of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c068e281-0709-4d13-8f5c-c4b4b9b8fd12.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the preceding code creates a queue first and then enqueues four items
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind the use of stacks and queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look into the basic idea behind the use of stacks and queues using an
    analogy. Let''s assume that we have a table where we put our incoming mail from
    our postal service, for example, Canada Mail. We stack it until we get some time
    to open and look at the mail, one by one. There are two possible ways of doing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: We put the letter in a stack and whenever we get a new letter, we put it on
    the top of the stack. When we want to read a letter, we start with the one that
    is on top. This is what we call a  *stack*. Note that the latest letter to arrive
    will be on the top and will be processed first. Picking up a letter from the top
    of the list is called a  *pop*  operation. Whenever a new letter arrives, putting
    it on the top is called  *push*  operation. If we end up having a sizable stack
    and lots of letters are continuously arriving, there is a chance that we never
    get a chance to reach a very important letter waiting for us at the lower end
    of the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We put the letter in pile, but we want to handle the oldest letter first: each
    time we want to look at one or more letters, we take care to handle the oldest
    one first. This is what we call a *q**ueue*. Adding a letter to the pile is called
    an *e**nqueue*  operation. Removing the letter from the pile is called *d**equeue*  operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of algorithms, a tree is one of the most useful data structures
    due to its hierarchical data storage capabilities. While designing algorithms,
    we use trees wherever we need to represent hierarchical relationships among the
    data elements that we need to store or process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look deeper into this interesting and quite important data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Each tree has a finite set of nodes so that it has a starting data element called
    a *root* and a set of nodes joined together by links called *branches*.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look into some of the terminology related to the tree data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Root node | A node with no parent is called the *root* node. For example,
    in the following diagram, the root node is **A**. In algorithms, usually, the
    root node holds the most important value in the tree structure. |'
  prefs: []
  type: TYPE_TB
- en: '| Level of a node | The distance from the root node is the level of a node.
    For example, in the following diagram, the level of nodes **D**, **E,** and **F**
    is two. |'
  prefs: []
  type: TYPE_TB
- en: '| Siblings nodes | Two nodes in a tree are called *siblings* if they are at
    the same level. For example, if we check the following diagram, nodes **B** and
    **C** are siblings. |'
  prefs: []
  type: TYPE_TB
- en: '| Child and parent node | A node, **F**, is a child of node **C**, if both
    are directly connected and the level of node **C** is less than node **F**. Conversely,
    node **C** is a parent of node **F**. Nodes **C** and **F** in the following diagram
    show this parent-child relationship. |'
  prefs: []
  type: TYPE_TB
- en: '| Degree of a node | The degree of a node is the number of children it has.
    For example, in the following diagram, node **B** has a degree of two. |'
  prefs: []
  type: TYPE_TB
- en: '| Degree of a tree | The degree of a tree is equal to the maximum degree that
    can be found among the constituent nodes of a tree. For example, the tree presented
    in the following diagram has a degree of two. |'
  prefs: []
  type: TYPE_TB
- en: '| Subtree | A subtree of a tree is a portion of the tree with the chosen node
    as the root node of the subtree and all of the children as the nodes of the tree.
    For example, a subtree at node **E** of the tree presented in the following diagram
    consists of node **E** as the root node and node **G** and **H** as the two children.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Leaf node | A node in a tree with no children is called a *leaf* node. For
    example, in the following figure, **D**, **G**, **H,** and **F** are the four
    leaf nodes. |'
  prefs: []
  type: TYPE_TB
- en: '| Internal node | Any node that is neither a root nor a leaf node is an internal
    node. An internal node will have at least one parent and at least one child node.
    |'
  prefs: []
  type: TYPE_TB
- en: Note that trees are a kind of network or graph that we will study in [Chapter
    6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised Machine Learning
    Algorithms*. For graphs and network analysis, we use the terms link or edge instead
    of branches. Most of the other terminology remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Types of trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of trees, which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary tree:** If the degree of a tree is two, that tree is called a *binary
    tree*. For example, the tree shown in the following diagram is a binary tree as
    it has a degree of two:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/28eabe7e-aae6-46a6-8eec-9b13113cc38b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the preceding diagram shows a  tree that has four levels with eight
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Full tree:** A full tree is the one in which all of the nodes are of the
    same degree, which will be equal to the degree of the tree. The following diagram
    shows the kinds of trees discussed earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/5a20e164-3199-48f1-a79d-fde170d1ed32.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the binary tree on the left is not a full tree, as node **C** has
    a degree of one and all other nodes have a degree of two. The tree in the middle
    and the one on the left are both full trees.
  prefs: []
  type: TYPE_NORMAL
- en: '**Perfect tree****:** A perfect tree is a special type of full tree in which
    all the leaf nodes are at the same level. For example, the binary tree on the
    right as shown in the preceding diagram is a perfect, full tree as all the leaf
    nodes are at the same level, that is, **level 2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordered t****ree**: If the children of a node are organized in some order
    according to particular criteria, the tree is called an *ordered tree*. A tree,
    for example, can be ordered left to right in an ascending order in which the nodes
    at the same level will increase in value while traversing from left to right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract data type tree is one of the main data structures that are used
    in developing decision trees as will be discussed in [Chapter 7](e3df232d-9571-4514-a5f1-2789965492e1.xhtml),
    *Traditional Supervised Learning Algorithms*. Due to its hierarchical structure,
    it is also popular in algorithms related to network analysis as will be discussed
    in detail in [Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised
    Machine Learning Algorithms*. Trees are also used in various search and sort algorithms
    where divide and conquer strategies need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed data structures that can be used to implement
    various types of algorithms. After going through this chapter, I expect that you
    should be able to select the right data structure to be used to store and process
    data by an algorithm. You should also be able to understand the implications of
    our choice on the performance of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about sorting and searching algorithms, where we will be
    using some of the data structures presented in this chapter in the implementation
    of the algorithms.
  prefs: []
  type: TYPE_NORMAL
