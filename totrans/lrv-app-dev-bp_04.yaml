- en: Chapter 4. Building a Personal Blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll code a simple personal blog with Laravel. We''ll also
    cover Laravel''s built-in authentication, paginate mechanism, and named routes.
    We''ll elaborate some rapid development methods, which come with Laravel, such
    as creating route URLs. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and migrating the posts database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a posts model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and migrating the authors database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a members-only area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a blog post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning blog posts to users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginating the content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and migrating the posts database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We assume that you have already defined database credentials in the `app/config/database.php`
    file. For this application, we need a database. You can simply create and run
    the following SQL command or basically you can use your database administration
    interface, something like phpMyAdmin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully creating the database for the application, first we need
    to create a posts table and install it in the database. To do this, open up your
    terminal, navigate through your project folder, and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate a migration file under `app/database/migrations`
    for generating a new MySQL table named `posts` in our `laravel_blog` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define our table columns and specifications, we need to edit this file.
    After editing the migration file, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the file, we need to use a simple `artisan` command to execute
    migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If no error occurs, check the `laravel_blog` database for the `posts` table
    and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a posts model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, for anything related to database operations on Laravel, using models
    is the best practice. We will benefit from the Eloquent ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this code in a file named as `Posts.php` under `app/models/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have set the database table name with the protected `$table` variable. We
    have also set editable columns with the `$fillable` variable and timestamps with
    the `$timestamps` variable as we've already seen and used in previous chapters.
    The variables which are defined in the model are enough for using Laravel's Eloquent
    ORM. We'll cover the public `Author()` function in the *Assigning blog posts to
    users* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our posts model is ready. Now we need an authors model and database to assign
    blog posts to authors. Let's investigate Laravel's built-in authentication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and migrating the authors database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contrary to most of the PHP frameworks, Laravel has a basic authentication
    class. The authentication class is very helpful in rapidly developing applications.
    First, we need a secret key for our application. The application secret key is
    very important for our application''s security because all data is hashed salting
    this key. The artisan command can generate this key for us with a single command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If no error occurs, you will see a message that tells you that the key is generated
    successfully. After key generation, if you face problems with opening your Laravel
    application, simply clear your browser cache and try again. Next, we should edit
    the authentication class''s configuration file. For using Laravel''s built-in
    authentication class, we need to edit the configuration file, which is located
    at `app/config/auth.php`. The file contains several options for the authentication
    facilities. If you need to change the table name, and so on, you can make the
    changes under this file. By default, Laravel comes with the `User` model. You
    can see the `User.php` file, which is located at `app/models/`. With Laravel 4,
    we need to define which fields are fillable in our `Users` model. Let''s edit
    `User.php` located at `app/models/` and add the "fillable" array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we need three columns for our authors. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`email`: This column stores author''s e-mails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: This column stores authors'' passwords'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This column stores the authors'' names and surnames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need several migration files to create the `users` table and add an
    author to our database. To create a migration file, give a command such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the migration file, which was created recently and located at `app/database/migrations/`.
    We need to edit the `up()` function as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After editing the migration file, run the `migrate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you know, the command creates the `users` table and its columns. If no error
    occurs, check the `laravel_blog` database for the `users` table and the columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to create a new migration file for adding some authors to the database.
    We can do so by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the migration file and edit the `up()` function as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We used a new class in the `up()` function, which is named `Hash`. Laravel has
    a hash maker/checker class, which is based on secure **Bcrypt**. Bcrypt is an
    accepted, secure hashing method for important data such as passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class for which we have created an application key with the artisan tool
    at the beginning of this chapter is used for salting. So, to apply migration,
    we need to migrate with the following artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check the `users` table for a record. If you check the `password` column,
    you will see a record stored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to securely store your user's passwords and their critical
    data. Do not forget that if you change the application key, all the existing hashed
    records will be unusable because the `Hash` class uses the application key as
    the salting key when validating and storing given data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a members-only area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, our blog system is member based. Because of that we need some areas
    to be accessible by members only, for adding new posts to the blog. We have two
    different methods to do this. The first one is the route filter method, which
    we will elaborate in the next chapters. The second is the template-based authorization
    check. This method is a more effective way of understanding the use of the `Auth`
    class with the **Blade template system**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Auth` class we can check the authorization status of a visitor by
    just a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `check()` function, which is based on the `Auth` class, always returns `true`
    or `false`. So, that means we can easily use the function in an `if/else` statement
    in our code. As you know from previous chapters, with the blade template system
    we were able to use that kind of PHP statement in the template files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the template files we need to write our routes. We need four
    routes for our application. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: A login route to process login requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new post route to process new post requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An admin route to show a new post form and a login form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An index route to list posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Named routing is another amazing feature of the Laravel framework for rapid
    development. Named routes allow referring to routes when generating redirects
    or URLs more comfortably. You may specify a name for a route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also specify route names for controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the named routes, we can easily create URLs for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the named routes to redirect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the route configuration file, which is located at `app/routes.php` and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to write the code for the controller side and templates of our
    application. First, we can start coding from our admin area. Let''s create a file
    under `app/views/` with the name `addpost.blade.php`. Our admin template should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the code, we use `if`/`else` statements in a template to
    check a user''s login credentials. We know already from the beginning of this
    section that we use the `Auth::check()` function to check the login status of
    a user. Also, we''ve used a new method to get the currently logged in user''s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get any information about the current user with the `user` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The template code first checks the login status of the visitor. If the visitor
    has logged in, the template shows a new post form; else it shows a login form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to code the controller side of our blog application. Let''s start
    from our users controller. Create a file under `app/controller/`, which is named
    `UsersContoller.php`. The final code of the controller should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The controller has two functions: the first is the `postLogin()` function.
    This function basically checks the posted form data for user login and then redirects
    the visitor to the `add_new_post` route to show the new post form. The second
    function processes the logout request and redirects to the `index` route.'
  prefs: []
  type: TYPE_NORMAL
- en: Saving a blog post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need one more controller for our blog posts. So, create a file under
    `app/controller/`, that is named `PostsContoller.php`. The final code of the controller
    should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Assigning blog posts to users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `postAdd()` function processes the new blog post create request on the
    database. As you can see, we can get the author''s ID with a previously mentioned
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, we can assign the current user with a blog post. As you will
    see, we have a new method in the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember, we''ve defined a public `Author ()` function in our `Posts`
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `belongsTo()` method is an `Eloquent` function to create relations between
    tables. Basically the function needs one required variable and one optional variable.
    The first variable (required) defines the target `Model`. The second and optional
    variable is to define the source column of the current model's table. If you don't
    define the optional variable, the `Eloquent` class searches the `targetModelName_id`
    column. In the `posts` table, we store the authors' IDs in the `author_id` column,
    not in the column named `user_id`. Because of this, we need to define a second
    optional variable in the function. With this method, we can pass our blog posts
    and all its authors' information to the template file. You can think of the method
    as some kind of a SQL join method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to use these relation functions in queries, we can easily call
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to manage the template files with fewer variables. Now we have just
    one variable to pass the template file, which is combined with all the necessary
    data. So, we need the second template file to list our blog posts. This template
    will work at our blog's frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Listing articles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections of this chapter, we''ve learned to use PHP `if/else`
    statements within blade template files. Laravel passes data to the template file
    as an array. So we need to use the `foreach` loop to parse data into the template
    file. We can also use a `foreach` loop in template files. So create a file under
    `app/views/` named `index.blade.php`. The code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dig the code. We''ve used a `foreach` loop inside the template file
    to parse all blog post data. Also, we see the combined author data usage in the
    `foreach` loop. As you may remember, we get the author information with the `belongsTo()`
    method in the model side. The whole relational data parsing is done inside an
    array, which is named the relation function name. For example, if we had a second
    relation function, which is named `Categories()`, the query would be something
    as follows on the controller side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `foreach` loop would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Paginating the content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eloquent''s `get()` method, which we''ve used in the controller side in the
    `Eloquent` query, fetches all the data from the database with a given condition.
    Often we need to paginate the content for a user-friendly frontend or less page
    loads and optimizations. The `Eloquent` class has a helpful method to do this
    quickly, which is called `paginate()`. This method fetches the data paginated
    and generates paginate links in the template with just a single line of code.
    Open the `app/controllers/PostsController.php` file and change the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paginate()` method paginates the data with the given numeric value. So,
    the blog posts will be paginating each page into `5` blog posts. We have to also
    change our template to show pagination links. Open `app/views/index.blade.php`
    and add the following code after the `foreach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The section in the template, which has the İD as `"main",` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `links()` function will generate pagination links automatically, if there
    is enough data to paginate. Else, the function shows nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've created a simple blog with Laravel's built-in functions
    and the Eloquent database driver. We've learned how to paginate the data and Eloquent's
    basic data relation mechanism. Also we've covered Laravel's built-in authentication
    mechanism. In the next chapters, we'll learn how to work with more complex tables
    and relational data.
  prefs: []
  type: TYPE_NORMAL
