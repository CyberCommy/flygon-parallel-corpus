- en: Handling Change, Dependencies, and Secrets in the System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will describe different elements that interact with multiple
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at strategies on how to make services describe their version so
    that dependent microservices can discover them and be sure that they have the
    proper dependencies already deployed. This will allow us to define a deploying
    order in dependent services and will stop deployment of a service if not all dependencies
    are ready.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes how to define configuration parameters that are cluster-wide,
    so they can be shared across multiple microservices and managed in a single place,
    using Kubernetes ConfigMap. We will also learn how to deal with configuration
    parameters that are secrets—like encryption keys—that should not be accessible
    to most people on the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding shared configuration across microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Kubernetes secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a new feature affecting multiple services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with service dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll know how to prepare dependent services for
    safe deployment and how to include secrets in your microservices that won't be
    accessible outside the deployment they're intended for.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code is available on GitHub at the following URL: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11).
    Note that the code is an extension of the code in `Chapter10`, with extra elements
    as described in this chapter. The structure is the same a subdirectory called
    `microservices` with the code, and another one called `kubernetes` with the Kubernetes
    configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the cluster, you need to build each individual microservice with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will build the required services.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use the `build-test.sh `script. We will explain how it works in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, create the `namespace` example and start the Kubernetes cluster with
    the configuration found in the `Chapter11/kubernetes` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This deploys the microservices to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code included in `Chapter11` has some issues and **won''t** deploy correctly
    until it is fixed. This is the expected behavior. During the chapter, we will
    explain the two problems: the secrets not getting configured, and the dependency
    for Frontend not getting fulfilled, stopping it from starting.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep reading the chapter to find the problems described. The solution is proposed
    as an assessment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to access the different services, you need to update your `/etc/hosts` file
    to include the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With that, you will be able to access services for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding shared configurations across microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some configurations may be common to several microservices. In our example,
    we are duplicating the same values for the database connection. Instead of repeating
    the values on each of the deployment files, we can use ConfigMap and share it
    across the different deployments.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to add ConfigMap to include files in [Chapter 10](ca9b0606-730a-4006-a575-de8e897a19ba.xhtml),
    *Monitoring Logs and Metrics*, under the *Setting up metrics *section. It was
    used for a single service, though.
  prefs: []
  type: TYPE_NORMAL
- en: A ConfigMap is a group of key/value elements. They can be added as environment
    variables or as files. In the next section, we will add a general configuration file
    that includes all the shared variables in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ConfigMap file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `configuration.yaml` file contains the common configuration of the system.
    It is available in the `Chapter11/kubernetes` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The variables related to the database, `DATABASE_ENGINE`, `POSTGRES_USER`, `POSTGRES_HOST`,
    and `POSTGRES_PORT`, are shared across the Thoughts Backend and Users Backend.
  prefs: []
  type: TYPE_NORMAL
- en: The `POSTGRES_PASSWORD` variable is a secret. We will describe this later in
    this chapter in the *Handling Kubernetes secrets *section.
  prefs: []
  type: TYPE_NORMAL
- en: The `THOUGHTS_BACKEND_URL` and `USER_BACKEND_URL` variables are used in the
    Frontend service. They are common across the cluster, though. Any service that
    wants to connect to the Thoughts Backend should use the same URL as described
    in `THOUGHTS_BACKEND_URL`.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it's only used in a single service, Frontend, so far, it fits the
    description of a variable that's system-wide and should be included in the general
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of having a shared repository for variables is to consolidate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: While creating multiple services and developing them independently, it is quite
    common to end up using the same information, but in two slightly different ways.
    Teams developing independently won't be able to share information perfectly, and
    this kind of mismatch will happen.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one service can describe an endpoint as `URL=http://service/api`,
    and another service using the same endpoint will describe it as `HOST=service
    PATH=/api`. The code of each service handles the configuration differently, though
    they connect to the same endpoint. This makes it more difficult to change the
    endpoint in a unified way, as it needs to be changed in two or more places, in
    two ways.
  prefs: []
  type: TYPE_NORMAL
- en: A shared place is a good way to first detect these problems, as they normally
    go undetected if each service keeps its own independent configuration, and then
    to adapt the services to use the same variable, reducing the complexity of the
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The name of ConfigMap in our example is `shared-config` as defined in the metadata
    and, like any other Kubernetes object, it can be managed through `kubectl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Using kubectl commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ConfigMap information can be checked with the usual set of `kubectl` commands.
    This allows us to discover the defined ConfigMap instances in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the number of keys, or variables, that ConfigMap contains is displayed;
    here, it is `6`. To see the content of ConfigMap, use `describe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to change ConfigMap, you can use the `kubectl edit` command, or,
    even better, change the `configuration.yaml` file and reapply it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will overwrite all the values.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration won't be applied automatically to the Kubernetes cluster.
    You'll need to redeploy the pods affected by the changes. The easiest way is to
    delete the affected pods and allow the deployment to recreate them.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if Flux is configured, it will redeploy the dependent pods
    automatically. Keep in mind that a change in ConfigMap (referenced in all pods)
    will trigger a redeploy on all pods in that situation.
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how to add ConfigMap to the deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ConfigMap to the deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once ConfigMap is in place, it can be used to share its variables with different
    deployments, maintaining a central location where to change the variables and
    avoid duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how each of the deployments for the microservices (Thoughts Backend,
    Users Backend, and Frontend) makes use of the `shared-config` ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Thoughts Backend ConfigMap configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Thoughts Backend deployment is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The full `shared-config` ConfigMap will be injected into the pod. Note that
    this includes the `THOUGHTS_BACKEND_URL` and `USER_BACKEND_URL` environment variables that
    previously were not available in the pod. More environment variables can be added.
    Here, we left `POSTGRES_DB` instead of adding it to the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `exec` in the pod to confirm it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that to be able to connect the secret, it should be properly configured.
    Refer to the *Handling Kubernetes secrets* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check inside the container, retrieve the pod name and use `exec` in it,
    as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `env` command returns all the environment variables, but there are a lot
    of them added automatically by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Users Backend ConfigMap configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Users Backend configuration is similar to the previous type of configuration
    we just saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The value of `POSTGRES_DB` is the same as in the Thoughts Backend, but we left
    it here to show how you can add more environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend ConfigMap configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Frontend configuration only uses ConfigMap, as no extra environment variables
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Frontend pods will also now include the information about the connection
    to the database, something that it doesn't require. This is fine for most of the
    configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use multiple ConfigMaps to describe different groups of configurations,
    if necessary. It is simpler to handle them in a big bucket with all the configuration
    parameters, though. This will help to catch duplicated parameters and ensure that
    you have all the required parameters in all microservices.
  prefs: []
  type: TYPE_NORMAL
- en: However, some configuration parameters have to be handled with more care as
    they'll be sensitive. For example, we left out from the `shared-config` ConfigMap
    the `POSTGRES_PASSWORD` variable. This allows us to log into the database, and
    it should not be stored on any file with other parameters, so as to avoid accidental
    exposure.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this kind of information, we can use Kubernetes secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Kubernetes secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets are a special kind of configuration. They need to be protected from
    being read by the other microservices that are using them. They are typically
    sensitive data, such as private keys, encryption keys, and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that reading a secret is a valid operation. After all, they need to
    be used. What differentiates a secret from other configuration parameters is that
    they need to be protected so only the authorized sources are able to read them.
  prefs: []
  type: TYPE_NORMAL
- en: The secrets should be injected by the environment. This requires the code to
    be able to retrieve the configuration secrets and use the proper one for the current
    environment. It also avoids storing the secret inside the code.
  prefs: []
  type: TYPE_NORMAL
- en: Remember *never* to commit production secrets in your Git repositories. The
    Git tree means that, even if it's deleted, the secret is retrievable. This includes
    the GitOps environment.
  prefs: []
  type: TYPE_NORMAL
- en: Also, use different secrets for different environments. The production secrets
    require more care than the ones in test environments.
  prefs: []
  type: TYPE_NORMAL
- en: In our Kubernetes configuration, the authorized sources are the microservices
    using them, as well as administrators of the system, accessing through `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to manage these secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Storing secrets in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes deals with secrets as a particular kind of ConfigMap values. They
    can be defined in the system and then applied in the same say a ConfigMap will
    be. The difference with the general ConfigMaps is that the information is protected
    internally. While they can be accessed through `kubectl`, they are protected against
    accidental exposure.
  prefs: []
  type: TYPE_NORMAL
- en: A secret can be created in the cluster through `kubectl` commands. They should
    *not* be created through files and GitOps or Flux, but manually instead. This
    avoids storing the secrets under the GitOps repo.
  prefs: []
  type: TYPE_NORMAL
- en: The pods that require the secret to operate will indicate so in their deployment
    file. This is safe to store under GitOps source control, as it doesn't store the
    secret but only the reference to the secret. When the pod gets deployed, it will
    use the proper reference and decode secret.
  prefs: []
  type: TYPE_NORMAL
- en: Logging into the pod will grant you access to the secret. This is normal, since,
    inside the pod, the application needs to read its value. Granting access to execute
    commands in the pod will grant them access to the secrets inside, so keep it in
    mind. You can read Kubernetes documentation about the best practices of the secrets
    to understand and adjust depending on your requirements ([https://kubernetes.io/docs/concepts/configuration/secret/#best-practices](https://kubernetes.io/docs/concepts/configuration/secret/#best-practices)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to handle them, let's see how to create these secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the secrets in Kubernetes. We will store the following secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public and private keys to sign and validate requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will store them inside the same Kubernetes secret that can have multiple
    keys. The following commands show how to generate a pair of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These keys are unique to you. We will use them to replace the stored example
    keys in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the secrets in the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Store the secrets in the cluster, under the `thoughts-secrets` secret. Remember
    to store it in the `example` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list the secrets in the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can describe the secrets for more info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can get the content of a secret, but the data gets retrieved encoded in
    Base64.
  prefs: []
  type: TYPE_NORMAL
- en: Base64 is an encoding scheme that allows you to transform binary data into text
    and vice versa. It is widely used. This allows you to store any binary secret,
    not only text. It also means that the secrets are not displayed in plain text
    when retrieved, adding a small layer of protection in cases such as unintentional
    display in screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the secret, use the usual `kubectl get` command as shown here. We
    use the `base64` command to decode it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, if you edit a secret to update it, the input should be encoded
    in Base64.
  prefs: []
  type: TYPE_NORMAL
- en: Secret deployment configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to configure the secret usage in the deployment configuration, so the
    secret is available in the required pod. For example, in the User Backend `deployment.yaml`
    config file, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We create the `POSTGRES_PASSWORD` environment variable that comes directly from
    the secret. We also create a volume called `sign-keys` that contains two keys
    as files, `public_key.pub` and `private_key.pem`. It mounts in the `/opt/keys/` path.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, the `deployment.yaml` file for the Thoughts Backend includes
    secrets, but only the PostgreSQL password and `public_key.pub`. Note that the
    private key is not added, as the Thoughts Backend doesn't require it, and it's
    not available.
  prefs: []
  type: TYPE_NORMAL
- en: For the Frontend, only the public key is required. Now, let's establish how
    to retrieve the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the secrets by the applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the `POSTGRES_PASSWORD` environment variable, we don't need to change anything.
    It was already an environment variable and the code was extracting it from there.
  prefs: []
  type: TYPE_NORMAL
- en: But for the secrets stored as files, we need to retrieve them from the proper
    location. The secrets stored as files are the key to signing the authentication
    headers. The public file is required in all the microservices, and the private
    key only in the Users Backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `config.py` file for the Users Backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The current keys are still there as default values. They will be used for unit
    tests when the secret files are not mounted.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth saying it again, but please *do not* use any of these keys. These
    are for running tests only and available to anyone that has access to this book.
  prefs: []
  type: TYPE_NORMAL
- en: If the files in the `/opt/keys/` path are present, they'll be read, and the
    content will be stored in the proper constant. The Users Backend requires both
    the public and private keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Thoughts Backend `config.py `file, we only retrieve the public key,
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Frontend service adds the public key in the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This configuration makes the secret available for the applications and closes
    the loop for the secret values. Now, the microservices cluster uses the signing
    key from a secret value, which is a safe way of storing sensible data.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a new feature affecting multiple services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about change requests within the realm of a single microservice. But
    what if we need to deploy a feature that works within two or more microservices?
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of features should be relatively rare and are one of the main causes
    of overhead in microservices compared with the monolith approach. In a monolith,
    this case is simply not possible as everything is contained within the walls of
    the monolith.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservice architecture, meanwhile, this is a complex change. This involves
    at least two independent features on each involved microservice that resides in
    two different repos. It is likely that the repos will be developed by two different
    teams, or at least different people will be responsible for each of the features.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying one change at a time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure that the features can be deployed smoothly, one at a time, they need
    to keep backward compatibility. This means that you need to be able to live in
    an intermediate stage when service A has been deployed, but not service B. Each
    change in the microservices needs to be as small as possible to minimize risks,
    and they should be introduced one change at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Why don't we deploy them all simultaneously? Because releasing two microservices
    at the same time is dangerous. To start with, deployments are not instantaneous,
    so there will be moments where out-of-date services will either send or receive calls
    that the system is not prepared to handle. That will create errors that may affect
    your customers.
  prefs: []
  type: TYPE_NORMAL
- en: But there's a chance of a situation occurring where one of the microservices
    is incorrect and needs to be rolled back. Then, the system is left in an inconsistent
    state. The dependent microservice needs to be rolled back as well. This, in itself,
    is problematic, but it can make things worse when, during the debugging of this
    problem, both microservices are stuck and cannot be updated until the problem
    gets fixed.
  prefs: []
  type: TYPE_NORMAL
- en: In a healthy microservice environment, there will be deployments happening quite
    often. Having to stop the pipeline for a microservice because another service
    requires work is a bad position to be in, and it will just add stress and urgency.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we talked about the speed of deployment and change. Deploying
    small increments often is the best way to ensure that each deployment will be
    of high quality. The constant flow of incremental work is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupting this flow due to an error is bad, but the effect multiplies quickly
    if the inability to deploy affects the pace of multiple microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple services being deployed simultaneously may also create a deadlock,
    where both services require work to fix the situation. This complicates the development
    and time to fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simultaneous deployments, analysis needs to be done to determine
    which microservice is dependent on the other. Most of the time, it is obvious.
    In our example, the Frontend is dependent on the Thoughts Backend, so any change
    that involves them both will need to start with the Thoughts Backend and then
    move to the Frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the Users Backend is a dependency of both, so assuming there's a change
    that affects the three of them, you'll need to first change the Users Backend,
    then the Thoughts Backend, and finally the Frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that sometimes, it is possible that deployments need to move across
    services more than once. For example, let''s imagine that we have a change in
    the signing mechanism for the authentication headers. The process then should
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the new authentication system in the Users Backend, but keep producing
    tokens with the old system through a config change. The old authentication process
    is still used in the cluster so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Thoughts Backend to allow working with both the old and the new system
    of authenticating. Note that it is not activated yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Frontend to work with both authentication systems. Still, at this
    point, the new system is not yet used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change configuration in the Users Backend to produce new authentication tokens. Now
    is when the new system starts to be used. While the deployment is underway, some
    old system tokens may be generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Users Backend and Frontend will work with any token in the system, either
    new or old. Old tokens will disappear over time, as they expire. New tokens are
    the only ones being created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an optional stage, the old authentication system can be deleted from the
    systems. The three systems can delete them without any dependency as the system
    is not used at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At any step of the process, the service is not interrupted. Each individual
    change is safe. The process is slowly making the whole system evolve, but each
    of the individual steps is reversible if there's a problem, and the service is
    not interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Systems tend to develop by adding new features, and it is uncommon to have a
    clean-up stage. Normally, systems live with deprecated features for a long time,
    even after the feature is not used anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk a bit more about clean-up in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml),
    *Collaborating and Communicating across Teams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process may also be required for configuration changes. In the example,
    changing the private key required to sign the authentication headers will require
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the Thoughts Backend and Frontend able to handle more than one public key.
    This is a prerequisite and a new feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the handled keys in the Thoughts Backend to have both the old and the
    new public keys. So far, no headers signed with the new key are flowing in the
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the handled keys in the Frontend to have both the old and the new. Still,
    no headers signed with the new key are flowing in the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the configuration of the Users Backend to use the new private key. From
    now on, there are headers signed with the new private key in the system. Other
    microservices are able to handle them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system still accepts headers signed with the old key. Wait for a safe period
    to ensure all old headers are expired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the configuration for the old key in the Users Backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 2 to 6 can be repeated every few months to use new keys.
  prefs: []
  type: TYPE_NORMAL
- en: This process is called **key rotation**, and it is considered a good security
    practice as it reduces the life when a key is valid, reducing the window of time
    the system is vulnerable to a leaked key. For simplicity, we have not implemented
    it in our example system, but doing so is left as a recommended exercise. Try
    to change the example code to implement this key rotation example!
  prefs: []
  type: TYPE_NORMAL
- en: The full system feature may involve multiple services and teams. To help with
    coordinating the dependencies of the system, we need to know when a certain dependency
    of service is deployed and ready to go. We will talk about the inter-team communication
    in [Chapter 12](d1a54332-1f4f-4ec7-a5a4-7ea81121bbea.xhtml), *Collaborating and
    Communicating across Teams*, but we can help programmatically by making the service
    API to explicitly describe which version of the service is deployed, as we will
    discuss in the *Dealing with service dependencies* section.
  prefs: []
  type: TYPE_NORMAL
- en: In case there's a problem in the new version that has just been deployed, the
    deployment can be reverted quickly through a rollback.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back the microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rollback is the process to step back quickly one of the microservices to the
    previous version.
  prefs: []
  type: TYPE_NORMAL
- en: This process can be triggered when there's a catastrophic error in a new version
    just released, so it can be solved quickly. Given that the version was already
    currently compatible, this can be done with confidence in a very short reaction
    time. Through GitOps principles, a `revert` commit can be done to bring back the
    old version.
  prefs: []
  type: TYPE_NORMAL
- en: The `git revert` command allows you to create a commit that undoes another,
    applying the same changes in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: This is a quick way to undo a particular change, and to allow later to *revert
    the revert* and reintroduce the changes. You can check the Git documentation for
    more details ([https://git-scm.com/docs/git-revert](https://git-scm.com/docs/git-revert)[).](https://git-scm.com/docs/git-revert)
  prefs: []
  type: TYPE_NORMAL
- en: Given the strategic approach to keep moving forward, a rollback is a temporary
    measure that, while in place, will stop new deployments in the microservice. A
    new version addressing the bug that caused the catastrophic deployment should
    be created as soon as possible, so as to keep the normal flow of releases.
  prefs: []
  type: TYPE_NORMAL
- en: As you deploy more and more often, and get better checks in place, rollbacks
    will be less and less common.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with service dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow services to check whether their dependencies have the correct version,
    we will make services to expose their version through a RESTful endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow the example in the Thoughts Backend available in GitHub at this
    URL: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/thoughts_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/thoughts_backend).
  prefs: []
  type: TYPE_NORMAL
- en: Check the version is available in the Frontend ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend)).
  prefs: []
  type: TYPE_NORMAL
- en: The first step in the process is to properly define the version for each service.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning the services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow a clear understanding of progress in our software, we need to name
    the different versions to be deployed. As we use `git` to keep track of changes,
    every commit in the system has an individual commit ID, but it doesn't follow
    any specific pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To give a meaning to it and order them, we need to develop a version schema.
    There are multiple ways of making a version schema, including by release date
    (Ubuntu uses this one) or by `major.minor.patch`.
  prefs: []
  type: TYPE_NORMAL
- en: Having the same versioning scheme everywhere helps to develop a common language
    and understanding across teams. It also helps management to understand the changes—both
    in terms of when things are released, as well as how quickly they are changing. Agree
    with your teams a versioning scheme that makes sense in your organization, and
    follow it in all services.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will use a `vMajor.Minor` schema and the version for the
    Users Backend as `v2.3`.
  prefs: []
  type: TYPE_NORMAL
- en: The most common pattern in software versioning is semantic versioning. This
    versioning pattern is useful for packages and customer-facing APIs, but less useful
    for internal microservice APIs. Let's see what its characteristics are.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Semantic versioning imposes meaning to the change on each of the different version
    numbers. This makes it easy to understand the scope of changes between versions
    and whether the update is risky to do on a dependent system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantic versioning defines each version with three numbers: major, minor,
    and patch, normally described as `major.minor.patch`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Increasing any of these numbers carries a particular meaning, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the major number produces backward-incompatible changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the minor number adds new features, but keeps backward-compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the patch number fixes bugs, but doesn't add any new features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, Python works under this schema as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 included compatibility changes with Python 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python version 3.7 introduced new features compared with Python 3.6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And Python 3.7.4 added security and bug fixes compared with Python 3.7.3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This versioning scheme is useful in communicating with external partners and
    is great for big releases and standard packages. But for small incremental changes
    in microservices, it is not very useful.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in previous chapters, the key to continuous integration to be
    delivered is to make very small changes. They should not break backward compatibility,
    but, over time, old features will be dropped. Each microservice works in unison
    with other services, in a controlled manner. There's no need to have such a strong
    feature labeling, compared with an external package. The consumers of the service
    are the other microservices, under tight control in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Some projects are abandoning semantic versioning due to this change in operation.
    For example, the Linux kernel stopped using semantic versioning to produce new
    versions without any particular meaning ([http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html](http://lkml.iu.edu/hypermail/linux/kernel/1804.1/06654.html)),
    as changes from one version to the next are relatively small.
  prefs: []
  type: TYPE_NORMAL
- en: Python will also treat version 4.0 as *the version that goes after 3.9*, without
    major changes like Python 3 had ([http://www.curiousefficiency.org/posts/2014/08/python-4000.html](http://www.curiousefficiency.org/posts/2014/08/python-4000.html)).
  prefs: []
  type: TYPE_NORMAL
- en: That's why, internally, semantic versioning is *not* recommended. It may be
    useful to keep a similar versioning scheme, but without forcing it to make compatibility
    changes, just ever-increasing numbers, without specific requirements on when to
    change minor or major versions.
  prefs: []
  type: TYPE_NORMAL
- en: Externally, though, version numbers may still have a marketing meaning. For externally
    accessible endpoints, it may be interesting to use semantic versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Once decided which version the service is, we can work on an endpoint that exposes
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a version endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The version to be deployed can be read from either the Kubernetes deployment
    or from the GitOps configuration. But there is a problem. Some of the configurations
    could be misleading or not uniquely pointing to a single image. For example, the `latest` tag may
    represent different containers at different times, as it gets overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there's a problem of having access to the Kubernetes configuration or
    GitOps repo. For a developer, maybe this configuration is available, but they
    won't be for the microservices (nor should they be).
  prefs: []
  type: TYPE_NORMAL
- en: To allow the remainder of the microservices in the cluster to discover the version
    of the service, the best way is to explicitly create a version endpoint in the
    RESTful API. The discovery of the service version is granted, as it uses the same
    interface it will use in any other request. Let's see how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To serve the version, we first need to record it into the service.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed previously, the version is stored as a Git tag. This will be
    our canon in the version. We will add the Git SHA-1 of the commit as well to avoid
    any discrepancies.
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-1 is a unique ID that identifies each commit. It's produced by hashing
    the Git tree, so that it's able to capture any change—either the content or the
    tree history. We will use the full SHA-1 of 40 characters, even though sometimes
    it is abbreviated to eight or less.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commit SHA-1 can be obtained with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This prints the last commit information, and only the SHA with the `%H` descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the tag this commit refers to, we will use the `git-describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, `git-describe` finds the closest tags to the current commit. If
    this commit is marked by a tag, as it should be for our deployments, it returns
    the tag itself. If it''s not, it suffixes the tag with extra information about
    the commits until it reaches the current one. The following code shows how to
    use `git describe`, depending on the committed version of the code. Note how the
    code not associated with a tag returns the closest tag and extra digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This always returns a version and allows us to check at a glance whether the
    code in the current commit is tagged in `git` or not.
  prefs: []
  type: TYPE_NORMAL
- en: Anything that gets deployed to an environment should be tagged. Local development
    is a different matter, as it consists of code that is not ready yet.
  prefs: []
  type: TYPE_NORMAL
- en: We can store these two values programmatically, allowing us to do it automatically
    and including them in the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the version in the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to have the version available inside the image. Because the image is
    immutable, doing so during the build process is the objective. The limitation
    we need to overcome here is that the Dockerfile process does not allow us to execute
    commands on the host, only inside the container. We need to inject those values
    in the Docker image while building.
  prefs: []
  type: TYPE_NORMAL
- en: A possible alternative is to install Git inside the container, copy the whole
    Git tree, and obtain the values. This is usually discouraged because installing
    Git and the full source tree adds a lot of space to the container, something that
    is worse. During the build process, we already have Git available, so we just
    need to be sure to inject it externally, which is easy to do with a build script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of passing the value is through the `ARG` parameters. As a
    part of the build process, we will transform them into environment variables,
    so they''ll be as easily available as any other part of the configuration. Let''s
    take a look at the Dockerfile in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We accept an `ARG` parameter and then transform it into an environment variable
    through the `ENV` parameter. Both have the same name for simplicity. The `ARG`
    parameter has a default value for corner cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes the version available (inside the container) after we build it with
    the `build.sh` script, which obtains the values and calls `docker-compose` to
    build with the version as arguments, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After the build process, the version is available as standard environment variables
    inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: We included a script (`build-test.sh `) in each of the microservices in this
    chapter  (for example, [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/build-test.sh](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/build-test.sh)).
    This mocks the SHA-1 and version name to create a synthetic version for tests.
    It sets up the `v2.3` version for the Users Backend and `v1.5` for the Thoughts
    Backend. These will be used for examples in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Check that the Kubernetes deployments include those versions (for example, the [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/docker-compose.yaml#L21](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter11/microservices/thoughts_backend/docker-compose.yaml#L21)
    image is the `v1.5` version).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, `VERSION_NAME` can also come from the CI pipeline as a parameter
    to the script. To do so, you''ll need to replace the script to accept it externally,
    as seen in the `build-ci.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All the versions of these scripts include the tagging of the image with `VERSION_NAME` as
    a tag.
  prefs: []
  type: TYPE_NORMAL
- en: We can retrieve the environment variables with the version inside the container
    in the Python code, returning them in an endpoint, making the version easily accessible
    through the external API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the version endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `admin_namespace.py` file, we will create a new `Version` endpoint using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now this code is very simple. It uses `os.environ` to retrieve the environment
    variables injected during the build as configuration parameters and return a dictionary
    with the commit SHA-1 and tag (described as a version).
  prefs: []
  type: TYPE_NORMAL
- en: 'The service can be built and run locally, using `docker-compose`. To test access
    to the endpoint in `/admin/version` and to check it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As the version is available, we can update the autogenerated documentation
    to display the correct value, as shown in `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So the version gets properly displayed in the automatic Swagger documentation.
    Once the version for a microservice is accessible through an endpoint in the API,
    other external services can access it to discover the version and make use of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to check the version through the API allows us to access the version
    easily in a programmatic way. This can be used for multiple purposes, like generating
    a dashboard displaying the different versions deployed in different environments.
    But we will explore the possibility to introduce service dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: A microservice, when it starts, can check the services it depends on, and also
    checks whether they are higher than an expected version. If they're not, it will
    not start. This avoids configuration problems when one dependent service gets
    deployed before the dependency is updated. This can happen in complex systems
    where there's no great coordination in deployments.
  prefs: []
  type: TYPE_NORMAL
- en: To check the version, when starting the server in `start_server.sh`, we will first call
    a small script that checks the dependency. If it is not available, it will produce
    an error and stop. We will check that the Frontend has an available version of
    the Thought Backend or even higher.
  prefs: []
  type: TYPE_NORMAL
- en: The script, which we will call in our example, is called `check_dependencies_services.py`,
    and it gets called in `start_server.sh` for the Frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `check_dependencies_services` script can be divided into three parts: a
    list of the dependencies required; a check for one dependency; and a main section
    where each of the dependencies is checked. Let''s take a look at the three parts.'
  prefs: []
  type: TYPE_NORMAL
- en: Required version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section describes each of the dependencies and the minimum version
    required. In our example, we stipulate that `thoughts_backend` needs to be version `v1.6` or
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This reuses the environment variable, `THOUGHTS_BACKEND_URL`, and completes
    the URL with the specific version path.
  prefs: []
  type: TYPE_NORMAL
- en: The main section goes through all the dependencies described to check them.
  prefs: []
  type: TYPE_NORMAL
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main function iterates through the `VERSIONS` dictionary and, for each
    one, does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calls the endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parses the result and gets the version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls `check_version` to see whether it's correct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it fails, it ends with a `-1` status, so the script reports as failed. These
    steps are executed through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The main function also prints some messages to help to understand the different
    stages. To call the version endpoint, it uses the `requests` package and expects
    both a `200` status code and a parsable JSON result.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this code iterates through the `VERSION` dictionary. So far, we only
    added one dependency, but the User Backend is another dependency and can be added.
    It's left as an exercise to do.
  prefs: []
  type: TYPE_NORMAL
- en: The version field will be checked in the `check_version` function, which we
    will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `check_version` function checks whether the current version returned is
    higher or equal to the minimum version. To simplify it, we will use the `natsort` package to
    sort the versions and then check the lowest.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the `natsort` full documentation ([https://github.com/SethMMorton/natsort](https://github.com/SethMMorton/natsort)).
    It can sort a lot of natural strings and can be used in a lot of situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, `natsort `supports ordering common patterns of versioning, which
    includes our standard versioning schema described previously (`v1.6` is higher
    than `v1.5`). The following code uses the library to sort both versions and verify
    that the minimum version is the lower one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With this script, we can now start the service and it will check whether the
    Thoughts Backend has the proper version. If you started the service as described
    in the *Technical requirements* section, you''ll see that the Frontend is not
    starting properly, and produces a `CrashLoopBackOff` status, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the logs of one of the Frontend pods to see the reason, using the `kubectl
    logs` command, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To fix the problem, you need to either build a version of the Thoughts Backend
    with a higher version or reduce the dependency requirement. This is left as an
    assessment at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deal with elements that work with several
    microservices at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: First, we talked about strategies to follow when new features need to change
    multiple microservices, including how to deploy small increments in an ordered
    fashion and to be able to roll back if there's a catastrophic problem.
  prefs: []
  type: TYPE_NORMAL
- en: We then talked about defining a clear versioning schema, and adding a version
    endpoint to the RESTful interfaces that allow self-discovery of the version for
    microservices. This self-discovery can be used to ensure that a microservice that
    depends on another is not deployed if the dependency is not there, which helps
    in coordinating releases.
  prefs: []
  type: TYPE_NORMAL
- en: The code in GitHub for the Frontend in this chapter ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter11/microservices/frontend))
    includes a dependency to the Thoughts Backend that will stop deploying it. Note
    that the code, as is, won't work. Fixing it is left as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use ConfigMap to describe configuration information that's
    shared across different services in the Kubernetes cluster. We later described
    how to use Kubernetes secrets to handle a configuration that's sensitive and requires
    extra care.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see the various techniques for coordinating, in
    a highly effective manner, different teams working with different microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the differences between releasing changes in a microservice architecture
    system and a monolith?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should the released changes be small in a microservice architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does semantic versioning work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the problems associated with semantic versioning for internal interfaces
    in a microservice architecture system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of adding a version endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we fix the dependency problem in this chapter's code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which configuration variables should we store in a shared ConfigMap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you describe the advantages and disadvantages of getting all the configuration
    variables in a single shared ConfigMap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a Kubernetes ConfigMap and a Kubernetes secret?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we change a Kubernetes secret?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine that, based on the configuration, we decided to change the `public_key.pub` file
    from a secret to a ConfigMap. What changes do we have to implement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For handling your secrets on AWS, you can interact with a tool called CredStash
    ([https://github.com/fugue/credstash](https://github.com/fugue/credstash)). You
    can learn more about how to use it in the book *AWS SysOps Cookbook – Second Edition* ([https://www.packtpub.com/cloud-networking/aws-administration-cookbook-second-edition](https://www.packtpub.com/cloud-networking/aws-administration-cookbook-second-edition)).
  prefs: []
  type: TYPE_NORMAL
