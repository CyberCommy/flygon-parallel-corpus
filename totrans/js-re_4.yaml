- en: Chapter 4. Regex in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we covered Regex's syntax in depth, and at this
    point, have all the pieces required to build a real-world project, which will
    be the goal of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing Regex's syntax allows you to model text patterns, but sometimes coming
    up with a good reliable pattern can be more difficult, so taking a look at some
    actual use cases can really help you learn some common design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will develop a form, and we will explore the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating a name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating a Twitter username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions and form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By far, one of the most common uses for regular expressions on the frontend
    is for use with user submitted forms, so this is what we will be building. The
    form we will be building will have all the common fields, such as name, e-mail,
    website, and so on, but we will also experiment with some text processing besides
    all the validations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real-world applications, you usually are not going to implement the parsing
    and validation code manually. You can create a regular expression and rely on
    some JavaScript libraries, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jQuery validation**: Refer to [http://jqueryvalidation.org/](http://jqueryvalidation.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsely.js**: Refer to [http://parsleyjs.org/](http://parsleyjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even the most popular frameworks support the usage of regular expressions with
    its native validation engine, such as **AngularJS** (refer to [http://www.ng-newsletter.com/posts/validations.html](http://www.ng-newsletter.com/posts/validations.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This demo will be for a site that allows users to create an online bio, and
    as such, consists of different types of fields. However, before we get into this
    (since we won't be building a backend to handle the form), we are going to setup
    some HTML and JavaScript code to catch the form submission and extract/validate
    the data entered in it.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the code neat, we will create an array with all the validation functions,
    and a data object where all the final data will be kept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic outline of the HTML code for which we begin by adding fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to write some JavaScript to catch the form and run through the
    list of functions that we will be writing. If a function returns false, it means
    that the verification did not pass and we will stop processing the form. In the
    event where we get through the entire list of functions and no problems arise,
    we will log out of the console and data object, which contain all the fields we
    extracted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript starts by creating the two variables I mentioned previously,
    we then pull the form's object from the DOM and set the submit handler. The `submit`
    handler begins by preventing a page from actually submitting, (as we don't have
    any backend code in this example) and then we go through the list of functions
    running them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Validating fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to validate different types of fields manually,
    such as name, e-mail, website URL, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a complete name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get our feet wet, let''s begin with a simple name field. It''s something
    we have gone through briefly in the past, so it should give you an idea of how
    our system will work. The following code goes inside the script tags, but only
    after everything we have written so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We get the name field in a similar way to how we got the form, then, we extract
    the value and test it against a pattern to match a full name. If the name doesn't
    match the pattern, we simply alert the user and return `false` to let the form
    handler know that the validations have failed. If the name field is in the correct
    format, we set the corresponding fields on the data object (remember, the middle
    name is optional here). The last line just adds this function to the array of
    functions, so it will be called when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing required to get this working is to add HTML for this form field,
    so inside the form tags (right before the submit button), you can add this text
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening this page in your browser, you should be able to test it out by entering
    different values into the **Name** box. If you enter a valid name, you should
    get the data object printed out with the correct parameters, otherwise you should
    be able to see this alert message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matching a complete name](img/2258OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the complete name Regex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to the regular expression used to match the name entered by
    a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a brief explanation of the Regex:'
  prefs: []
  type: TYPE_NORMAL
- en: The `^` character asserts its position at the beginning of a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first capturing group `(\S+)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S+` matches a non-white space character [`^\r\n\t\f`]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second capturing group `(\S*)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S*` matches any non-whitespace character [`^\r\n\t\f`]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `*` quantifier between zero and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`" ?"` matches the whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` quantifier between zero and one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b` asserts its position at a (`^\w|\w$|\W\w|\w\W`) word boundary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third capturing group `(\S+)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\S+` matches a non-whitespace character [`^\r\n\t\f`]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` asserts its position at the end of a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching an e-mail with Regex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next type of field we may want to add is an e-mail field. E-mails may look
    pretty simple at first glance, but there are a large variety of e-mails out there.
    You may just think of creating a `word@word.word` pattern, but the first section
    can contain many additional characters besides just letters, the domain can be
    a subdomain, or the suffix could have multiple parts (such as `.co.uk` for the
    UK).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our pattern will simply look for a group of characters that are not spaces
    or instances where the `@` symbol has been used in the first section. We will
    then want an `@` symbol, followed by another set of characters that have at least
    one period, followed by the suffix, which in itself could contain another suffix.
    So, this can be accomplished in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pattern of our example is very simple and will not match every valid e-mail
    address. There is an official standard for an e-mail address's regular expressions
    called **RFC 5322**. For more information, please read [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add the field to our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add this function to verify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an HTML5 field type specifically designed for e-mails, but here we
    are verifying manually, as this is a Regex book. For more information, please
    refer to [http://www.w3.org/TR/html-markup/input.email.html](http://www.w3.org/TR/html-markup/input.email.html).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the e-mail Regex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is a brief explanation of the Regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^` asserts a position at the beginning of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^\s@]+` matches a single character that is not present in the following list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches any white space character [`\r\n\t\f` ]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@` matches the `@` literal character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^\s@.]+` matches a single character that is not present in the following
    list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches a [`\r\n\t\f`] whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@.` is a single character in the `@.` list, literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\.` matches the `.` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^\s@]+` match a single character that is not present in the following list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches [`\r\n\t\f`] a whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@` is the `@` literal character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` asserts its position at end of a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching a Twitter name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next field we are going to add is a field for a Twitter username. For the
    unfamiliar, a Twitter username is in the `@username` format, but when people enter
    this in, they sometimes include the preceding `@` symbol and on other occasions,
    they only write the username by itself. Obviously, internally we would like everything
    to be stored uniformly, so we will need to extract the username, regardless of
    the `@` symbol, and then manually prepend it with one, so regardless of whether
    it was there or not, the end result will look the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'So again, let''s add a field for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write the function to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If a user inputs the `@` symbol, it will be ignored, as we will add it manually
    after checking the username.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the twitter username Regex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a brief explanation of the Regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^` asserts its position at start of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@?` matches the `@` character, literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` quantifier between zero and one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First capturing group `(\w+)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w+` matches a [`a-zA-Z0-9_`] word character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` asserts its position at end of a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another popular field, which can have some unique constraints, is a password
    field. Now, not every password field is interesting; you may just allow just about
    anything as a password, as long as the field isn't left blank. However, there
    are sites where you need to have at least one letter from each case, a number,
    and at least one other character. Considering all the ways these can be combined,
    creating a pattern that can validate this could be quite complex. A much better
    solution for this, and one that allows us to be a bit more verbose with our error
    messages, is to create four separate patterns and make sure the password matches
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the input, it''s almost identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process_password` function is not very different from the previous example
    as we can see its code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All in all, you may say that this is a pretty basic validation and something
    we have already covered, but I think it's a great example of working smart as
    opposed to working hard. Sure, we probably could have created one long pattern
    that would check everything together, but it would be less clear and less flexible.
    So, by breaking it into smaller and more manageable validations, we were able
    to make clear patterns, and at the same time, improve their usability with more
    helpful alert messages.
  prefs: []
  type: TYPE_NORMAL
- en: Matching URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s create a field for the user''s website; the HTML for this field
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A URL can have many different protocols, but for this example, let's restrict
    it to only http or https links. Next, we have the domain name with an optional
    subdomain, and we need to end it with a suffix. The suffix itself can be a single
    word, such as .com or it can have multiple segments, such as.co.uk.
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, our pattern looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using multiple noncapture groups, both for when sections are optional
    and for when we want to repeat a segment. You may have also noticed that we are
    using the case insensitive flag (`/i`) at the end of the regular expression, as
    links can be written in lowercase or uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll implement the actual function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be pretty familiar with the process of adding fields
    to our form and adding a function to validate them. So, for our remaining examples
    let's shift our focus a bit from validating inputs to manipulating data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the URL Regex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a brief explanation of the Regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^` asserts its position at start of a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:https?:\/\/)?` is anon-capturing group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` quantifier between zero and one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http` matches the http characters literally (case-insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s?` matches the `s` character literally (case-insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` quantifier between zero and one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:` matches the `:` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\/` matches the `/` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\/` matches the `/` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w+` matches a [`a-zA-Z0-9_`] word character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:\.\w+)?` is a non-capturing group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` quantifier between zero and one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\.` matches the `.` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\w+` matches a [`a-zA-Z0-9_`] word character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:\.[A-Z]{2,3})+` is a non-capturing group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\.` matches the `.` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[A-Z]{2,3}` matches a single character present in this list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{2,3}` quantifier between`2` and `3` times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A-Z` is a single character in the range between A and Z (case insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` asserts its position at end of a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i` modifier: insensitive. Case insensitive letters, meaning it will match
    a-z and A-Z.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to add one more input to our form, which will be for the user's
    description. In the description, we will parse for things, such as e-mails, and
    then create both a plain text and HTML version of the user's description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML for this form is pretty straightforward; we will be using a standard
    textbox and give it an appropriate field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s start with the bare scaffold needed to begin processing the form
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code gets the text from the textbox on the page and then saves both a plain
    text version and an HTML version of it. At this stage, the HTML version is simply
    the plain text version wrapped between a pair of paragraph tags, but this is what
    we will be working on now. The first thing I want to do is split between paragraphs,
    in a text area the user may have different split-ups—lines and paragraphs. For
    our example, let's say the user just entered a single new line character, then
    we will add a `<br />` tag and if there is more than one character, we will create
    a new paragraph using the `<p>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Using the String.replace method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use JavaScript's replace method on the string object This function
    can accept a Regex pattern as its first parameter, and a function as its second;
    each time it finds the pattern it will call the function and anything returned
    by the function will be inserted in place of the matched text.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for our example, we will be looking for new line characters, and in the
    function, we will decide if we want to replace the new line with a break line
    tag or an actual new paragraph, based on how many new line characters it was able
    to pick up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you may notice is that we need to use the `g` flag in the pattern,
    so that it will look for all possible matches as opposed to only the first. Besides
    this, the rest is pretty straightforward. Consider this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the String.replace method](img/2258OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you take a look at the output from the console of the preceding code, you
    should get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the String.replace method](img/2258OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Matching a description field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we need to do is try and extract e-mails from the text and automatically
    wrap them in a link tag. We have already covered a Regexp pattern to capture e-mails,
    but we will need to modify it slightly, as our previous pattern expects that an
    e-mail is the only thing present in the text. In this situation, we are interested
    in all the e-mails included in a large body of text.
  prefs: []
  type: TYPE_NORMAL
- en: If you were simply looking for a word, you would be able to use the `\b` matcher,
    which matches any boundary (that can be the end of a word/the end of a sentence),
    so instead of the dollar sign, which we used before to denote the end of a string,
    we would place the boundary character to denote the end of a word. However, in
    our case it isn't quite good enough, as there are boundary characters that are
    valid e-mail characters, for example, the period character is valid. To get around
    this, we can use the boundary character in conjunction with a lookahead group
    and say we want it to end with a word boundary, but only if it is followed by
    a space or end of a sentence/string. This will ensure we aren't cutting off a
    subdomain or a part of a domain, if there is some invalid information mid-way
    through the address.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we aren't creating something that will try and parse e-mails no matter
    how they are entered; the point of creating validators and patterns is to force
    the user to enter something logical. That said, we assume that if the user wrote
    an e-mail address and then a period, that he/she didn't enter an invalid address,
    rather, he/she entered an address and then ended a sentence (the period is not
    part of the address).
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we assume that to the end an address, the user is either going
    to have a space after, such as some kind of punctuation, or that he/she is ending
    the string`/`line. We no longer have to deal with lines because we converted them
    to HTML, but we do have to worry that our pattern doesn't pick up an HTML tag
    in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this, our pattern will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We start off with a word boundary, then, we look for the pattern we had before.
    I added both the (`>`) greater-than and the (`<`) less-than characters to the
    group of disallowed characters, so that it will not pick up any HTML tags. At
    the end of the pattern, you can see that we want to end on a word boundary, but
    only if it is followed by a space, an HTML tag, or the end of a string. The complete
    function, which does all the matching, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can continue to add fields, but I think the point has been understood. You
    have a pattern that matches what you want, and with the extracted data, you are
    able to extract and manipulate the data into any format you may need.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the description Regex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go back to the regular expression used to match the name entered by
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a brief explanation of the Regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\b` asserts its position at a (`^\w|\w$|\W\w|\w\W`) word boundary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^\s<>@]+` matches a single character not present in the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches a [`\r\n\t\f` ] whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<>@` is a single character in the `<>@` list (case-sensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@` matches the `@` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^\s<>@.]+` matches a single character not present in this list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches any [`\r\n\t\f`] whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<>@.` is a single character in the `<>@.` list literally (case sensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\.` matches the `.` character literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[^\s<>@]+` matches a single character not present in this the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `+` quantifier between one and unlimited times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\s` matches a [`\r\n\t\f` ] whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<>@` isa single character in the `<>@` list literally (case sensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b` asserts its position at a (`^\w|\w$|\W\w|\w\W`) word boundary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?=.?(?:\s|<|$))` Positive lookahead - Assert that the Regex below can be
    matched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.?` matches any character (except new line)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `?` quantifier between zero and one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(?:\s|<|$)` is a non-capturing group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First alternative: `\s` matches any white space character [`\r\n\t\f`]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second alternative: `<` matches the character `<` literally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third alternative: `$` assert position at end of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `g` modifier: global match. Returns all matches of the regular expression,
    not only the first one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining a Markdown example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More examples of regular expressions can be seen with the popular **Markdown**
    syntax (refer to [http://en.wikipedia.org/wiki/Markdown](http://en.wikipedia.org/wiki/Markdown)).
    This is a situation where a user is forced to write things in a custom format,
    although it''s still a format, which saves typing and is easier to understand.
    For example, to create a link in Markdown, you would type something similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This would then be converted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Disregarding any validation on the URL itself, this can easily be achieved
    using this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It looks a little complex, because both the square brackets and parenthesis
    are both special characters that need to be escaped. Basically, what we are saying
    is that we want an open square bracket, anything up to the closing square bracket,
    then we want an open parenthesis, and again, anything until the closing parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good website to write markdown documents is [http://dillinger.io/](http://dillinger.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we wrapped each section into its own capture group, we can write this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We haven't been using capture groups in our manipulation examples, but if you
    use them, then the first parameter to the callback is the entire match (similar
    to the ones we have been working with) and then all the individual groups are
    passed as subsequent parameters, in the order that they appear in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a couple of examples that showed us how to both
    validate user inputs as well as manipulate them. We also took a look at some common
    design patterns and saw how it's sometimes better to simplify the problem instead
    of using brute force in one pattern for the purpose of creating validations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue exploring some real-world problems by
    developing an application with **Node.js**, which can be used to read a file and
    extract its information, displaying it in a more user friendly manner.
  prefs: []
  type: TYPE_NORMAL
