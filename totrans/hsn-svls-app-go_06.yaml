- en: Deploying Your Serverless Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we learned how to build a serverless API from scratch.
    In this chapter, we will try to accomplish the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build, deploy, and manage our Lambda functions going through some advanced AWS
    CLI commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish multiple versions of the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to separate multiple deployment environments (sandbox, staging, and
    production) with aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover the usage of the API Gateway stage variables to change the method endpoint's
    behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda CLI commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through the various AWS Lambda commands that you
    might use while building your Lambda functions. We will also learn how you use
    them to automate your deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: The list-functions command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall, this command was introduced in [Chapter 2](52476096-dfc4-445d-ab4c-df692471bff7.xhtml),
    *Getting Started with AWS Lambda*. As its name implies, it lists all Lambda functions
    in the AWS region you provided. The following command will return all Lambda functions
    in the North Virginia region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For each function, the response includes the function''s configuration information
    (`FunctionName`, Resources usage, `Environment` variables, IAM Role, `Runtime`
    environment, and so on), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f3674b0-2fca-4d32-83e7-5b3fbe287e66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To list only some attributes, such as the function name, you can use the `query`
    filter option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The create-function command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've read through the preceding chapters, you should be familiar with this
    command as it has been used multiple times to create a new Lambda function from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the function''s configuration, you can use the command to provide
    the deployment package (ZIP) in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ZIP file**: It provides the path to the ZIP file of the code you are uploading
    with the `--zip-file` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**S3 Bucket object**: It  provides the S3 bucket and object name with the `--code`
    option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The as-mentioned commands will return a summary of the function''s settings
    in a JSON format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dff57c7d-d25e-456b-a915-b9c2200697bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s worth mentioning that while creating your Lambda function, you might
    override the compute usage and network settings based on your function''s behavior
    with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--timeout`: The default execution timeout is three seconds. When the three
    seconds are reached, AWS Lambda terminates your function. The maximum timeout
    you can set is five minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--memory-size`: The amount of memory given to your function when executed.
    The default value is 128 MB and the maximum is 3,008 MB (increments of 64 MB).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--vpc-config`: This deploys the Lambda function in a private VPC. While it
    might be useful if the function requires communication with internal resources,
    it should ideally be avoided as it impacts the Lambda performance and scaling
    (this will be discussed in upcoming chapters).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS doesn't allow you to set the CPU usage of your function as it's calculated
    automatically based on the memory allocated for your function. CPU usage is proportional
    to the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The update-function-code command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to AWS Management Console, you can update your Lambda function''s
    code with AWS CLI. The command requires the target Lambda function name and the
    new deployment package. Similarly to the previous command, you can provide the
    package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The path to the new `.zip` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The S3 bucket where the `.zip` file is stored:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation prints a new unique ID (called `RevisionId`) for each change
    in the Lambda function''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b88a78d-a93b-4d00-9be4-b35adbc7f447.png)'
  prefs: []
  type: TYPE_IMG
- en: The get-function-configuration command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to retrieve the configuration information of a Lambda function, issue
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will provide the same information in the output that was
    displayed when the `create-function` command was used.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve configuration information for a specific Lambda version or alias
    (following section), you can use the `--qualifier` option.
  prefs: []
  type: TYPE_NORMAL
- en: The invoke command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we invoked our Lambda functions directly from AWS Lambda Console and
    through HTTP events with API Gateway. In addition to that, Lambda can be invoked
    from the AWS CLI with the `invoke` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will invoke the `UpdateMovie` function and save the function''s
    output in `result.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bf38ec4-0da7-4488-8e80-638a8f6613c7.png)'
  prefs: []
  type: TYPE_IMG
- en: The status code is 400, which is normal, as `UpdateFunction` is expecting a
    JSON input. Let's see how to provide a JSON to our function with the `invoke`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to the DynamoDB `movies` table, and pick up a movie that you want
    to update. In this example, we will update the movie with the ID as 13, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf4c4a5a-47d0-4cff-8131-68edd932fb20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a JSON file with a `body` attribute that contains the new movie item
    attribute, as the Lambda function is expecting the input to be in the API Gateway
    Proxy request format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the `invoke` function command again with the JSON file as the
    input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print the `result.json` content, the updated movie should be returned,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0e91b21-4b46-4ba5-a805-6b9cf5783fcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can verify that the movie''s name is updated in the DynamoDB table by invoking
    the `FindAllMovies` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `body` attribute should contain the new updated movie, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d2551c4-7c08-45ab-833a-d237a6585924.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Head back to DynamoDB Console; the movie with the ID of 13 should have a new
    name, as shown in the following  screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc7602d9-b2e1-400c-9718-68dd610decc2.png)'
  prefs: []
  type: TYPE_IMG
- en: The delete-function command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete a Lambda function, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, the command will delete all function versions and aliases. To delete
    a specific version or alias, you might want to use the `--qualifier` option.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be familiar with all the AWS CLI commands you might use and
    need while building your serverless applications in AWS Lambda. In the upcoming
    section, we will see how to create different versions of your Lambda functions
    and maintain multiple environments with aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Versions and aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're building your serverless application, you must separate your deployment
    environments to test new changes without impacting your production. Therefore,
    having multiple versions of your Lambda functions makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A version represents a state of your function''s code and configuration in
    time. By default, each Lambda function has the `$LATEST` version pointing to the
    latest changes of your function, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0af4671-f79f-4c0b-a52e-53d80a392b58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to create a new version from the `$LATEST` version, click on Actions and
    Publish new version. Let''s call it `1.0.0`, as shown in  the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e0d3aa0-b07c-48bc-adc8-f9bf75607245.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The new version will be created with an ID=1 (incremental). Note the ARN Lambda
    function at the top of the window in the following screenshot; it has the version
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f123634e-9126-42a6-bf0b-ce5ffcae414b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the version is created, you cannot update the function code, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c93eb73c-fb64-48ae-9a55-7d0b047a6b7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moreover, advanced settings, such as IAM roles, network configuration, and
    compute usage, cannot be changed, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9fff6eb-11e2-4438-8632-92fc609387a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Versions are called **immutable**, which means they cannot be changed once they're
    published; only the `$LATEST` version is editable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to publish a new version from the console. Let's publish a
    new version with the AWS CLI. But first, we need to update the `FindAllMovies`
    function as we cannot publish a new version if no changes were made to `$LATEST`
    since publishing version `1.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new version will have a pagination system. The function will return only
    the number of items requested by the user. The following code will read the `Count`
    header parameter, convert it to a number, and use the `Scan` operation with the `Limit`
    parameter to fetch the movies from DynamoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the `FindAllMovies` Lambda function''s code with the `update-function-code`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, publish a new version, `1.1.0`, based on the current configuration and
    code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to AWS Lambda Console and navigate to your `FindAllMovies`; a new version
    should be created with a new ID=2, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93db27df-86fe-4dd5-b7c7-cd37eb140f69.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our versions are created, let's test them out by using the AWS CLI
    `invoke` command.
  prefs: []
  type: TYPE_NORMAL
- en: FindAllMovies v1.0.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Invoke the `FindAllMovies` v1.0.0 version with its ID in the qualifier parameter
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`result.json` should have all the movies in the DynamoDB `movies` table, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba6b88b5-5a6e-4bf4-817d-69b80be8635c.png)'
  prefs: []
  type: TYPE_IMG
- en: The output showing all the movies in the DynamoDB movies table
  prefs: []
  type: TYPE_NORMAL
- en: FindAllMovies v1.1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `input.json`, and paste in the following content.
    This function''s version expects a Header parameter, called `Count`, with a number
    of movies to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the function, but this time, use the `--payload` parameter with the
    path location to the `input.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`result.json` should contain only four movies, as expected, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5be9c81-be0c-4c0e-9daf-3010a0d4959c.png)'
  prefs: []
  type: TYPE_IMG
- en: That's how to create multiple versions of your Lambda function. But, what are
    the best practices for Lambda function versioning?
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you publish a new version of your Lambda function, you should give it a
    significant and meaningful version name that allows you to track different changes
    made to your function through its development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: When you're building a public serverless API that will be used by millions of
    customers, the way you name your different API versions is critical as it allows
    your customers to know whether the new release introduces breaking changes. It
    also lets them choose the right time to upgrade to the newest version without
    taking much risk of breaking up their pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s where Semantic Versioning ([https://semver.org](https://semver.org))
    comes into play, it''s a version scheme that uses a sequence of three digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95b25d49-ebb1-489a-a43f-f77522dcd791.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each digit is incremented based on the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: Increment if the Lambda function is not backward-compatible with
    previous releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: Increment if the new functionality or features have been added to
    the function and it''s still backward-compatible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: Increment if bugs and issues have been fixed and the function is
    still backward-compatible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the `FindAllMovies` function's version `1.1.0` is the first major
    release, with one minor version bringing a new feature (Pagination system).
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The alias is a pointer to a specific version, it allows you to promote a function
    from one environment to another (such as staging to production). Aliases are mutable,
    unlike versions, which are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the concept of aliases, we will create two aliases, as illustrated
    in the following diagram: a `Production` alias pointing to `FindAllMovies` Lambda
    function `1.0.0` version, and a `Staging` alias that points to function `1.1.0` version.
    Then, we will configure API Gateway to use these aliases instead of the `$LATEST` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e87027dd-a651-498d-bbab-2684b4573f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Head back to the `FindAllMovies` configuration page. If you click on the **Qualifiers** drop-down
    list, you should see a default alias called `Unqualified` pointing to your `$LATEST`
    version, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/521e0803-990d-40aa-8c5c-c5ce67395608.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a new alias, click on Actions and then Create a new alias called
    `Staging`. Select the `5` version as the target, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b245509-65f5-45c0-b87d-a5d7ca17cc02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, the new version should be added to the list of Aliases, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39136427-32c5-4e9a-bfaa-322cb13c6827.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, create a new alias for the `Production` environment that points to version
    `1.0.0` using the AWS command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the new alias should be successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87f2947c-f8ef-4520-8c29-99e84af8ea17.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our aliases have been created, let's configure the API Gateway to use
    those aliases with **Stage variables**.
  prefs: []
  type: TYPE_NORMAL
- en: Stage variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stage variables are environment variables that can be used to change the behavior
    at runtime of the API Gateway methods for each deployment stage. The following
    section will illustrate how to use stage variables with API Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the API Gateway Console, navigate to the `Movies` API, click on the `GET`
    method, and update the target Lambda Function to use a stage variable instead
    of a hardcoded Lambda function name, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c74cdbfd-622f-4eb3-a166-55242aed9c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you save it, a new prompt will ask you to grant the permissions to API
    Gateway to call your Lambda function aliases, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9ea0a69-ead1-478f-a915-0ad36c30bf95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Execute the following commands to allow API Gateway to invoke the `Production`
    and `Staging` aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Production alias**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Staging alias:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new stage called `production`, as shown in next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/311b2b02-9a37-49a5-b79f-b0755d8ebc44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click on the **Stages Variables** tab, and create a new stage variable
    called `lambda` and set `FindAllMovies:Production` as a value, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/541715f5-692e-4694-8e41-ce523f6560ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Do the same for the `staging` environment with the `lambda` variable pointing
    to the Lambda function''s `Staging` alias, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d2cc7e7-8ecb-4879-96ab-9e3272681b45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To test the endpoint, use the `cURL` command or any REST client you''re familiar
    with. I opt for Postman. A `GET` method on the API Gateway''s `production` stage
    invoked URL should return all the movies in the database, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5b9c15a-4785-453d-89f1-ee518e30279b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Do the same for the staging environment, with a new `Header` key called `Count=4`;
    you should have only four movies items in return, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e739b39-c75a-4cd4-88c8-1b4abba35045.png)'
  prefs: []
  type: TYPE_IMG
- en: That's how you can maintain multiple environments of your Lambda functions.
    You can now easily promote the `1.1.0` version into production by changing the
    `Production` pointer to point to `1.1.0` instead of `1.0.0`, and roll back in
    case of failure to the previous working version without changing the API Gateway
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CLI can be very useful for creating automation scripts to manage AWS Lambda
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Versions are immutable and cannot be changed once they’re published. On the
    other hand, aliases are dynamic and their binding can be changed at any time to
    implement code-promotion or rollback. Adopting Semantic Versioning for the Lambda
    function’s versions can make tracking changes easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to set up a CI/CD pipeline from scratch
    to automate the process of deploying Lambda functions to production. We will also
    cover how aliases and versions can be used in the Continuous Integration workflow.
  prefs: []
  type: TYPE_NORMAL
