- en: Introduction to Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last three chapters, we learned about the linguistic features of modern
    C++: multithreading, lock-free programming models, and so on. The topics covered
    there can be considered as sort of prerequisites to start learning about the reactive
    programming model. The reactive programming model warrants skills in functional
    programming, concurrent programming, schedulers, object/functional programming,
    design patterns, and event Stream processing, to name a few. We have already covered
    or touched upon functional programming, object/functional programming, and some
    topics that are related to scheduling in the previous chapter. This time, we will
    cover the wonderful world of design patterns to appreciate the crux of reactive
    programming in general and Observables in particular. In the next chapter, we
    will deal with the topic of event Stream programming before we jump into the RxCpp
    library. The design pattern movement reached critical mass with the publication
    of a book titled *Design Patterns: Elements of Reusable Object Oriented Software*
    by the **Gang of Four** (**GoF**). who cataloged a set of 23 patterns grouped
    into creational, structural, and behavioral families. The GoF catalog defined
    the Observer pattern in the category of behavioral patterns. A key message we
    want to deliver here is that the reactive programming model can be understood
    through knowledge of the venerable GoF patterns. In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The GoF Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations of the GoF Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A holistic look at design patterns and Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling real-world hierarchies using composite design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral processing of composites using visitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening the composite and navigating through the Iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation from Iterator to Observable/Observer by reversing the gaze!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GoF Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GoF Observer pattern is also referred to as a *publish-subscribe pattern*
    in the GoF book. The idea is simple. `EventSource` (classes that emits events)
    will have a one-to-many relationship with event sinks (classes that listen to
    the event notification). Every `EventSource` will have a mechanism for the event
    sinks to subscribe to, in order to get different types of notification. A single
    `EventSource` might emit multiple events. An `EventSource` can send notifications
    to thousands of subscribers (event sinks or listeners) when there is a change
    in state or something significant happens in its realm. The `EventSource` will
    walk through the list of subscribers and notify them one by one. The GoF book
    was written at a time when the world was mostly doing sequential programming.
    Topics such as concurrency were mostly related to platform-specific libraries
    or the `POSIX` thread library. We will write a simple C++ program to demonstrate
    the whole idea of the Observer pattern. The purpose is to quickly understand the
    Observer pattern, and ideas such as robustness have been given secondary priority.
    The listing is self-contained and easily understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet implements a trivial `EventSource`, which can potentially
    store an integral value as the state. In modern C++, we can use type traits to
    detect whether the consumer has instantiated this class with an integral type.
    Since our focus is on elucidation, we have not added assertions pertaining to
    type constraints. In the next C++ standards, there is a notion called **concept**
    (known as Constraints in other languages) that will help in enforcing that directly
    (without type traits). In a real-life scenario, an `EventSource` might store lots
    of variables or Streams of values. Any changes in them will be broadcast to all
    subscribers. In the `SetState` method, when a consumer of the `EventSource` class
    (the event sink itself is the consumer in this class) mutates the state, the `NotifyAll()`
    method will get triggered. The `NotifyAll()` method works through the list of
    sinks and invokes the `Update()` method. Then, event sinks can do the tasks that
    are specific to their context. We have not implemented methods such as unsubscribe
    to focus on the core issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EventSourceValueObserver` class has implemented the `Update` method to
    do a task that is relevant for its context. Here, it just prints the values of
    the old state and current state onto the console. In real life, sinks might modify
    a UX element or relay the propagation of state to other objects through notifications.
    Let''s also write another event sink, which will inherit from `EventSourceValueObserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented a specialized version of the Observer for demonstration
    purposes. This has been done to show that we can have subscribers that are instances
    of two classes (which can be inherited from `EventSourceObserver<T>`). Here also,
    we do not do much when we get a notification from the `EventSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet instantiates an `EventSource` object and adds two
    subscribers. When we change the state of the `EventSource`, the notification will
    be received by the subscribers. This is the crux of the Observer pattern. In a
    normal OOP program, the consumption of objects is done in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call a method to compute some value or change state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do something useful based on the return value or a change in the state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, in the case of the Observer, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the object (`EventSource`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribe for the notification by implementing Observers (for event listening)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When something changes at the `EventSource`, you will be notified
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do something with the value received through the notification
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Method` function outlined here helps in the separation of concerns, and
    modularity has been achieved. This is a good mechanism to implement event-driven
    code. Rather than polling for events, you are asking to be notified. Most GUI
    toolkits today use similar paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The limitations of the GoF Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GoF pattern book was written at a time when the world was really doing
    sequential programming. The architecture of Observer pattern implementation had
    lot of anomalies, judging from the current programming model world view. Here
    are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The close coupling between Subjects and Observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lifetime of the `EventSource` is controlled by the Observers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observers (sinks) can block the `EventSource`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation is not thread-safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event filtering is done at the sink level. Ideally speaking, the data should
    be filtered at the place where the data is (at the subject level, before notification).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, Observers do not do much and the CPU cycles will be wasted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EventSource` should ideally publish the value to the environment. The environment
    should notify all the subscribers. This level of indirection can facilitate techniques
    such as event aggregation, event transformation, event filtering, and canonicalizing
    the event data to name a few.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the advent of functional programming techniques such as immutable variables,
    functional composition, functional style transformation, lock-free concurrent
    programming, and so on, we can circumvent the limits of the classic Observer pattern.
    The solution outlined by the industry is the notion of Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the classic Observer pattern, a diligent reader might have seen the potential for
    the asynchronous programming model to be incorporated. The `EventSource` can make
    asynchronous calls to the Subscribers method, rather than looping the subscribers
    sequentially. By using a fire and forget mechanism, we can decouple the `EventSource`
    from its sinks. The invocation can be done from a background thread, async task,
    or packaged task, or a suitable mechanism for the context. The asynchronous invocation
    of notification methods has the added advantage that if any of the  client blocks
    (by getting into an infinite loop or a crash), others can still get the notification.
    The asynchronous method works on the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: Define methods for handling data, exceptions, and the end of the data (on the
    event sink side)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An Observer (event Sink) interface should have `OnData`, `OnError`, and `OnCompleted`
    methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every event sink should implement the Observer interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every `EventSource` (Observable) should have subscribe and unsubscribe methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The event sink should subscribe to an instance of Observable through Subscribe
    methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an event happens, the Observer will be notified by the Observable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of these things were already mentioned in [Chapter 1](0352eeb5-f1d9-42d2-b657-92ff3ed53abd.xhtml),
    *Reactive Programming Model – Overview and History*. We did not cover the asynchronous
    part then. In this chapter, we will revisit those ideas. Based on the experience
    which authors had based on the technical presentations and interaction with developers,
    jumping right into the Observable/Observer model of programming does not help
    in comprehension. Most developers are confused regarding Observable/Observer because
    of the fact that they do not know what particular problem this pattern solves.
    The classic GoF Observer implementation given here is to set the context for discussions
    on Observable Streams.
  prefs: []
  type: TYPE_NORMAL
- en: A holistic look at GoF patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design pattern movement started at a time when the World was struggling
    to come to terms with complexities of object-oriented software design methods.
    The GoF book and the associated pattern catalog gave developers a set of techniques
    for designing large-scale systems. Topics such as concurrency and parallelism
    were not in the minds of the people who designed the catalog. (At least, their
    work did not reflect this!)
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that event handling through the classic Observer pattern has some
    limitations, which might be a problem in some cases. What is the way out? We need
    to take a fresh look at the problem of event handling by taking a step back. We
    will digress into the subject of philosophy a bit to have a different outlook
    on the problem that the reactive programming model (programming with Observable
    Streams!) is trying to solve. Our Journey  will help us to transition nicely from
    GOF patterns to the world of Reactive programming using functional programming
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: The following content in this section is bit abstract and has been given here
    to provide a conceptual background from which authors  of this book have approached
    the subject covered in this chapter. Our approach to explaining Observables starts
    from the GoF Composite/Visitor pattern and iteratively reaches the topic of Observables. 
    The idea of this approach came from a book on Advaita Vedanta, a mystical philosophical
    tradition that originated in India.  The topic has been explained in Western Philosophical
    terms. If a matter seems bit abstract, feel free to gloss over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nataraja Guru (1895-1973) was an Indian philosopher who was a proponent of
    the Advaita Vedanta Philosophy, an Indian philosophical school based on the non-dualism
    of a supreme force that governs all of us. According to this philosophical school,
    whatever we see around , be it humans, animals, or plants, are manifestations
    of the Absolute (called Brahman in Sanskrit) and its only positive affirmation
    is SAT-CHIT-ANAND (Vedanta philosophy uses negation and proof by contradiction
    to depict Brahman). This can be translated into the English language as existence,
    essence, and bliss (the implied meaning of bliss is "good" here). In a book titled
    *The Unitive Philosophy* published by DK Print World, New Delhi, he gives a mapping
    of SAT-CHIT-ANAND to Ontology, Epistemology, and Axiology (the three primary branches
    of philosophy). The Ontology, Epistemology, and Axiology are the theories of existence,
    knowledge, and values respectively. The following table gives possible mappings
    of SAT-CHIT-ANAND to other entities that mean more or less the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SAT** | **CHIT** | **ANAND** |'
  prefs: []
  type: TYPE_TB
- en: '| Existence | Essence | Bliss |'
  prefs: []
  type: TYPE_TB
- en: '| Ontology | Epistemology | Axiology |'
  prefs: []
  type: TYPE_TB
- en: '| Who am I? | What can I know? | What should I do? |'
  prefs: []
  type: TYPE_TB
- en: '| Structure | Behavior | Function |'
  prefs: []
  type: TYPE_TB
- en: In Vedanta (the Advaita school) philosophy, the whole World is viewed as existence,
    essence, and bliss. From the table, we will map the problems in the software design
    world into the problem of structure, behavior, and function. Every system in the
    world can be viewed from the structural, behavioral, and functional perspectives.
    The canonical structure for a OOP programs is hierarchies. We will model the world
    we are interested in as hierarchies and process them in a canonical manner. The
    GOF pattern catalog has got Composite pattern (structural)  for modelling hierarchies
    and Visitor pattern (behavioral)  to process them.
  prefs: []
  type: TYPE_NORMAL
- en: The OOP programming model and hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is bit conceptual in nature and those of you who have not dabbled
    with GoF design patterns will find it a bit difficult. The best strategy could
    be to skip this section and focus on the running example. Once you have understood
    the running example, this particular section can be revisited.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming is very good at modeling hierarchies. In fact, the
    hierarchy can be considered the canonical data model for the object-oriented processing
    of data. In the GoF pattern world, we model hierarchies using the Composite pattern.
    The Composite pattern is categorized as a structural pattern. Whenever there is
    a Composite pattern used, the Visitor pattern will also be part of the system.
    The Visitor pattern is good for processing composites to add behavior to the structure.
    The Visitor/Composite patterns come as a pair in real-life contexts. Of course,
    one instance of the Composite can be processed by different visitors. In a Compiler
    project, the **Abstract Syntax Tree** (**AST**) will be modeled as a composite
    and there will be Visitor implementations for type checking, code optimization,
    code generation, and static analysis to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the problems with the Visitor pattern is the fact that it has to have
    some notion of the structure of the Composite to do the processing.  Moreover,
    it  will result in code bloat in the context where it needs to process a filtered
    subset of the available data in the Composite hierarchy. We might require different
    visitors for each filter criterion. The GoF pattern catalog has another pattern
    that falls into the behavioral category, called Iterator, something that every
    C++ programmer is familiar with. The Iterator pattern is good at processing data
    in a structure-agnostic manner. Any kind of hierarchical structure has to be linearized
    or flattened to be in a shape amenable to be processed by an Iterator. An example
    could be a tree, which can be processed using a BFS Iterator or a DFS Iterator.
    For the application programmer, all of a sudden the tree appears as a linear structure.
    We need to flatten the hierarchies to be in a state where the structure is amenable
    to Iterators. The process will be implemented by the person who has implemented
    the API. There are some limitations to the Iterator pattern (which is pull-based)
    and we will reverse the gaze and make the system push-based using a pattern called
    Observerable/Observer, an enhanced version of the Observer pattern. This section
    is a bit abstract, but after going through the entire chapter, you can come back
    and make sense of what is happening. In a nutshell, we can sum up the whole thing
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can model hierarchical structures using the Composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can process the Composite using the Visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can flatten or linearize the Composite to navigate it through Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators follow a pull method and we need to reverse the gaze for a push-based
    scheme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have managed to reach the Observable/Observer way of implementing things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables and Iterators are binary opposites (one man's push is another man's
    pull!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement all of the preceding points to have a firm grounding on Observables.
  prefs: []
  type: TYPE_NORMAL
- en: A Composite/Visitor pattern for expression processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate the journey from the GoF pattern catalog to Observables, we
    will model a four-function calculator as a running example. Since expression trees
    or AST are hierarchical in nature, they will be a good example to model as a Composite
    pattern. We have purposefully omitted writing a parser to keep the code listing
    small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined an enum type to represent the four binary operators (`+` ,
    `-` , `*` , `/`) and two unary operators (`+` , `-`). Other than the standard
    C++ headers, we have included a custom header (`FuncCompose.h`), which is available
    at the GitHub repo associated with this book. It contains code for the Compose
    function and pipe operator (`|`) for functional composition. We can use Unix pipeline
    style composition to tie together a collection of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Expr class will act as the base class for all the nodes that are part of
    the Expression Tree. Since our purpose is to demonstrate the Composite/Visitor
    GoF pattern, we support only constants, binary expressions, and unary expressions.
    The accept method in the Expr class accepts a Visitor reference as a parameter
    and the body of the method will be the same for all the nodes. The method will
    redirect the call to the appropriate handler on the Visitor implementation.  To
    gain more insight into the whole subject covered in this section, read about *double
    dispatch* and *Visitor pattern*  by searching the web using your favorite search
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visitor interface (`IExprVisitor`) contains methods to process all the
    node types supported by the hierarchy. In our case, there are methods for processing
    constant numbers, binary operators, and unary operators. Let''s see the code for
    the Node types. We start with the Number class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Number class wraps an IEEE double precision floating point number. The
    code is obvious and all we need to bother about is the content of the `accept`
    method. The method receives a parameter of type visitor (`IExprVisitor&`). The
    routine just reflects the call back to the appropriate node on the Visitor implementation.
    In this case, it will call `Visit(Number&)` on `IExpressionVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinaryExpr` class models a binary operation with left and right operands.
    The operands can be any of the classes in the hierarchy. The candidate classes
    are `Number`, `BinaryExpr`, and `UnaryExpr`. This can go to an arbitrary depth.
    The terminal node is Number in our case. The previous code has support for four
    binary operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UnaryExpr` method models a unary expression with an operator and a right
    side expression. We support unary plus and unary minus for this implementation.
    The right side expression can in turn be a `UnaryExpr`, `BinaryExpr`, or `Number`.
    Now that we have implementations for all the node types supported, let''s focus
    on the implementation of the Visitor Interface. We will write a Tree Walker and
    Evaluator to compute the value of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This does a depth-first walk of the AST and recursively evaluates the node.
    Let''s write an expression processor (an implementation of `IExprVisitor`) that
    will print the expression tree to the console in **Reverse Polish Notation** (**RPN**) form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The RPN notation is also called the postfix notion, where the operator comes
    after the operands. They are suitable for processing using an evaluation stack.
    They form the basis of the stack-based virtual machine architecture leveraged
    by the Java Virtual Machine and the .NET CLR. Now, let''s write a main function
    to put everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet creates an instance of a composite (an instance of `BinaryExpr`)
    and also instantiates an instances of `TreeEvaluatorVisitor` and `ReversePolshEvaluator`.
    Then, the `accept` method of Expr is called to start processing. We will see the
    value of the expression and an RPN equivalent of the expression on the console.
    In this section, we learned how to create a Composite and process the Composite
    using a Visitor interface. Other potential examples for Composites/Visitors are
    storing directory contents and their traversal, XML processing, document processing,
    and so on. Popular opinion says that, if you know the Composite/Visitor duo, you
    have understood the GoF pattern catalog well.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that the Composite pattern and Visitor pattern act as a pair to
    take care of the structural and behavioral aspects of a system and provide some
    functionality. The Visitor has to be written in a manner that presupposes the
    cognizance of the structure of the Composite. This can be a potential problem
    from an abstraction perspective. An implementer of a hierarchy can provide a mechanism
    to flatten the hierarchy into a list (which is possible in most cases). This will
    enable the API implementer to provide an Iterator-based API. The Iterator-based
    API is good for functional-style processing as well. Let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Flattening the composite for iterative processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already learned that the Visitor pattern has to know the structure
    of the composite for someone to write an instance of the Visitor interface. This
    can create an anomaly called *abstraction leak*. The GoF pattern catalog has a
    pattern that will help us to navigate the contents of a tree in a structure-agnostic
    manner. Yes, you might have guessed it correctly: the Iterator pattern is the
    candidate! For the Iterator to do its job, the composite has to be flattened into
    a list sequence or Stream. Let''s write some code to flatten the expression tree
    that we modeled in the previous section. Before we write the logic to flatten
    a Composite, let''s create a data structure to store the contents of an AST as
    a list. Every node in the list has to store either an operator or value, depending
    upon whether we need to store operators or operands. We describe a data structure
    called `EXPR_ITEM` for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `list<EXPR_ITEM>` data structure will store the contents of the composite
    as a linear structure. Let''s write a class that will flatten the composite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FlattenerVistor` class will flatten the composite `Expr` node to a list
    of `EXPR_ITEM`. Once the composite has been linearized, it is possible to process
    items using the Iterator pattern. Let''s write a small global function to convert
    an `Expr` tree to `list<EXPR_ITEM>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The global subroutine `ExprList` will flatten an arbitrary expression tree
    of a list of `EXPR_ITEM`. Once we have flattened the composite, we can use an
    iterator to process the content. After linearizing the structure as a list, we
    can use a stack data structure to evaluate the expression data to produce the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`DoubleStack` is a wrapper around the STL stack container. This can be considered
    as some kind of helper routine to keep the listing terse. Let''s write an evaluator
    for the flattened expression. We will iterate through list`<EXPR_ITEM>` and push
    the value to the stack, if a value is encountered. If an operator is encountered,
    we will pop the values from the stack and apply the operation. The result is pushed
    into the stack once again. At the end of the iteration, the existing element in
    the stack will be the value associated with the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a main program that will call this function to evaluate the expression.
    The code listing in the evaluator is easy to understand because we are reducing
    a list. In the tree-based interpreter, things were not obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Map and filter operations on the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Map is a functional operator where a function will be applied to a list. Filter
    will apply a predicate to a list and return another list. They are the cornerstone
    of any functional processing pipeline. They are also called higher-order functions.
    We can write a generic Map function, using `std::transform` for `std::list` and
    the `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also write a function to filter a `std::list` (we assume only a list
    will be passed). The same can work on `std::vector`. We can compose a higher-order
    function using the pipe operator. The composite function can also be passed as
    a predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this implementation of Filter, due to limitations in `std::copy_if`, we
    were forced to roll our own iteration logic. It is generally advised to use the
    STL implementation of functions to write wrappers. For this particular scenario,
    we need to detect whether a list is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a main function to put everything together. The code will demonstrate
    how to use `Map` and `Filter` in the application code. The logic for functional
    composition and the pipe operator are available in the `FuncCompose.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Filter` routine creates a new `list<Expr>`, which contains only the values
    or operands used in the expression. The `Map` routine applies a composite function
    on the list of values to return a new list.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing the gaze for Observables!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned that we can transform a composite to a list and traverse
    them through an Iterator. The Iterator pattern pulls data from the data source
    and manipulates the result at the consumer level. The most important problem we
    face is that we are coupling our `EventSource` and event sink. The GoF Observer
    pattern also does not help here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a class that can act as an event hub, which the sinks will subscribe
    to. By having an event hub, we will now have an object that will act as an intermediary
    between the `EventSource` and event sink. One advantage of this indirection is
    readily obvious from the fact that our class can aggregate, transform, and filter
    out events before they reach the consumer. The consumer can even set transformation
    and filtering criteria at the event hub level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already covered the `OBSERVABLE` and `OBSERVER` in [Chapter 1](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=53&action=edit#post_26), *Reactive
    Programming Model – Overview and History* and [Chapter 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml),
    *A Tour of Modern C++ and its Key Idioms*. The `EventSource` implements `OBSERVABLE`
    and the event sinks implement the `OBSERVER` interface. A class derived from `OBSERVER`
    will implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ondata` (for receiving data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onexception` (exception processing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oncompleted` (end of the data)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `EventSource` class will be derived from `OBSERVABLE` and has to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe (subscribe to notification)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribe (not implemented in our case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`map_func` and `filter_func` are functions that can help us to transform and
    filter the values before they are dispatched to the subscribers in an asynchronous
    manner. We give these values as parameters when we instantiate the `EventSource`
    class. Currently, we have written the code under the assumption that only the
    `Expr` object will be stored in the `EventSource`. We can have a list or vector
    of expressions and Stream the value to the subscribers. For this, implementation
    a scalar value can be pushed to the listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have made some assumptions that the `Expr` objects will be owned by the
    caller. We have also omitted the implementation of the unsubscribe method. The
    constructor takes an `Expr` object, a `Filter` predicate (it can be a composite
    function using the | operator), and a `Mapping` function (it can be a composite
    function using the `|` operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After evaluating the expression, the scalar value will be put into an STL list.
    Then, the Map function will be applied on the list to transform the value. In
    future, we will handle a list of values. Once we have mapped or transformed the
    values, we will apply a filter to the list. If there is no value in the list,
    the method returns without notifying the subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we will call `packaged_task` to dispatch the data to the event
    sinks. Industrial-strength libraries use a piece of code called Scheduler to do
    this part of the task. Since we are using fire and forget, the sinks will not
    be able to block the `EventSource`. This is one of the most important use cases
    of Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a method to emit random expressions based on the modern C++
    random number generator with a uniform probability distribution. The choice of
    this distribution is rather arbitrary. We can try other distributions as well
    to see different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a main function to put everything together. We will instantiate
    the `EventSourceValueSubject` class with an `Expr`, a `Filter`, and a `Mapper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'While instantiating the object, we have used the pipe operator to compose two
    Lambdas. This is to demonstrate that we can compose an arbitrary list of functions
    to form a composite function. When we write RxCpp programs, we will exploit this
    technique a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have instantiated two `OBSERVER` objects and assigned them
    to the ondata member using Lambda functions . We have not implemented other methods.
    This is for demonstration purposes only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We subscribed to event notification using the `OBSERVER` instances. We have
    only implemented the ondata method. Implementing `onexception` and `oncompleted`
    are trivial tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We evaluated a series of random expressions by setting the expression to the
    `EventSource` object. After transformation and filtering, if there is a value
    left, the value will be notified to the `OBSERVER` and it will printed to the
    console. With this, we have managed to write a non-blocking `EventSource` using
    `packaged_taks`. We have demonstrated the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling an expression tree using a Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing a Composite through the Visitor interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening the expression tree into a list and processing it through Iterators
    (pull)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing the gaze from `EventSource` to the event sink (push)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot of ground in this chapter, inching towards the reactive
    programming model. We learned about the GoF Observer pattern and understood its
    shortcomings. Then, we digressed into philosophy to understand the method of looking
    at the world from a structural, behavioral, and functional perspective. We learned
    about the GoF Composite/Visitor pattern in the context of modeling an expression
    tree. We learned how to flatten the hierarchy into a list and navigate them through
    the Iterator. Finally, we transformed the scheme of things a bit to reach Observables.
    Normally, Observables work with Streams, but in our case it was a scalar value.
    In the next chapter, we will learn about event Stream processing to complete our
    prerequisites for learning reactive programming.
  prefs: []
  type: TYPE_NORMAL
