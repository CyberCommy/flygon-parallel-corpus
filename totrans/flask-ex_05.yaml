- en: Chapter 5. Improving the User Experience of Our Headlines Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wealthy business people who have to constantly make a good impression to keep
    up profitable relations sometimes employ personal assistants to study their acquaintances.
    The PA then stands behind the wealthy person at social events and whispers a few
    choice words to him or her about someone who is approaching to converse. The words
    have to be succinct but informative, such as "Paul Smith. One child, Jill. Recently
    travelled, Mauritius". Now, our business person can pretend that whoever has approached
    is a dear friend and talk all about his children and travels at some length without
    having the faintest clue of who the person actually is. This makes other people
    feel important and liked, and this can help our hypothetical millionaire become
    even richer.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this relevant to web applications? Well, we want to do exactly the same
    thing. Users of our site who feel important and remembered are more likely to
    come back, so we need a digital PA to make the user feel as though we've taken
    the time and effort to remember who they are and what they like. We could build
    a database of our users to store what currency conversions they usually calculate
    and which cities' weather they are interested in and then display these to them
    by default. The issue with this strategy is that we'd need them to identify themselves
    with every visit, and most users would find the extra step of entering a username,
    and possibly a password, tedious and off-putting.
  prefs: []
  type: TYPE_NORMAL
- en: Enter HTTP cookies. These sly little things will lurk on our users' computers
    and act as digital PAs for us when our users make a second visit to our site,
    giving us information that we've acquired before but haven't bothered to remember.
    This sounds pretty underhand. At one point, the European Union thought this way
    and attempted to regulate the use of cookies, but they are everywhere and are
    simple and useful, and the regulation attempts were a bit underwhelming (take
    a look at [http://silktide.com/the-stupid-cookie-law-is-dead-at-last/](http://silktide.com/the-stupid-cookie-law-is-dead-at-last/)).
  prefs: []
  type: TYPE_NORMAL
- en: In their simplest form, cookies are simply key-value pairs that we store on
    our users' machines and ask their browser to automatically send back to us whenever
    they visit our site. The pros of this are that we don't have to keep and maintain
    a database and we don't have to explicitly ask users to tell us who they are.
    However, the cons are that we don't have control of the information and if a user
    changes computers, web browsers, or even just deletes our cookies, we'll no longer
    be able to identify him or her. Cookies are, therefore, perfect for an application
    such as the one we've built; it's not the end of the world if a user has to click
    a few times to get back to the media, currency, and weather information he or
    she searched for the last time, but it's nice if we can remember previous choices
    and display these automatically.
  prefs: []
  type: TYPE_NORMAL
- en: While we're on the topic of user experience (or UX as it's often referred to),
    our site looks as though it was made in the 1980s. We'll have a stronger focus
    on aesthetics in later chapters, but for now we'll also take a look at how to
    add some basic layout and colors to our site. As we're focusing on functionality
    and simplicity, it'll still be far from "modern-looking", but we'll add some building
    blocks to our toolkit that we'll use more carefully later on. We'll use **Cascading
    Style Sheets** (normally just called **CSS**) to achieve this. CSS is a great
    tool to enable a further separation of concerns; we have already mainly separated
    our logic (that is, our Python script) from our content (that is, our HTML templates).
    Now, we'll take a look at how CSS can help us separate our formatting (that is,
    the color, font, layout, and so on) from the rest of our content, such as the
    static text in our template files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've had an overview of cookies and CSS, we'll get to looking at implementing
    them in Flask. This is the final chapter of our first project, and by the end
    of it, we'll have a Headlines application that includes cookies and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding cookies to our Headlines application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding CSS to our Headlines application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding cookies to our Headlines application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application, at this point, has a couple of issues. Let's imagine a user,
    Bob, who lives in Seattle. Bob visits our site and sees the defaults for BBC,
    London, and conversion of GBP to USD. Bob wants to see the weather for Seattle,
    so he types `Seattle` into the **Weather search** bar and hits Enter. He glances
    at the returned weather and feels pretty depressed that it's cold and raining
    as usual, so he looks away from the weather further down the page and sees the
    BBC headlines. He would prefer CNN headlines, so he selects this publication from
    the drop-down menu and hits **Submit**. He reads through a couple of headlines
    before realizing that current affairs are even duller and more depressing than
    the weather. So, his eyes move back to the top of the page again to cheer himself
    up. He's confused; since changing his publication preference, the weather has
    defaulted back to London, where the weather is even worse! He closes our application
    and doesn't come back. If he were to come back, everything would display the defaults
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two immediate problems are:'
  prefs: []
  type: TYPE_NORMAL
- en: Not remembering our users' choices even while they stay on our site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not remembering our users' choices after they close our site and revisit at
    a later stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's fix both of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using cookies with Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies, as introduced earlier, can be thought of as key-value pairs that we
    may or may not receive by default from return visitors. We need to change our
    app so that when a user makes choices, we create or update their cookie to reflect
    these changes, and when a user requests our site, we check to see whether a cookie
    exists and read as much of the unspecified information from this as possible.
    First, we'll look at how to set cookies and have our user's browser automatically
    remember information, and then we'll look at retrieving the information that we
    previously used cookies to store.
  prefs: []
  type: TYPE_NORMAL
- en: Setting cookies in Flask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Flask makes dealing with cookies as easy as ever. First, we need a couple more
    imports; we''ll use the `datetime` library from Python to set the lifespan of
    our soon-to-exist cookies, and we''ll use Flask''s `make_response()` function
    to create a response object that we can set cookies on. Add the following two
    lines to your imports section in the `headlines.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, we were simply rendering our template with the custom arguments and
    then returning it to our users' web browsers. In order to set cookies, we need
    an extra step. First, we'll create a response object with our new `make_response()`
    function and then set our cookie using this object. Finally, we'll return the
    entire response, which includes the rendered template and the cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitute the last line of our `home()` function in `headlines.py` with the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a big change from the simple return statement we had, so let's
    break it down a bit. First, we will wrap a `make_response()` call around our `render_template()`
    call instead of returning the rendered template directly. This means that our
    Jinja templates will be rendered, and all the placeholders will be replaced with
    the correct values, but instead of returning this response directly to our users,
    we will load it into a variable so that we can make some more additions to it.
    Once we have this response object, we will create a `datetime` object with a value
    of 365 days from today's date. Then, we will do a series of `set_cookie()` calls
    on our `response` object, saving all the user's selections (or refreshing the
    previous defaults) and setting the expiry time to a year from the time the cookie
    was set using our `datetime` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will return our `response` object, which contains the HTML for the
    rendered template, and our four cookie values. On loading the page, our user's
    browser will save the four cookies, and we'll be able to retrieve the values if
    the same user visits our application again.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving cookies in Flask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remembering the information is not much good if we don''t do anything with
    it. We now set cookies as the final step before we send a response to our users.
    However, we need to check for the saved cookies when a user sends us a request.
    If you remember how we got named arguments from Flask''s request object, you could
    probably guess how to get saved cookies. The following line will get the cookie
    named `publication` if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is simple, right? The only tricky part is getting our fallback logic correct.
    We still want explicit requests to take the highest priority; that is, if a user
    enters text or selects a value from a drop-down menu, this will be what he or
    she wants irrespective of what we expect from previous visits. If there is no
    explicit request, we will look in the cookies to check whether we can grab a default
    from there. Finally, if we still have nothing, we will use our hardcoded defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the fallback logic to check for cookies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s just implement this logic for `publication` first. Add a new `if` block
    to our publication logic in the `home()` function of `headlines.py` to make it
    match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will look in the GET arguments, fall back if necessary on the saved
    cookies, and finally fall back on our default value. Let's take a look at this
    working. Open your web browser and navigate to `localhost:5000`. Search for `Fox`
    in the **Publication** search bar and wait for the page to reload with Fox News
    headlines. Now, close your browser, reopen it, and load `localhost:5000` again.
    This time, you should see the Fox headlines without having to search for them,
    as in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no `publication` argument in the URL, and yet the headlines
    themselves are now from Fox News.
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the fallback logic to check for cookies](img/B04312_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving the cookies for other data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have basic cookies working for our publication, but we still want to read
    the cookies we potentially saved for weather and currency options. We could simply
    add the same if statement to each section of our code, substituting `city`, `currency_from`,
    and `currency_to` for `publication` as relevant, but making the same changes in
    many parts of our code is a strong sign that we need to do some refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `get_value_with_fallback()` function instead that implements
    our fallback logic on a more abstract level. Add the new function to the `headlines.py`
    file and call it from the `home()` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should be able to submit the forms in any order and have all our options
    remembered as we would expect. Also, whenever we visit our site, it will automatically
    be configured with our most recently used options. Give it a go! You should be
    able to search for currency, weather, and headlines; then, close your browser;
    and revisit the site. The inputs you used most recently should appear by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, we can see that no arguments are passed in the
    URL, and yet we are displaying weather data for Port Elizabeth in South Africa;
    currency data from the **Chinese Yuan** (**CNY**) to **Saint Helena Pound** (**SHP**);
    and headlines from Fox News.
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the cookies for other data](img/B04312_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding CSS to our Headlines application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our site remains pretty bare. There's a lot of white and some black. Most users
    prefer color, animations, borders, margins, and so on. As mentioned before, we're
    not really going to focus on aesthetics now, but we'll add some basic colors and
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: External, internal, and inline CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways that CSS can be added to a web page. The best way is to
    keep it completely separate from the HTML and save it in an external file, which
    is included in the HTML in a `<link>` element. This is sometimes referred to as
    the *external CSS*. The worst way is called *inline CSS*. Using the inline method,
    CSS is defined on a per element basis; this is considered bad practice as any
    changes to style require trawling through HTML to find the relevant sections.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, many elements on a page often have the same or at least related
    styles to maintain color schemes and styles throughout the site. Using inline
    styles, therefore, often leads to a lot of code repetition, which we know to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we'll take a middle ground. We'll keep our CSS defined in
    our `.html` template files, but we'll define it all in a single place. This is
    because we haven't yet looked at how Flask handles files by convention, so keeping
    all our code in one place is simpler for now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our first CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS is quite straightforward; we will describe elements of our page by type,
    ID, class, and so on and define a number of properties for these, such as color,
    layout, padding, fonts, and so on. CSS is designed to *cascade*, that is, if we
    don't specify for a more specific element, it'll automatically inherit properties
    defined for a more general element. We'll go through the CSS itself fairly quickly,
    so if you've never heard of it before and would like to know more about it, now
    is the opportune moment to take a break and go through some CSS-specific resources.
    There are a lot of them online that a quick search will reveal; if you enjoyed
    the W3Schools HTML tutorial we mentioned earlier, you can find a similar CSS one
    here at [http://www.w3schools.com/css/](http://www.w3schools.com/css/). Alternatively,
    dive in the deep end with the examples and brief explanations that follow!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a better header to our site. We''ll add a tagline beneath
    our top level heading, and surround it with a new `<div>` tag so that we can modify
    the entire header in the upcoming CSS. Modify the start of the `home.html` template
    to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `<div>` tag doesn't do anything by itself, and you can think of it as a
    container. We can use it to group logically related elements into the same element,
    which is very useful for CSS as we can then style all of the elements in a `<div>`
    tag at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS should be added into the `<head>` section of our template inside a `<style>`
    tag. Underneath the `<title>` tag in our `home.html` template, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined the styles explicitly for three elements: the outer `<html>` element,
    the `<body>` element, and any element with an `id="header"` attribute. As all
    of our elements are within our `<html>` element, the font cascades automatically
    down everywhere (although it could still be overwritten explicitly by subelements).
    We set everything in our body element (which contains all the visible items of
    the page) to have a maximum width of 900 pixels. The `margin: 0 auto;` line means
    that there will be no margin at the top and bottom of the body, and an automatic
    margin on the left- and right-hand sides. This has the effect of centering everything
    on the page. The `background: white;` and `background: lightgrey;` lines mean
    that we''ll have a centered main element with a light grey background inside the
    larger window, which is white. Finally, our defined header `div` will have a lightsteelblue
    background. Save the page with the added styles and refresh to see the effect.
    It should look similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding our first CSS](img/B04312_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at how we can improve the aesthetics in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Browsers and caching**'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Browsers often cache content that doesn't change often locally in order to display
    pages more quickly the next time you visit them. This is not ideal for development
    as you want to see the changes as you make them. If your styles don't seem to
    be doing what you'd expect, clear your browser's cache and try again. This can
    be done on most browsers by pressing *Ctrl* + *Shift* + *ESC* and selecting the
    relevant options from the menu that pops up.
  prefs: []
  type: TYPE_NORMAL
- en: Adding padding to our CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is slightly more interesting than black on white, but it's still pretty
    ugly. One problem is that the text is right up against the margin of the color
    without any breathing room. We can fix this using *CSS padding*, which moves everything
    over from the top, right, bottom, left, or any combination by specified amounts.
  prefs: []
  type: TYPE_NORMAL
- en: We could add padding directly to our `<body>` tag as we want a nice left-hand
    side buffer for all the text. If you try this, you'll see the immediate issue;
    the padding will affect everything, including our `<div>` header and the `<hr>`
    tag that separates it from the rest of our content, which means that there will
    be a weird stripe of grey that isn't what we want. We'll fix the issue in a way
    that you'll soon use for nearly everything CSS-related—just add more divs! We
    need a *main* `<div>` header around all our subheadings and an inner header div
    so that we can pad the text in our header without padding the background color
    or the separator.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more styles to our CSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following sections to your CSS to define left-hand side padding for
    our main and inner header divs and update the `#header` section to include some
    top padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding the div tags to the template file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s add the divs themselves; the template code in `home.html` should
    be updated to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Styling our inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This makes the layout a bit more pleasant to look at because the text doesn''t
    look like it''s trying to sneak off the edge. The next major pain point is our
    input elements, which are very boring. Let''s add some style to them as well.
    At the bottom of the CSS we have so far, add the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first section styles our text input and select (that is, drop-down) elements.
    The text color is grey, it has a border that is of the same color as our heading,
    and we will make them a little bit bigger than the default ones we had before
    using height and line height. We also need to adjust the margins to make the text
    fit in the new size more naturally (if you''re curious, leave out the margin line
    at the bottom of the first section and look at the result.) The second and third
    sections are to style our **Submit** buttons; one to define how they usually look
    and the other to define how they look when the mouse moves over them. Again, save
    these changes and refresh the page to see how they look. You should see something
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling our inputs](img/B04312_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final result will still not win any design awards, but at least you've learned
    the basics of CSS. One of the most frustrating parts of designing web pages is
    that each browser interprets CSS slightly differently (or in some cases, very
    differently). Cross-browser testing and validation is every web developer's arch
    nemesis, and in later chapters, we'll look at some tools and frameworks that can
    be used to mitigate the issues that arise from this potential lack of consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've made our site a bit more user-friendly in this chapter, both in terms
    of functionality (by remembering our users' choices through cookies) and aesthetics
    (using CSS). We'll come back to both of these topics in later projects, in which
    we'll use cookies to allow users to log in and some more advanced CSS. This is
    the end of our Headlines project; we have a functioning Headlines application
    that displays news, weather, and currency information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll start building a new project: an interactive crime
    map.'
  prefs: []
  type: TYPE_NORMAL
