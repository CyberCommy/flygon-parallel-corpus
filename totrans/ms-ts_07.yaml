- en: Chapter 7. Modularization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modularization is a popular technique used in modern programming languages that
    allows programs to be built from a series of smaller programs, or modules. Writing
    programs that use modules encourages programmers to write code that conforms to
    the design principle called "Separation of Concerns". In other words, each module
    focuses on doing one thing, and has a clearly defined interface. If we then consume
    this module by focusing on the interface, we can easily replace this interface
    with something else, without breaking our code. We will focus more on "Separation
    of Concerns" and other object-oriented design patterns in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript, in itself, does not have a concept of modules, but it is proposed
    for the upcoming ECMAScript 6 standard. Popular frameworks and libraries such
    as Node and Require have built module-loading capabilities into their frameworks.
    These frameworks, however, use slightly different syntax. Node uses the CommonJS
    syntax for module loading, whereas Require uses the **Asynchronous Module Loading**
    (**AMD**) syntax. The TypeScript compiler has an option to turn on module compilation,
    and then switch between these two syntax styles.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the syntax of both module styles, and how the
    TypeScript compiler implements them. We will take a look at how to use modules
    when writing code for both Node and Require. We will also have a cursory look
    at Backbone, and how to write an application using a Model, View and Controller.
    Each of these Backbone components will be built as loadable modules.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most prevalent usage of the CommonJs syntax for writing modules is when
    writing server-side code. It has been argued that browser-based CommonJs syntax
    simply cannot be done without a lot of overhead, but there are some libraries
    out there such as Curl ([https://github.com/cujojs/curl](https://github.com/cujojs/curl))
    that allow this syntax. In this section, we will, however, focus on Node application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Node in Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Node within Visual Studio has been made a breeze by the Node tools for
    Visual Studio plugin ([https://nodejstools.codeplex.com](https://nodejstools.codeplex.com)).
    This toolset has also been updated to use TypeScript as a default editor, bringing
    the full TypeScript development experience to Node. Once the extension has been
    installed, we can create a new blank Node application, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Node in Visual Studio](img/image_9665OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a blank Node application with the Node toolset
  prefs: []
  type: TYPE_NORMAL
- en: This project template will create a `server.ts` TypeScript file, and include
    the `node.d.ts` declaration file automatically for us. If we compile and run this
    default implementation by simply hitting *F5*, the project template will automatically
    start up a new console to run our Node server, start the server instance, and
    open a browser to connect to this instance. If all goes well at this stage, your
    browser will simply say **Hello World**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `server.ts` TypeScript file that is creating an instance
    of our Node server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this code snippet uses the CommonJs module syntax to tell
    our Node server that it must `import` the library named `'http'`.
  prefs: []
  type: TYPE_NORMAL
- en: This line has two key parts. To explain these key parts, let's start at the
    right-hand side of the `=` sign and work our way towards the left. The `require`
    function takes a single parameter, and is used to tell the application that there
    is a library named `'http'` out there. The `require` function also tells the application
    that it needs this library to be made available to it, in order to continue functioning.
    As `require` is a key part of the syntax of modules in TypeScript, it has been
    given the keyword status and will be highlighted in blue, just like other keywords
    such as `var`, `string`, and `function`. If the application cannot find this `'http'`
    library, then Node will immediately throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side of the `=` sign uses the `import` keyword, which is also
    a fundamental concept in module syntax. The `import` statement tells the application
    to attach the library that has been loaded via the `require` function, `require('http')`,
    into a namespace called `_http`. Whatever functions or objects that the `'http'`
    library has made public will be available to the program via the `_http` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: If we jump to the third line very quickly, we can see that we invoke a function
    called `createServer` that is defined in the `'http'` module, and call it via
    the `_http` namespace. hence `_http.createServer()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default `server.ts` file that is generated by the blank Node project template
    is very slightly different than our preceding code sample. It names the import
    `http`, which matches the library name `''http'',` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import http = require(''http'');`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common naming standard for Node. You can, of course, name your import
    namespaces whatever you like, but it does help to have the namespace match the
    imported library's name, to help with the readability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of our code snippet simply sets up the variable named `port`
    to either be the value of the global variable `process.env.port`, or a default
    value of `1337`. This port number is used on the very last line, and uses fluent
    syntax to call the `listen` function on the returned value of the `http.createServer`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Our `createServer` function has two variables named `req` and `res`. If we use
    our mouse to hover over the `req` variable, we can see that it is of type `_http.ServerRequest`.
    Similarly, the `res` variable is of type `_http.ServerResponse`. These two variables
    are our HTTP request and response streams. In the body of the code, we are invoking
    the `writeHead` function on the HTTP response to set the content-type, and then
    we are invoking the `end` function on the HTTP response to write the text `'Hello
    World\n'` to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: With these couple of lines of code, we have created a running node HTTP server
    that serves up a simple web page with the text **"Hello World"**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you have a keen eye for TypeScript syntax, you will notice that
    this file uses JavaScript syntax and not TypeScript syntax for our `createServer`
    function. This is most probably due to the recent upgrade of the Node toolset
    from JavaScript to TypeScript. The call to `createServer` can also be written
    using TypeScript fat arrow syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Node module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Node module, we simply need to create another TypeScript file to
    house our module code. Let''s create a file named `ServerMain.ts`, and move the
    code that writes to the HTTP response into this module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our `ServerMain` module starts with the `import` of the `'http'` module into
    the `http` namespace. This is necessary to allow us to use the `ServerRequest`
    and `ServerResponse` types that are part of this library.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `export` is now used to indicate what functions will be made available
    to users of this module. As we can see, we have exported a function named `processRequest`
    that takes two parameters, `req` and `res`. This function will be used as a replacement
    for the anonymous function `(req, res) => { … }` that we were using in the `server.ts`
    file previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as good TypeScript coders, we have also strongly typed the `req` and
    `res` variables to be of type `http.ServerRequest`, and of type `http.ServerResponse`
    respectively. This will enable Intellisense within our IDE, and also adheres to
    two principles of strong typing (S.F.I.A.T and self-describing functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we modify the `server.ts` file to use our new module, let''s crack open
    the generated JavaScript file and take a closer look at the CommonJs syntax in
    a little more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first part of this JavaScript is simple enough—we have a function named
    `processRequest`. The last line, however, attaches this function to a property
    on the `exports` global variable. This `exports` global variable is how CommonJs
    publishes modules to the outside world. Any function, class, or property that
    needs to be exposed to the outside world must be attached to the `exports` global
    variable. The TypeScript compiler will generate this line of code for us whenever
    we use the `exports` keyword in a TypeScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Node module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our module in place, we can modify our `server.ts` file to
    use this module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line stays the same, but the second line uses the same `import` and
    `require` syntax to now import our `'./ServerMain'` module into the `ServerMain`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntax that we use to name this module points to a local file module, and
    therefore uses a relative file path to the module file. This relative path will
    resolve to the `ServerMain.js` file that TypeScript has generated. Creating a
    global Node module with the name `'ServerMain'`, which would be globally available—similar
    to the `'http'` module—is outside the scope of this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Our call to the `http.createServer` function now passes in our `processRequest`
    function as an argument. We have changed from an anonymous function using the
    fat arrow syntax, to a named function from the `ServerMain` module. We have also
    started to adhere to our "Separation of Concerns" design pattern. The `server.ts`
    file starts the server on a specific port, and the `ServerMain.ts` file now houses
    the code used to process a single request.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining asynchronous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing Node code, it is necessary to take a careful note of the asynchronous
    nature of all Node programming, as well as JavaScript''s lexical scoping rules.
    Luckily, the TypeScript compiler will generate errors if we break any of these
    rules. As an example of this, let''s update our `ServerMain` module to read in
    a file from disk, and serve up the contents of this file, instead of our `Hello
    world` text, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To read files from disk, we will need to use the Node global module named `"fs"`,
    or filesystem, which is imported on the first line of the code. We then expose
    a new function named `processRequestReadFromFileAnonymous` that again uses the
    `req` and `res` parameters. Within this function, we then use the `fs.readFile`
    function to read a file from disk using three arguments. The first argument is
    the name of the file to be read in, the second argument is the file type, and
    the third argument is a callback function that Node will call, once the file has
    been read from disk.
  prefs: []
  type: TYPE_NORMAL
- en: The body of this anonymous function is similar to what we have seen previously,
    but it also checks the `err` argument to see whether there was an error while
    loading the file. If there was no error, the function simply writes the file to
    the response stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real-world applications, the logic inside of the main `processRequestReadFromFileAnonymous`
    function could become quite complex (besides the name), and may involve more than
    a single step to read a hardcoded filename from disk. Let''s move this anonymous
    function into a private function, and see what happens. Our first pass at refactoring
    this code may be something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have modified the `fs.readFile` function call, and replaced the anonymous
    callback function with a named function—`writeFileToStreamError`. This change,
    however, will immediately generate a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This compilation error is caused by the lexical scoping rules of JavaScript.
    The function `writeFileToStreamError` is trying to use the `res` parameter of
    the parent function. However, as soon as we moved this function outside the lexical
    scope of the parent, the variable `res` is no longer in scope – and will therefore
    be `undefined`. To fix this error, we need to ensure that the lexical scope of
    the `res` argument is maintained within our code structure, and we need to pass
    the value of the `res` argument down to our `writeFileToStream` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the call to `fs.readFile` on the third line in the preceding code,
    we have reverted back to our anonymous syntax, and passed on the value of the
    parent `res` argument down to our new function `writeFileToStream`. This modification
    of our code now correctly adheres to the lexical scoping rules of JavaScript.
    Another side-effect is that we have clearly defined what variables the `writeFileToStream`
    function needs, in order to work. It needs the `err` and `data` variables from
    the `fs.readFile` callback, but it also needs the `res` variable from the original
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have not exported the `writeFileToStream` function; it is purely an internal
    function for use within our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now modify our `server.ts` file to use our new chained function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application now will show the world what our `server.js` file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chaining asynchronous functions](img/image_9665OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Node application serving the contents of a file on disk
  prefs: []
  type: TYPE_NORMAL
- en: Note that because we are using modules, we have been able to write three different
    versions of the `processRequest` function, each with a slight twist. However,
    our modifications to the `server.ts` file that launches the server have been very
    simple. We have just replaced the function that the server calls, in order to
    effectively run three different versions of our application. Again, this complies
    with the "Separation of Concerns" design principle. The `server.ts` code is simply
    used to start the Node server on a specific port, and should not be concerned
    with how each request is processed. Our code within `ServerMain.ts` is responsible
    simply for processing a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our section on writing Node applications within TypeScript.
    As we have seen, the TypeScript developer experience brings with it a compilation
    step, which will quickly trap lexical scoping rules and many other issues within
    our code. Final score, TypeScript: 1, buggy code: 0!'
  prefs: []
  type: TYPE_NORMAL
- en: Using AMD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AMD stands for Asynchronous Module Definition, and as the name suggests, loads
    modules asynchronously. This means that when an HTML page is loaded, requests
    to fetch the JavaScript module files happen at the same time. This allows our
    page to load faster, as we are requesting smaller amounts of JavaScript simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: AMD module loading is typically used in browser applications, and works together
    with third-party libraries that provide a script-loading capability. One of the
    most popular script and module loaders currently available is Require. In this
    section, we will look at how to use the AMD module-loading syntax, and how to
    implement Require in a browser-based application.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let's create a simple TypeScript-based solution, using the "**Html
    application with TypeScript"** Visual Studio template. If you are not using Visual
    Studio, then simply create a new project or base source directory, and set up
    your environment for TypeScript compilation. To use AMD compilation, we will need
    to set our TypeScript project properties in order to compile to the AMD module
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using NuGet, we will then install the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RequireJS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Requirejs.TypeScript.DefinitelyTyped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jQuery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.TypeScript.DefinitelyTyped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JasmineTest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jasmine.TypeScript.DefinitelyTyped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also base our application on Backbone, so we will therefore need the
    following NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Backbone.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Backbone.TypeScript.DefinitelyTyped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Backbone installation will also install Underscore, and the `Backbone.TypeScript.DefinitelyTyped`
    package will also install `underscore.TypeScript.DefinitelyTyped`.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backbone provides a very minimalistic framework for writing rich client-side
    JavaScript applications. It uses the MVC pattern to abstract our logic away from
    direct DOM manipulation. Backbone provides a core set of functionality that is
    broken up into models, collections, and views, as well as some utility classes
    to help with events and routing. The library itself is incredibly small, with
    the minimized `.js` file under 20 KB in size. Its only dependency is Underscore,
    which is a utility library, again under 16 KB in size. Backbone is a very popular
    library, has a huge number of extensions, and is relatively easy to learn and
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: Models, collections and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the core of Backbone lies the model. A model is a class that has a set of
    properties, and represents an item of information that will be treated as a unit.
    You could think of a model as a single row of data in a database table, or as
    an object to hold a particular type of information. Model objects are typically
    very simple, with a few getters and setters for each of their properties, and
    possibly a `url:` property for use with RESTful services. Arrays of models are
    held within a collection. A collection could be thought of as all the rows of
    data in a database table, or a logical group of models, each of the same type.
    Models can contain other models, and can also contain collections, so we are free
    to mix and match and combine collections and models at will.
  prefs: []
  type: TYPE_NORMAL
- en: Models, therefore, are used to define the structure of the data that our application
    uses. Backbone provides a simple `url:` property for both models and collections,
    which is used to synchronize Backbone models with RESTful services. Backbone will
    take care of generating create, read, update, and delete AJAX calls to our services
    via this `url:` property.
  prefs: []
  type: TYPE_NORMAL
- en: Once a model or collection has been created, it is then passed to a view. A
    Backbone view is responsible for combining the properties of a model with an HTML
    template. Templates are made up of normal HTML, but have a special syntax to allow
    the properties of a model to be injected into this HTML. Once this HTML template
    has been combined with a model, the view can render the resultant HTML to the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone does not really have the concept of a controller, as found in the classic
    MVC definition, but we can use normal TypeScript classes to accomplish the same
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's dive right into Backbone, and start with the definition of a model. In
    this sample, we will work with the concept of a contact—that simply has a `Name`
    and `EmailAddress` property—as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this `ContactModel.ts` file is located under the `/tscode/app/models`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start with the definition of an interface named `IContactModel`, which has
    our `Name` and `EmailAddress` properties, both of which are strings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a class named `ContactModel` that derives from, or `extends`,
    the base `Backbone.Model` class. Note that we are using the `export` keyword before
    our class definition, to indicate to the TypeScript compiler that we are creating
    a module that can be imported elsewhere. The `export` keyword and usage is exactly
    the same as what we have seen previously when we used the CommonJS syntax. Our
    `ContactModel` class implements the `IContactModel` interface, and also uses ES5
    `get` and `set` syntax to define the `Name` and `EmailAddress` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of each of these properties calls the Backbone `this.get('<propertyname>')`
    or `this.set('<propertyname>', value)` functions. Backbone stores model properties
    as object attributes, and uses these `get` and `set` functions internally to interact
    with model properties – hence the syntax used previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s follow TDD practices, and write a set of unit tests to make sure that
    we can create an instance of our `ContactModel` correctly. For this test, we will
    create a `ContactModelTests.ts` file under the `/tscode/tests/models` directory,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this test uses the `import <namespace> = require('<filename>')`
    syntax that we have seen previously, to import the `ContactModel` module that
    we exported earlier. You will notice that the file name uses a relative path,
    which drops down two directories (`"../../"`) before specifying the `"app/models/ContactModel"`
    path. This is because AMD module compilation uses paths that are relative to the
    current file. As our test code is in the `/tscode/tests/models` directory, this
    relative path must point to the correct directory that contains the `ContactModel.ts`
    TypeScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Our test defines a variable named `contactModel` that is strongly typed to be
    of type `cm.ContactModel`. Again, we are using the prefix from the `import` statement
    as a namespace in order to reference the exported `ContactModel` class. Our `beforeEach`
    function then creates an instance of the `ContactModel` class, passing a JavaScript
    object with the `Name` and `EmailAddress` properties into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using JSON syntax in the constructor of our `ContactModel` class. This
    syntax closely matches the data that a RESTful service would return, and is, therefore,
    a handy way of constructing classes and assigning properties in a single constructor
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Our first test is checking whether the `contactModel.Name` ES5 syntax works
    correctly, and will return the text `'testName'`. The second test is almost the
    same but uses the `.get('Name')` internal Backbone attribute syntax in order to
    ensure that our TypeScript class and the Backbone class are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The require.config file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have defined a `Backbone.Model`, and have a written a Jasmine test
    for it, we will need to run this test in a browser to verify our results. Generally,
    we would create an HTML page, and then include the `<script>` tags for each of
    our JavaScript files in the header section. This is where AMD steps in. We no
    longer need to specify every JavaScript file in our HTML. All we need to do is
    include a single `<script>` tag for Require ( which is our module loader ), which
    will then co-ordinate the loading of all the files that we need automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s create a `SpecRunner.html` file in the `/tests` directory
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple HTML file. The line to note here, though, is the `<script>`
    tag that loads `/Scripts/require.js`. This script tag has a `data-main` attribute,
    which is set to `"/tscode/tests/TestConfig"`. The `data-main` attribute is passed
    to Require, and it tells Require where to start looking for our JavaScript files.
    In the preceding code, Require will look for a file named `/tscode/tests/TestConfig.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build this `/tscode/tests/TestConfig.ts` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with a call to the `require.config` function, and pass it a JavaScript
    object which has three properties: `baseUrl`, `paths`, and `shim`. The `baseUrl`
    property tells Require what base directory to use when it is looking for JavaScript
    files. In the sample application, our `TestConfig.ts` file is in the `/tscode/tests`
    directory, so our base directory would be `/`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `paths` property specifies the full path to our JavaScript files, and each
    entry is given a name. In the previous example, the script `/Scripts/jasmine/jasmine.js`
    is named `'jasmine'`, and can be referred to as `'jasmine'` throughout the rest
    of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Require will automatically append `.js` to each of these entries, so any entry
    in the `paths` property should NOT include `.js` in the file's entry.
  prefs: []
  type: TYPE_NORMAL
- en: The `shim` property tells Require a few more details about each entry in the
    `paths` property. Take a look at the `shim` entry for `backbone`. It has a `deps`
    property that specifies what the dependencies for Backbone are. Backbone has a
    dependency on Underscore, so Underscore must be loaded before Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: The `exports` property tells Require to append the library to the namespace
    that is specified as the exports' value. In our preceding sample, therefore, any
    call to Underscore must prepend an `_` to any function call in the Underscore
    library. As an example, `_.bindAll` calls the `bindAll` function of Underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies specified in the `shim` section of `require.config` are recursive.
    If we take a look at the shim for `'jasmine-boot'`, we can see that it is dependent
    on `'jasmine-html'`, which in turn is dependent on `'jasmine'`. Require will ensure
    that all these scripts are loaded in the correct order, before running code that
    needs `'jasmine-boot'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s next take a look at the bottom of the file where we call the `require`
    function. This call takes two parameters: an array of files that need to be loaded,
    and a callback function to call once the load step has been completed. This callback
    function has a corresponding parameter for each of the file entries in our array.
    So, in the previous example, `''jasmine-boot''` will be made available to our
    function via the corresponding parameter `jb`. We will see more examples of this
    a bit later.'
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `require` function, each with its array of files that need to be
    loaded, and the corresponding callback parameters, can be nested. In our sample,
    we have nested a second call to the require function inside our initial call,
    but this time we have passed in the `specs` array and omitted the callback parameters.
    This `specs` array currently contains just our `ContactModelTests` file. Our nested
    anonymous function just calls the `window.onload` function, which will trigger
    Jasmine to run all of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call to `window.onload()` has a slightly strange syntax. We are using an
    explicit cast to cast the `window` variable to a type of `<any>` before calling
    the `onload()` function. This is because the TypeScript compiler is expecting
    an `Event` parameter to be passed to the `onload()` function. We do not have an
    event parameter, and need to ensure that the generated JavaScript is in the correct
    syntax – hence the cast to `<any>`.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, we can now fire up our browser and call the `SpecRunner.html`
    page at `/tscode/tests/SpecRunner.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing Require config errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often, when developing AMD applications with Require, we can start to
    get unexpected behaviour, strange error messages, or simply blank pages. These
    strange results are generally caused by the configuration for Require, either
    in the `paths`, `shim`, or `deps` properties. Fixing these AMD errors can be quite
    frustrating at first, but generally, they are caused by one of two things—incorrect
    dependencies or `file-not-found` errors.
  prefs: []
  type: TYPE_NORMAL
- en: To fix these errors, we will need to open the debugging tools within the browser
    that we are using—which for most browsers, is achieved by simply hitting *F12*.
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some AMD errors are caused by incorrect dependencies in our `require.config`.
    These errors can be found by checking the console output in the browser. Dependency
    errors would generate browser errors similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This type of error might mean that the AMD loader has loaded Backbone, for example,
    before loading Underscore. So, whenever Backbone tries to use an underscore function,
    we get a `not defined` error, as shown in the preceding output. The fix for this
    type of error is to update the `deps` property of the library that is causing
    the error. Make sure that all prerequisite libraries have been named in the `deps`
    property, and the errors should go away. If they do not, then the error may be
    caused by the next type of AMD error, a `file-not-found` error.
  prefs: []
  type: TYPE_NORMAL
- en: 404 errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'File-not-found, or 404 errors are generally indicated by console output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out which file is causing the preceding error, switch to the network
    tab in your debugger tools and refresh the page. Look for 404 (`file-not-found`)
    errors, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![404 errors](img/image_9665OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Firefox network tab with 404 errors
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, we can see that the call to `jquery.js` is generating a
    404 error, as our file is actually named `/Scripts/jquery-2.1.1.js`. These sorts
    of errors can be fixed by adding an entry to the `paths` parameter in `require.config`
    so that any call to `jquery.js` is replaced by a call to `jquery-2.1.1.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Require has a good set of documentation for common AMD errors ([http://requirejs.org/docs/errors.html](http://requirejs.org/docs/errors.html))
    as well as advanced API usages, including circular references ([http://requirejs.org/docs/api.html#circular](http://requirejs.org/docs/api.html#circular)),
    so be sure to check the site for more information on possible AMD errors.
  prefs: []
  type: TYPE_NORMAL
- en: Using Backbone.Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a `ContactModel` working and tested, we can build a `Backbone.Collection`
    to house a group of `ContactModel` instances. Since we are using AMD, we can create
    a new `ContactCollection.ts` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a `Backbone.Collection` is relatively straightforward. Firstly, we
    `import` the `ContactModel`, as we have seen previously, and assign it to the
    `cm` namespace. We then create a class named `ContactCollection` that `extends`
    from `Backbone.Collection`, and uses the generic type `cm.ContactModel`. This
    `ContactCollection` has two properties: `model` and `url`. The `model` property
    tells Backbone what model class to use internally, and the `url` property points
    to a server-side RESTful URL. Backbone will generate the correct POST, GET, DELETE,
    and UPDATE HTTP protocols for server-side RESTful calls when we synchronize our
    data with the server. In the preceding sample, we are simply returning a hardcoded
    JSON file, as we will only be using HTTP GETs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the resultant JavaScript file that TypeScript generates, we will
    see that the compiler has modified our file quite a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first six lines of the file starting with `var __extends`, are simply TypeScript's
    implementation of inheritance in JavaScript, and we will not concern ourselves
    too much with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines to note start with the `define` function. TypeScript has wrapped
    our class definition within an outer call to `define`. This `define` function
    call now has three parameters: `require`, `exports`, and `./ContactModel`. The
    syntax and usage of this function are exactly the same as the call to the `require`
    function that we wrote ourselves in the `TestConfig.ts` file.'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is an array of files to import, and the second parameter
    is a callback function to call once these files have been loaded. Again, each
    element in our first array has a corresponding argument in our callback parameters.
    TypeScript will automatically add the `"require"` and `"exports"` parameters for
    us, and then include any file that we specified using the `import` keyword. When
    TypeScript compiles our files using the AMD syntax, it will automatically generate
    this style of JavaScript to be compatible with AMD loaders such as Require.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write a couple of unit tests for our `ContactCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This test starts with an `import` statement for both the `ContactCollection`,
    as well as the `ContactModel`, as we will be using both within this test. It then
    simply creates a new `ContactCollection` and passes in an array of two new `ContactModels`.
    This test highlights how to create a new `ContactCollection`, and populate it
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let ''s now write a test to load the collection via the `url` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This test creates a new `ContactCollection` and then calls the `fetch` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have passed an `async` flag set to `false` to force Backbone to use a synchronous
    call to the server. In other words, the JavaScript will pause until the fetch
    is complete before moving onto the next line. We could have written this test
    using the asynchronous `done` syntax of Jasmine, but for smaller tests, passing
    this `async` flag makes the code a little easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `fetch` function will use the `url` parameter
    to issue a GET HTTP request to the provided URL, which in this case is simply
    loading the `contacts.json` file. The contents of this file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This file uses simple JSON syntax to define four contacts, each with a `Name`
    and `EmailAddress` property. Let''s write a few integration tests to ensure that
    the `fetch` function, using this JSON, actually creates a `ContactCollection`
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test code, we are using the `beforeEach` function to populate our collection
    variable with an instance of the `ContactCollection` class, and are then calling
    the `fetch` function, again with the `{async: false}` flag. Our first test then
    uses the Backbone `at` function to retrieve the first model held within the collection
    at index `0`. We then check the `''Name''` attribute of the returned model, using
    Backbone''s internal `get` function. The second test is using the ES5 syntax of
    our `ContactModel` class, just to test whether Backbone is in fact storing an
    instance of our `ContactModel` class in its collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include these tests in our test suite, we now simply need to modify the
    `TestConfig.ts` file and add an entry to our specs array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Backbone views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a `ContactCollection` to house our `ContactModels`, let''s
    create a `Backbone.View` that will render this collection to the DOM. In order
    to do this, we will actually create two views: one view for each item in the collection,
    and one view for the collection itself. Remember that Backbone views combine a
    `Backbone.Model` with a template in order to render the model''s properties into
    the DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the view to render a single collection item (in this case
    a single `ContactModel`), called `ContactItemView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet starts with an `import` of the `ContactModel` class that we
    have attached to the `cm` namespace. We then create a class named `ContactItemView`
    that `extends` from `Backbone.View`. Similar to the generic syntax that we used
    for our collection, this view class also uses the `ContactModel` as the type for
    its generic instance. Finally, we export this class to make it available to our
    code as an AMD module.
  prefs: []
  type: TYPE_NORMAL
- en: The `ContactItemView` class has a public property named `template` that is a
    function that returns a string. This function takes the model's properties as
    an input argument. The `template` function is assigned in the second line of the
    constructor, to be the result of the call to Underscore's `_.template( … )` function.
    If we take a closer look at the string used in this template function, we will
    see that it is an HTML string that uses the `<%= propertyName %>` syntax, to inject
    the Backbone model's properties into the HTML. We have also specified that the
    DOM `className` should be set to `"contact-item-view"`. Finally, we call the base
    class constructor with the `options` argument that was passed into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we done here? We have created a `Backbone.View` class, specified
    its `className`, and set the `template` that the view should use to render its
    model to the DOM. The last piece of code that we need is the `render` function
    itself. This `render` function does a couple of things in just one line. Firstly,
    each Backbone view has a `$el` property that holds the DOM element. We then call
    the `html` function on this element in order to set it's HTML, and pass in the
    result of a call to the `template` function. By convention, the `render` function
    always returns `this`, to enable a calling class to use fluent syntax after calling
    the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of template engines that can be used with Backbone—such as
    Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)) and Moustache
    ([https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/))
    to name a few. In this sample, we will just stick to the Underscore template engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a `Backbone.View` defined, we can write a simple test for
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet starts with the imports for both `ContactModel` and `ContactItemView`.
    There is only one test in this suite, and it is fairly simple. Firstly, we create
    an instance of a `ContactModel`, setting the `Name` and `EmailAddress` properties
    in the constructor. We then create an instance of the `ContactItemView` class,
    and pass the model we just created as a constructor argument. Note the syntax
    that we are using in the constructor: `{ model: contactModel }`. Backbone views
    can be constructed in a few different ways, and the properties that we set on
    construction – in this case the `model` property – are passed down to the base
    Backbone classes, via the `super()` function call in our constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Our test then calls the `render` function on the `contactItemView` instance.
    Note here that we are then referencing the `$el` property of the view directly,
    and calling the `html` function – as if it were a jQuery DOM element. This is
    the reason why all `render` functions should return `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Our test then checks that the result of the `render` function generates the
    HTML that we expect, based on the template, and our model properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Text plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having hardcoded HTML within our view, however, will make our code difficult
    to maintain. To help with this conundrum, we will use a Require plugin called
    Text. Text uses normal require syntax, just with a `''text!"` prefix to load files
    from the site for use in our code. To install this plugin via NuGet, simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To use Text, we will first need to list `text` in our `require.config paths`
    property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then modify our call to `require` in our `TestConfig.ts` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we create a global variable named `CONTACT_ITEM_SNIPPET`
    to hold our snippet, and then we include the HTML file that we need to load using
    the `'text!<path to html>'` syntax in our call to `require`. Again, each item
    in the array we use for the `require` function call has a corresponding variable
    in our anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, Require will load the text found at `/tscode/app/views/ContactItemView.html`,
    and pass it to our function via the `contactItemSnippet` argument as a string.
    We can then set the global variable `CONTACT_ITEM_SNIPPET` to this value. Before
    we can run this code, however, we will need to modify our `ContactItemView` to
    use this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The changed line in the preceding code is the call invoke the `_.template` function
    using the value of the global variable `CONTACT_ITEM_SNIPPET`, instead of a hard
    coded HTML string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need is to create the `ContactItemView.html` file itself,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This HTML file uses the same `<%= propertyName %>` syntax that we have seen
    before, but we are now able to easily expand our HTML to include outer `divs`,
    and give each property its own CSS classes for some styling later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our tests now, however, will break our `ContactItemViewTests` – because
    the HTML we are using has been changed. Let''s fix this broken test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have commented the offending line, and are using the `.toContain` matcher
    to ensure that our HTML has been injected correctly with the model properties,
    instead of looking for an exact match for the `html` string value.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a view to render individual Contact items, we need another
    view to render the entire `ContactCollection`. To do this, we simply create a
    new `Backbone.View` for our collection, and then create a new `ContactItemView`
    instance for each item in the collection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start this code snippet with our imports for the `ContactModel` and `ContactItemView`
    modules. We then create a `ContactCollectionView` that extends `Backbone.View`,
    this time using a base `Backbone.Model` for the generic syntax. Our `constructor`
    simply passes any `options` that it receives down to the base view class through
    the `super` function call. We then call an Underscore function named `bindAll`.
    The Underscore `bindAll` function is a utility function that binds the scope of
    `this` to the correct context, when used in a class function. Let's explore the
    code a little to make this clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` function will be called by the user of the `ContactCollectionView`,
    and simply calls the `renderChildItem` function for each model that it has in
    its collection. `this.collection.each` takes a single parameter, which is a callback
    function to be called for each model in the collection. We could have written
    this code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This version of the same code uses an anonymous function within the `each` function.
    In our previous code snippet, however, we have written the `renderChildItem` as
    a class function, instead of using an anonymous function. Because of JavaScript's
    lexical scoping rules, this slight change means that the `this` property would
    now refer to the function itself, and not the class instance. By using `_.bindAll(this,'renderChildItem')`,
    we have bound the variable `this` to be the class instance for all calls to `renderChildItem`.
    We can then use the `this` variable within the `renderChildItem` function, and
    `this.$el` will be correctly scoped to the instance of the class `ContactCollectionView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for a couple of tests on this `ContactCollectionView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, the `import` and `beforeAll` functions should be pretty
    easy to decipher, so let''s focus on the body of the actual test. Firstly, we
    are creating a `ContactCollectionView` instance, and passing in this `contactCollection`
    instance via the `{ collection: contactCollection}` property in the constructor.
    Backbone views that work with a single item use the `{ model: <modelName> }` property,
    and views that work with collections use the `{ collection: <collectionInstance>
    }` property. Our first test simply checks to see that the internal `collection`
    property does actually contain a collection whose `length` should be `2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write a test to check that the `renderChildItem` function is called
    when we call the `render` function on our `ContactCollectionView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This test creates a view as we have seen previously, and then creates a spy
    on the `renderChildItem` function. To trigger this function to be called, we call
    the `render` function on our view instance. Finally, we just check that our spy
    has been called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can write a quick test to see if the HTML generated by the `render`
    function contains properties from our collection''s models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This test is very similar to our `ContactItemView` rendering tests, but instead
    uses the `ContactCollectionView` `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the two Backbone views in place, we can now build a simple class to coordinate
    the loading of our collection, and the rendering of the full collection to the
    DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our code starts with imports for each of our various modules. We then create
    a class definition named `ContactViewApp`, and within this class, a method named
    `run`. This `run` method simply creates a new `ContactCollection`, and calls `fetch`
    to trigger Backbone to load the collection. This call to `fetch` then defines
    a `success` and `error` callback, each set to their relevant functions within
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: When the `ContactCollection` fetch returns successfully, Backbone will invoke
    the `contactCollectionLoaded` function. Within this function, we simply create
    a `ContactCollectionView`, and then use jQuery to append the HTML returned via
    the `render` function to the DOM element `"#mainContent"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a web page to put everything together. The contents of our
    HTML page would now read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This page is very similar to the page we were using previously for running
    our tests. We have included an `app.css` link to allow for some styling, and we
    then call Require with a new config file, named `/tscode/app/AppConfig`. We also
    have a `div` within the body tag, with an id of `mainContent`, which will house
    the rendered HTML from our `ContactViewApp`. Now we need to create our `AppConfig.ts`
    file for Require to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note in this code snippet, is that we have now included a
    `paths` reference to our `ContactViewApp`. The corresponding `shim` entry for
    `ContactViewApp` specifies that it has a dependency on `backbone`. Again, we have
    a global variable named `CONTACT_ITEM_SNIPPET`, and we then call the `require`
    function to load our `ContactViewApp` class, as well as the HTML snippet. Note
    too, that we are able to reference our `ContactViewApp` via the `app` argument
    in our anonymous function, and the HTML via the `contactItemSnippet` argument.
    To run the app, we simply create an instance of the `ContactViewApp` class, and
    call the `run` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now be able to see the results of all of our hard work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an application](img/image_9665OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Backbone app running with Require.js
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To finish off our app, let''s use a jQuery plugin called **flip** ([http://lab.smashup.it/flip/](http://lab.smashup.it/flip/))
    that triggers an animation to rotate, or flip, the outer `div` of an item when
    it is clicked. Flip is typical of a range of jQuery plugins that can be applied
    to elements of our application. Before we can trigger a Flip animation, however,
    we will need to respond to a click event from the user within the `ContactItemView`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we have now added an `onClicked` function to our `ContactItemView`
    class that simply pops up an `alert`. Note how we are able to reference the `model`
    property of the view class, in order to read properties from the underlying `Backbone.Model`
    that this class instance was created with. Within the `constructor`, we have also
    set `this.events` to a JavaScript object that has a single property: `''click''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `''click''` property is set to our `onClicked` function, and will be invoked
    when the `ContactItemView` DOM element receives a user''s click event. With this
    in place, whenever we click on a rendered element in our page, we will receive
    an alert popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using jQuery plugins](img/image_9665OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alert popup on click event showing Model properties
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now turn our attention to using the Flip jQuery plugin. Flip relies
    on jQuery as well as jQueryUI, so we will need to install jQueryUI from NuGet
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Flip itself does not have a NuGet package, so will need to download it, and
    included it in our project the old-fashioned way. There is also no DefinitelyTyped
    definition for Flip, so we will need to include one in our project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration file for the Flip plugin is very simply generated from the
    documentation on the website. As Flip is a jQuery plugin, it is available on any
    jQuery object that is reference by the `$( )` notation. Because of this, we must
    `extend` the JQuery type definition with our own – hence we create the jQuery
    interface with our two new functions: `flip` and `revertFlip`. The input to Flip
    has been defined as the `IFlipOptions` interface, as built from the website documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To load this library within Require, we modify our call to `require.config`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added two entries to our paths object: `jqueryui`, and `jqueryflip`.
    We have then added corresponding `shim` entries and specified the relevant dependencies.
    The line to note here, is the `exports` property on `jqueryflip`. We have specified
    that it must export to the `$` symbol. This is the default jQuery selector symbol,
    and all jQuery plugins must export to the `$` symbol, in order to be defined correctly
    when using Require. Our final change to the code is to use the `flip` function
    on the click event of `ContactItemView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are referencing the `$el` element within the `Backbone.View`, which
    is a shorthand syntax for the jQuery selector. We are then calling the `flip`
    function, and specifying a top-to-bottom flip, to last 200 milliseconds. Running
    our page now, and clicking on a contact element will now trigger a flip animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using jQuery plugins](img/image_9665OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Flip.js in action flipping a div element
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have had a look at using modules – both CommonJs and AMD.
    We explored CommonJS modules as used within Node applications, and discussed the
    creation and usage of these modules with TypeScript. We then moved on to browser-based
    modules, and explored the use of AMD compilation in regards to Require. We built
    a very simple Backbone based application, complete with Jasmine unit tests, and
    then had a look at using the Text plugin with Require. We also incorporated a
    third-party jQuery plugin called Flip to provide some animation on our user interface.
    In our next chapter, we will tackle some object-oriented programming principles,
    and have a look at dependency injection and domain events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
