- en: Chapter 3. Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built our first application that uses PDO, we will take a closer
    look at an important aspect of user-friendly web applications—error handling.
    Not only does it inform the user about an error condition, it also limits the
    damage if an error is not detected when it occurred.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Most web applications have rather simple error handling strategy. When an error
    occurs, the script terminates and an error page is presented. The error should
    be logged in the error log, and the developers or maintainers should check the
    logs periodically. The most common sources of errors in database-driven web applications
    are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Server software failure or overload such as the famous "too many connections"
    error
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inappropriate configuration of the application, which may happen when we use
    an incorrect connection string, a rather common mistake when an application is
    moved from one host to another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improper validation of user input, which may lead to malformed SQL and subsequent
    failure of the query
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a record with a duplicate primary key or unique index value, which
    either results from an error in the business logic of the application or may occur
    in a controlled situation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax errors in SQL statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will extend our application so that we can edit existing
    records as well as add new records. As we will deal with user input supplied via
    web forms, we have to take care of its validation. Also, we may add error handling
    so that we can react to non-standard situations and present the user with a friendly
    message.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, let's briefly examine the sources of errors mentioned above
    and see what error handling strategy should be applied in each case. Our error
    handling strategy will use exceptions, so you should be familiar with them. If
    you are not, you can refer to Appendix A, which will introduce you to the new
    object-oriented features of PHP5.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We have consciously chosen to use exceptions, even though PDO can be instructed
    not to use them, because there is one situation where they cannot be avoided.
    The PDO constructors always throw an exception when the database object cannot
    be created, so we may as well use exceptions as our main error‑trapping method
    throughout the code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Sources of Errors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an error handling strategy, we should first analyze where errors can
    happen. Errors can happen on every call to the database, and although this is
    rather unlikely, we will look at this scenario. But before doing so, let's check
    each of the possible error sources and define a strategy for dealing with them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Server Software Failure or Overload
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This can happen on a really busy server, which cannot handle any more incoming
    connections. For example, there may be a lengthy update running in the background.
    The outcome is that we are unable to get any data from the database, so we should
    do the following.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: If the PDO constructor fails, we present a page displaying a message, which
    says that the user's request could not be fulfilled at this time and that they
    should try again later. Of course, we should also log this error because it may
    require immediate attention. (A good idea would be emailing the database administrator
    about the error.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this error is that, while it usually manifests itself before
    a connection is established with the database (in a call to PDO constructor),
    there is a small risk that it can happen after the connection has been established
    (on a call to a method of the `PDO` or `PDOStatement` object when the database
    server is being shutdown). In this case, our reaction will be the same—present
    the user with an error message asking them to try again later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Improper Configuration of the Application
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This error can only occur when we move the application across servers where
    database access details differ; this may be when we are uploading from a development
    server to production server, where database setups differ. This is not an error
    that can happen during normal execution of the application, but care should be
    taken while uploading as this may interrupt the site's operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'If this error occurs, we can display another error message like: "This site
    is under maintenance". In this scenario, the site maintainer should react immediately,
    as without correcting, the connection string the application cannot normally operate.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Improper Validation of User Input
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is an error which is closely related to SQL injection vulnerability. Every
    developer of database-driven applications must undertake proper measures to validate
    and filter all user inputs. This error may lead to two major consequences: Either
    the query will fail due to malformed SQL (so that nothing particularly bad happens),
    or an SQL injection may occur and application security may be compromised. While
    their consequences differ, both these problems can be prevented in the same way.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following scenario. We accept some numeric value from a
    form and insert it into the database. To keep our example simple, assume that
    we want to update a book''s year of publication. To achieve this, we can create
    a form that has two fields: A hidden field containing the book''s ID, and a text
    field to enter the year. We will skip implementation details here, and see how
    using a poorly designed script to process this form could lead to errors and put
    the whole system at risk.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The form processing script will examine two request variables: `$_REQUEST[''book'']`,
    which holds the book''s ID and `$_REQUEST[''year'']`, which holds the year of
    publication. If there is no validation of these values, the final code will look
    similar to this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s see what happens if the user leaves the `book` field empty. The final
    SQL would then look like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This SQL is malformed and will lead to a syntax error. Therefore, we should
    ensure that both variables are holding numeric values. If they don't, we should
    redisplay the form with an error message.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how an attacker might exploit this to delete the contents of
    the entire table. To achieve this, they could just enter the following into the
    `year` field:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This turns a single query into three queries:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, the third query is malformed, but the first and second will execute,
    and the database server will report an error. To counter this problem, we could
    use simple validation to ensure that the `year` field contains four digits. However,
    if we have text fields, which can contain arbitrary characters, the field's values
    must be escaped prior to creating the SQL.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a Record with a Duplicate Primary Key or Unique Index Value
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This problem may happen when the application is inserting a record with duplicate
    values for the primary key or a unique index. For example, in our database of
    authors and books, we might want to prevent the user from entering the same book
    twice by mistake. To do this, we can create a unique index of the ISBN column
    of the `books` table. As every book has a unique ISBN, any attempt to insert the
    same ISBN will generate an error. We can trap this error and react accordingly,
    by displaying an error message asking the user to correct the ISBN or cancel its
    addition.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Syntax Errors in SQL Statements
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This error may occur if we haven't properly tested the application. A good application
    must not contain these errors, and it is the responsibility of the development
    team to test every possible situation and check that every SQL statement performs
    without syntax errors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: If this type of an error occurs, then we trap it with exceptions and display
    a fatal error message. The developers must correct the situation at once.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned a bit about possible sources of errors, let's examine
    how PDO handles errors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Types of Error Handling in PDO
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, PDO uses the **silent error handling mode**. This means that any
    error that arises when calling methods of the `PDO` or `PDOStatement` classes
    go unreported. With this mode, one would have to call `PDO::errorInfo(), PDO::errorCode(),
    PDOStatement::errorInfo()`, or `PDOStatement::errorCode()`, every time an error
    occurred to see if it really did occur. Note that this mode is similar to traditional
    database access—usually, the code calls `mysql_errno()` and `mysql_error()` (or
    equivalent functions for other database systems) after calling functions that
    could cause an error, after connecting to a database and after issuing a query.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Another mode is the **warning mode**. Here, `PDO` will act identical to the
    traditional database access. Any error that happens during communication with
    the database would raise an `E_WARNING` error. Depending on the configuration,
    an error message could be displayed or logged into a file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Finally, PDO introduces a modern way of handling database connection errors—by
    using **exceptions**. Every failed call to any of the `PDO` or `PDOStatement`
    methods will throw an exception.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have previously noted, PDO uses the silent mode, by default. To switch
    to a desired error handling mode, we have to specify it by calling `PDO::setAttribute()`
    method. Each of the error handling modes is specified by the following constants,
    which are defined in the PDO class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::ERRMODE_SILENT` - the *silent* strategy.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::ERRMODE_WARNING` - the *warning* strategy.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::ERRMODE_EXCEPTION` - use *exceptions.*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set the desired error handling mode, we have to set the `PDO::ATTR_ERRMODE`
    attribute in the following way:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see how PDO throws an exception, edit the `common.inc.php` file by adding
    the above statement after the line #46\. If you want to test what will happen
    when PDO throws an exception, change the connection string to specify a nonexistent
    database. Now point your browser to the books listing page.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an output similar to:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Types of Error Handling in PDO](graphics/2660_03_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'This is PHP''s default reaction to uncaught exceptions—they are regarded as
    fatal errors and program execution stops. The error message reveals the class
    of the exception, `PDOException`, the error description, and some debug information,
    including name and line number of the statement that threw the exception. Note
    that if you want to test SQLite, specifying a non-existent database may not work
    as the database will get created if it does not exist already. To see that it
    does work for SQLite, change the `$connStr` variable on line 10 so that there
    is an illegal character in the database name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Refresh your browser and you should see something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Types of Error Handling in PDO](graphics/2660_03_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: As you can see, a message similar to the previous example is displayed, specifying
    the cause and the location of the error in the source code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Error Handling Function
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we know that a certain statement or block of code can throw an exception,
    we should wrap that code within the *try…catch* block to prevent the default error
    message being displayed and present a user-friendly error page. But before we
    proceed, let's create a function that will render an error message and exit the
    application. As we will be calling it from different script files, the best place
    for this function is, of course, the `common.inc.php` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function, called `showError()`, will do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Render a heading saying "Error".
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the error message. We will escape the text with the `htmlspecialchars()`
    function and process it with the `nl2br()` function so that we can display multi-line
    messages. (This function will convert all line break characters to`<br>` tags.)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `showFooter()` function to close the opening`<html>` and`<body>` tags.
    The function will assume that the application has already called the `showHeader()`
    function. (Otherwise, we will end up with broken HTML.)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also have to modify the block that creates the connection object in
    `common.inc.php` to catch the possible exception. With all these changes, the
    new version of `common.inc.php` will look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the newly created function is pretty straightforward. The more
    interesting part is the *try…catch* block that we use to trap the exception. Now
    with these modifications we can test how a real exception will get processed.
    To do that, make sure your connection string is wrong (so that it specifies wrong
    database name for MySQL or contains invalid file name for SQLite). Point your
    browser to `books.php` and you should see the following window:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining an Error Handling Function](graphics/2660_03_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Creating the Edit Book Page
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed earlier, we want to extend our application so that we can
    add and edit books and authors. Also, our system should be able to protect us
    from entering the same book twice—by enforcing the unique index on the `ISBN`
    column in the books table.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed with the code, we will create the index. Fire up your command
    line client and enter the following command (which is the same for MySQL and SQLite):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will also make our edit book page serve two purposes at once—adding a new
    book and editing an existing one. The script will distinguish which action to
    take by the presence of the book ID, either in an URL or in a hidden form field.
    We will link to this new page from within `books.php`, so that we will be able
    to edit every book just by clicking on a link on the books listing page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: This page is more complicated than those described in the previous chapter,
    so I will provide you with the code first and then discuss it. Let's call this
    page edit `Book.php:`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is rather self-documenting, but let's briefly go through its main parts.
    Lines 12 to 23 deal with fetching the book details would be edited if the page
    was requested with the book ID. These details are stored in the `$book` variable.
    Note how we explicitly cast the request parameter `book` to `integer` so that
    no SQL injection can occur (line 13). If no book ID is provided, we set it to
    an empty array. Note how we call the `closeCursor()` function and then assign
    the `$q` variable to null. This is necessary as we are going to reuse the connection
    object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Lines 26 to 33 prepare the list of authors. As our system allows exactly one
    author per book, we will create a select box field listing all the authors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Line 35 checks whether there was a submission of the form. If the test is successful,
    the script validates every field (lines 37 to 68). Every failed validation is
    appended to a list of warnings. (The `$warnings` variable is initialized with
    an empty array.) We will use this list to see whether validations were successful
    and to store error messages if they weren't.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Lines 69 to 94 build the actual SQL for update. The final SQL depends on whether
    we are updating a book (when the `$book` array will contain the **id** key), or
    adding a new one. Note how we quote every column value prior to query execution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Lines 95 to 112 try to execute the query. It may fail if the user has entered
    a duplicate ISBN so we wrap the code in a `try…catch` block. If an exception does
    get thrown, the `catch` block will append the corresponding warning to the `$warnings`
    array. If everything works without an error, the script redirects to the books
    listing page where you should see the changes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Lines 113 to 118 get executed if there was no submission of the form. Here the
    `$_POST` array gets populated with the contents of the `$books` variable. We do
    this because we will use the `$_POST` array to display form fields' values later
    in the code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Note how we display error messages (if any) on lines 122 to 129 and the select
    box on lines 141 to 154\. (We are looking through all authors and if the author's
    ID matches this book author's ID then that author is marked as the selected option.)
    Also, the other form fields are rendered using the `htmlspecialchars()` function
    applied to the items of the `$_POST` array. Lines 189 to 191 will add a hidden
    field to the form that contains the ID of the currently edited book (if any).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Modern web applications employ client-side validation in addition to server-side
    validation of user-supplied data. Though this is not in the scope of this book,
    you might consider browser-based validation in your projects to increase responsiveness
    and potentially decrease load of your web server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should link to the newly created page from the `books.php` page. We
    will provide an *Edit this book* link for every listed book as well as an *Add
    book* link under the table. I will not reproduce the whole `books.php` source
    here, just the lines that should be changed. So, lines 32 to 48 should be replaced
    with the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following should be added just before the call to the `showFooter()` function
    so that the four lines look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if you again navigate to the `books.php` page you should see the following
    window:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Edit Book Page](graphics/2660_03_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'To see how our edit book page looks, click on any **Edit** link in the last
    column of the table. You should see the following form:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Edit Book Page](graphics/2660_03_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Let's see how our form works. It is validating every form field that gets sent
    to the database. If there is any validation error, the form will not update the
    database and prompt the user to correct his submission. For example, try changing
    the author select box to the default option (labeled *Please select…)* and editing
    the ISBN to be 5 digits long.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click the **Save** button, you should see that the form displays following
    error messages:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Edit Book Page](graphics/2660_03_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Now correct the errors and try to change the ISBN to 1904811027\. This ISBN
    is already used in our database by another book, so the form will again display
    an error. You can further test the form by adding a book. You might also want
    to test how it works with SQLite.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Edit Author Page
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application still lacks the add/edit author functionality. This page will
    be somewhat simpler than the edit book page because it will not have the select
    box for authors and no unique index. (You may want to create a unique index on
    the author's first and last name columns to prevent duplicates there too, but
    we will leave this up to you.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call this page `editAuthor.php`. Here is its source code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This source is built in the same way as the `editBook.php` page so you should
    be able to follow it easily.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We will link to the `editAuthors.php` page in the same way as we linked to
    the `editBook.php` page from the `books.php` page. Edit the `authors.php` file
    and change lines 30-41 to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following line just before the last PHP block:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, if you refresh the `authors.php` page you will see the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Edit Author Page](graphics/2660_03_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: You can click the **Edit** links in the rightmost column to edit every author's
    details. You can try submitting the form with empty values to see that invalid
    submissions will be rejected. Also, you can try and add a new author to the system.
    After you successfully do this, you may want to go back to books listing and edit
    some book. You will see that newly created author is available in the **authors**
    select box.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Securing against Uncaught Exceptions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen previously, we place the *try...catch* blocks around code that
    can throw exceptions. However, in very rare cases, there might be some unexpected
    exceptions. We can imitate such an exception by modifying one of the queries so
    that it contains some malformed SQL. For example, let''s edit `authors.php`, line
    16 to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，我们在可能引发异常的代码周围放置了*try...catch*块。然而，在非常罕见的情况下，可能会出现一些意外的异常。我们可以通过修改其中一个查询来模拟这样的异常，使其包含一些格式不正确的SQL。例如，让我们编辑`authors.php`，将第16行修改为以下内容：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now try to navigate to `authors.php` with your browser to see that an uncaught
    exception has occurred. To correctly handle this situation, we either should create
    an exception handler or wrap every block of code that calls `PDO` or `PDOStatement`
    class methods in a *try…catch* block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用浏览器导航到`authors.php`，看看是否发生了未捕获的异常。为了正确处理这种情况，我们要么创建一个异常处理程序，要么将调用`PDO`或`PDOStatement`类方法的每个代码块包装在*try...catch*块中。
- en: Let's see how we can create the exception handler. This is an easier approach
    as it does not require changing lots of code. However, for big applications this
    may be bad practice as handling exceptions, where they occur may be more secure
    and better recovery logic can be applied.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建异常处理程序。这是一种更简单的方法，因为它不需要改变大量的代码。然而，对于大型应用程序来说，这可能是一个不好的做法，因为在发生异常的地方处理异常可能更安全，并且可以应用更好的恢复逻辑。
- en: 'However, with our simple application we can use the global exception handler.
    It will just use the `showError()` function to say that the site is under maintenance:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们简单的应用程序，我们可以使用全局异常处理程序。它将只是使用`showError()`函数来表示网站正在维护中。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Place this into `common.inc.php`, just before the connection creation code block.
    If you refresh the `authors.php` page now, you will see that the handler gets
    called.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码放入`common.inc.php`中，就在连接创建代码块之前。如果现在刷新`authors.php`页面，你会看到处理程序被调用了。
- en: It is always a good idea to have the default exception handler. As you have
    noticed, unhandled exceptions expose too much sensitive information including
    database connection details. Also, in real world applications the error pages
    should not display any information about the type of the error. (Note that our
    example application does.) The default handler should write to the error log and
    alert site maintainers about the error.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有默认的异常处理程序总是一个好主意。正如你已经注意到的，未处理的异常会暴露太多敏感信息，包括数据库连接详细信息。此外，在真实世界的应用程序中，错误页面不应显示有关错误类型的任何信息。（请注意，我们的示例应用程序是这样的。）默认处理程序应该写入错误日志，并通知网站维护人员有关错误的信息。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined how `PDO` handles errors and introduced exceptions.
    Also, we investigated the sources of errors and saw how to counter them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了`PDO`如何处理错误，并介绍了异常。此外，我们调查了错误的来源，并看到了如何对抗它们。
- en: Our sample application was extended with some real-world administration functionality
    that uses data validation and is secured against SQL injection attacks. Of course,
    they should also allow database modifications only to certain users based on login
    names and passwords. However, this is beyond the scope of this book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序已经扩展了一些真实世界的管理功能，使用了数据验证，并且受到了SQL注入攻击的保护。当然，他们还应该只允许基于登录名和密码的特定用户对数据库进行修改。然而，这超出了本书的范围。
- en: In the next chapter, we will look at another very important aspect of PDO and
    database programming in general—using prepared statements. We will see how our
    administration pages can be simplified with their help, leading to less code and
    better maintenance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到PDO和数据库编程中另一个非常重要的方面——使用预处理语句。我们将看到如何借助它们来简化我们的管理页面，从而减少代码量并提高维护性。
