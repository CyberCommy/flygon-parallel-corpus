- en: Harnessing the Power of PHP 7 Data Structures and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to harness PHP 7's performance boosts using
    most of its key optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will explore how better understanding data structures and datatypes,
    and how using simplified functions can help a PHP application's global performance
    along its critical execution path.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we will learn how it is best to avoid using inefficient structures,
    like most dynamic ones, in our PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, although PHP is not a functional language, we will see how some functional
    techniques can be of immediate help when optimizing PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, in this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7 optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying possible optimizations and avoiding dynamic structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming and memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP 7 optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 is in itself a major optimization. A good part of PHP's code base was
    rewritten for this release and most official benchmarks show that, generally speaking,
    almost any PHP code will run about two times faster or more with PHP 7 than with
    previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: PHP is programmed in C and optimizing the performance of Zend's **Ahead-Of-Time**
    (**AOT**) compiler depends ultimately on using the C compiler's internal logic
    in an optimized way. This latest version of PHP is the result of many years of
    research and experiments by Zend. The greater part of these optimizations was
    implemented by eliminating the performance overhead generated by certain PHP internal
    structural constructs and data structures. According to *Dmitry Stogov[1]*, *a
    typical real-life PHP application spends about 20% of the CPU time in the memory
    manager, 10% doing hash table operations, 30% in internal functions and only 30%
    in the VM.* In order to optimize the execution of PHP code, PHP 7's new version
    of the Zend Engine had to start by representing source code in an **Abstract Syntax
    Tree** (**AST**), thus allowing the engine to generate better quality **Intermediate
    Representations** (**IR**) of the source code and, since PHP 7.1, to be able to
    remove dead code and reduce as many expressions as possible to their static representation
    through **Static Single Assignment** (**SSA**) form and type inference. In turn,
    this allows the engine to only allocate necessary data structures to the stack
    instead of the heap in memory at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This is very important in order to understand the rest of this chapter, as it
    allows us to see why datatype juggling and dynamic structures in general will
    create most of the overhead by bloating memory allocation at runtime, why certain
    data structures had to be re-implemented to allow for C-level performance and
    why immutability is a developer's ally when trying to achieve better code performance.
    Let's have a look at these elements more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Strict typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a language is dynamically typed, that is to say, it has loosely typed variables,
    it provides a higher level of abstraction that boosts the developer's productivity,
    but doesn't offer the best performance since its compiler has more work to do
    when trying to determine the datatypes of its variables. It comes as no surprise
    that strongly typed languages have always had better performance at runtime than
    loosely typed ones. This conclusion was confirmed by Facebook's HipHop project,
    which conducted benchmark tests with different languages and came to the conclusion
    that statically compiled languages always execute more quickly and consume less
    memory than dynamic ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although PHP 7 is still a loosely typed language, it now offers the possibility
    to strict type variables and function signatures. This can be easily tested by
    executing the following code example. Let''s run the following code to see its
    current performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of running this script using `Blackfire.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f09bed69-e006-4a81-a39f-ad95751fbe9e.png)The profiling report when
    omitting to do strict typing of variables and function signatures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s replace the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute it, we will immediately see the difference in performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/694aceeb-df0c-4312-ac07-845f920538f7.png)The profiling report when
    strict typing variables and function signatures'
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance boost can also be seen using the `microtime()` function. Let''s
    run both versions of our script and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6eceebe1-668a-4c3c-8749-bb70f9ff3648.png)Comparing script performance
    with the microtime() function'
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully benefit from PHP's new AST and SSA features, developers should
    try to strictly type variables and function signatures as much as possible. This
    will become especially true when the Zend Engine gets, in future releases, a **Just-In-Time**
    (**JIT**) compiler as this will allow for further optimizations solely based on
    type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Also, an added bonus of strict typing is that it lets the compiler manage an
    aspect of code quality by eliminating the necessity of having unit tests that
    simply make sure that functions are behaving as expected when receiving unexpected
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable and packed arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we will see later in this chapter, immutability not only helps the developer
    lessen his cognitive burden while programming and makes for better quality code
    and better unit tests in general, but will also allow for better code optimizations
    by the compiler. As of PHP 7, any static array is cached by OPcache and a pointer
    to the array is shared with any part of the code that tries to access it. Moreover,
    PHP 7 offers a very important optimization for packed arrays, which are arrays
    that are indexed with ascending integers only. Let''s take the following code
    and execute it against PHP 5.6 and then PHP 7 with OPcache enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the previous code with PHP 5.6, we consume almost 7.4 MB of memory
    and the elapsed time is 0.005 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df382441-74a2-45f4-92f1-fc2e750ab0d2.png)The results when running
    the script against PHP 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the same code with PHP 7, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/49b7fa67-c85d-412a-8889-450f65f22082.png)The results when running
    the same script against PHP 7.1'
  prefs: []
  type: TYPE_NORMAL
- en: The results are impressive. The same script is 40 times faster and consumes
    almost 10 times less memory. Immutable arrays therefore provide more speed and
    developers should avoid modifying large arrays and encourage the use of packed
    arrays as much as possible when dealing with large arrays in order to optimize
    memory allocation and maximize speed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation of integers and floats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another optimization introduced by PHP 7 is the reuse of previously allocated
    variable containers. If you need to create a large number of variables, you should
    try to reuse them, as PHP 7''s compiler will avoid reallocating memory and reuse
    the memory slots that are already allocated. Let''s have a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this code against PHP 5.6 and PHP 7 in order to see the difference
    in memory consumption. Let''s start with PHP 5.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2473ad97-fcf2-4790-bbbf-f365b20254a6.png)The results when running
    the script against PHP 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run the same script with PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7b7954ca-cba2-44a4-b588-c7efb8e78b2d.png)The results when running
    the same script against PHP 7.1'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the results show us that memory consumption was reduced by almost
    a third. Although this goes against the very principle of the immutability of
    variables, it is still a very important optimization when you must allocate a
    large number of variables in memory.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation and concatenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In PHP 7, string interpolation has been optimized with a new string analysis
    algorithm. This means that string interpolation is now much faster than concatenation
    and that what used to be true about concatenation and performance is no longer
    the case. Let''s take the following code example in order to measure the new algorithm''s
    performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the performance measurements when running this code against PHP 5.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aff9b54f-71a9-43e0-8a4c-ddd1dc2dda5b.png)The results when running
    the script against PHP 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the same script with PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a82a65f3-b669-4d74-9811-9ff5d1bc9e49.png)The results when running
    the same script against PHP 7.1'
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7 is about three to four times faster and consumes more than a third less
    memory. The lesson to be learned here is to try using PHP 7's string interpolation
    algorithm as much as possible when dealing with strings.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though it is best to avoid passing a variable by reference to a function
    in order to avoid altering your application''s state outside of the function,
    PHP 7 makes it possible to pass variables by reference to functions in a highly
    optimized way even if the reference is a mismatch. Let''s take the following code
    example in order to better understand how PHP 7 is much more efficient in doing
    so than PHP 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this code with the PHP 5 binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68ecb6f7-c0d3-4e15-9be6-4de0b577dcb6.png)The results when running
    the script against PHP 5.6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result when executing the same code with PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/817ef153-f0e1-44f3-b593-8c1d37f9f150.png)The results when running
    the same script against PHP 7.1'
  prefs: []
  type: TYPE_NORMAL
- en: The results are once more very impressive as PHP 7 does the same work with almost
    a third less memory allocation and 1,000 times faster! What is happening under
    the hood is that PHP 7 no longer makes copies in memory of variables when a reference
    mismatch occurs. Thus, the new compiler avoids bloating memory allocation for
    nothing and speeds up the execution of any PHP script where reference mismatches
    are an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying more possible optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When optimizing an application, you will start by identifying the most time-consuming
    functions, especially along the application's critical path. As stated in a previous
    chapter, most of those functions will be I/O functions as these are always the
    most expensive operations for a computer to execute. Most of the time you will
    see the possibility to optimize loops and reduce the number of system calls, but
    you will soon realize that I/O operations remain costly no matter what optimizations
    you wish to bring to them. Sometimes, though, you might run into very slow PHP
    structures that can simply be replaced with faster ones, or you may realize that
    poorly designed code can easily be refactored to be less resource-hungry, such
    as when replacing a dynamic structure with a simpler static one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, dynamic structures should be avoided unless absolutely necessary. We
    will now have a look at a very simple example. We will program the same functionality
    four times, but with three different approaches: functional and dynamic, functional
    and static, and finally, structural and static. Let''s start with the functional
    and dynamic approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates an array with 1,000 elements by calling the same closure
    recursively. If we run this code, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/310cd67e-f945-42ef-9ed8-f35f6e010b06.png)Time elapsed and memory
    consumed when running the script programmed with the functional and dynamic approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the results of running this script using `Blackfire.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/865efdb5-9f6d-4340-acfc-691e6fd1940a.png)The profiling report when
    running the script programmed with the functional and dynamic approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s code the same functionality, but in a more static fashion with a classic
    named function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this version of our code, we obtain the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d09776a-1981-4715-a040-1409ede0791b.png)Time elapsed and memory
    consumed when running the script programmed with the functional and static approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script with the `Blackfire.io` profiler yields these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/532b428d-1d99-4a5a-bf3d-814a59bb8755.png)The profiling report when
    running the script programmed with the functional and static approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s program this functionality again, but in a very structural
    and static way by using a `for` loop instead of tail-calling the function recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results after executing this latest version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38692ba5-dce2-4731-82d6-a4e9ac58f5fb.png)Time elapsed and memory
    consumed when running the script programmed with the structural and static approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results of profiling this version of the script with `Blackfire.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e1edd60-f97e-4acc-bce6-dc8d84e5a2a5.png)The profiling report when
    running the script programmed with the structural and static approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results clearly show that the structural approach is the fastest. If we
    now go a little further down the structural route, with only a hint of functional
    programming, and try using a generator to create the array iteratively, we should
    not be surprised by the high performance results that we will get. Here is the
    last version of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result when running the latest version of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3201960-6ec7-4e70-92cb-98af3f9ca57a.png)Time elapsed and memory
    consumed when running the script programmed with a very structural and static
    approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results with `Blackfire.io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f6f60c39-b8b5-4b8a-91fa-6b5cb6076733.png)The profiling report when
    running the script programmed with a very structural and static approach'
  prefs: []
  type: TYPE_NORMAL
- en: The results clearly show how this last version of our code really outperforms
    the other ones. Indeed, PHP is still a very structural language as its compiler
    still does not fully optimize tail-recursion calls and does take less time to
    complete the execution of a program if it is coded in a structural way. Does this
    mean that PHP will never be a functional language and that it is best to avoid
    programming in a functional way in PHP? The short answer is no. Also, does this
    mean that functional programming with PHP is a thing of the future only? Again,
    the answer is no. There are certain functional programming techniques that we
    can use immediately and that will help our scripts be more performant. Let's have
    a look at one in particular, which is memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP is an imperative and not a declarative language, which means that programming
    is done using statements that alter the state of the program, just like other
    languages in the C family, and it is not composed of stateless expressions or
    declarations, like SQL for example. Though PHP is primarily a structural (procedural)
    and object-oriented programming language, we have seen, since PHP 5.3, more and
    more requests for change that asked for more and more structures that are functional
    in nature, such as generators and lambda functions (anonymous functions). Nevertheless,
    PHP remains for now a structural language in nature, especially when it comes
    to performance.
  prefs: []
  type: TYPE_NORMAL
- en: This being said, most functional programming techniques will yield fruit a few
    years from now, but there are still some functional programming techniques that
    can be used immediately in PHP that will improve performance as soon as you implement
    them in the code base of a project. One such technique is memoization.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is a functional programming technique in which the result of an
    expensive functional computation is stored and reused each time it is called within
    the same program. The idea is to return the static value of a function when it
    receives a certain input. Obviously, to avoid the invalidation of values, the
    function should be referentially transparent, which means that it should always
    return the same output when given a specific input. Of course, this comes in handy
    when you realize that a referentially transparent function is called many times
    along the critical path of an application and is computed every time. Memoization
    is an easy optimization to implement as it simply creates a cache to store the
    results of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example that will help us easily grasp the idea behind
    it. Let''s say we have the following code along the critical path of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that the same function is called recursively many times. Moreover,
    it is a referentially transparent function. Therefore, it is a perfect candidate
    for memoization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by checking its performance. If we execute the code, we will get
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4111c620-6852-4dc9-8a5a-88e2e5370845.png)The results before implementing
    memoization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement a cache to memoize the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results when executing this new version of the same code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8626594-4df0-4a81-9a97-cc503216f617.png)The results after implementing
    memoization'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the PHP script now runs much faster. The more often a referentially
    transparent function is called along the critical path of your application, the
    more the speed will increase when using memoization. Let's have a look at our
    script's performance using `Blackfire.io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results when executing the script without memoization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d9cbb171-7264-4da1-ab25-a6137c8c10a7.png)The profiling report when
    not using memoization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results with memoization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30e818e4-d067-4b3c-ac71-7a3317063b81.png)The profiling report when
    using memoization'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison shows that the memoized version of the script runs about eight
    times faster and consumes a third less memory. An important gain in performance
    for such an easy implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final question concerning memoization might be: can we cache the result
    between runs of the same script? Of course we can. It is up to you to determine
    the best way to cache it. You can use any standard way of caching a result. Also,
    there is at least one library that you can use to cache memoized results in PHP.
    You will find it at the following address: [https://github.com/koktut/php-memoize](https://github.com/koktut/php-memoize).
    Please be aware that this library would not have been a good option for our last
    script as it doesn''t work well with recursive tail-calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how PHP 7 is an optimization in itself, how
    avoiding dynamic structures in general will always boost the performance of your
    PHP scripts and how certain functional programming techniques such as memoization
    can be strong allies when optimizing code performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to cope with input and output (I/O) poor
    latency by learning about generators and asynchronous non-blocking code, multithreading
    with the POSIX threads (`pthreads`) library and multitasking with the `ReactPHP`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[http://news.php.net/php.internals/73888](http://news.php.net/php.internals/73888)'
  prefs: []
  type: TYPE_NORMAL
