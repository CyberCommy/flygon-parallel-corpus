- en: Chapter 10. Generic Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here again is a recurring theme of this book: at its worst, web development
    is boring and monotonous. So far, we''ve covered how Django tries to take away
    some of that monotony at the model and template layers, but web developers also
    experience this boredom at the view level.'
  prefs: []
  type: TYPE_NORMAL
- en: Django's *generic views* were developed to ease that pain.
  prefs: []
  type: TYPE_NORMAL
- en: They take certain common idioms and patterns found in view development and abstract
    them so that you can quickly write common views of data without having to write
    too much code. We can recognize certain common tasks, like displaying a list of
    objects, and write code that displays a list of any object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the model in question can be passed as an extra argument to the URLconf.
    Django ships with generic display views to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Display list and detail pages for a single object. If we were creating an application
    to manage conferences, then a `TalkListView` and a `RegisteredUserListView` would
    be examples of list views. A single talk page is an example of what we call a
    detail view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present date-based objects in year/month/day archive pages, associated detail,
    and latest pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to create, update, and delete objects-with or without authorization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken together, these views provide easy interfaces to perform the most common
    tasks developers encounter when displaying database data in views. Finally, display
    views are only one part of Django's comprehensive class-based view system. For
    a full introduction and detailed description of the other class-based views Django
    provides, see [Appendix C](apc.xhtml "Appendix C. Generic View Reference"), *Generic
    View Reference*.
  prefs: []
  type: TYPE_NORMAL
- en: Generic views of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's generic views really shine when it comes to presenting views of your
    database content. Because it's such a common task, Django comes with a handful
    of built-in generic views that make generating list and detail views of objects
    incredibly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at some examples of showing a list of objects or an
    individual object. We''ll be using these models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to define a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally hook that view into your urls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all the Python code we need to write. We still need to write a template,
    however. We could explicitly tell the view which template to use by adding a `template_name`
    attribute to the view, but in the absence of an explicit template Django will
    infer one from the object's name. In this case, the inferred template will be
    `books/publisher_list.html`-the books part comes from the name of the app that
    defines the model, while the "publisher" bit is just the lowercased version of
    the model's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when (for example) the `APP_DIRS` option of a `DjangoTemplates` backend
    is set to True in `TEMPLATES`, a template location could be: `/path/to/project/books/templates/books/publisher_list.html`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This template will be rendered against a context containing a variable called
    `object_list` that contains all the publisher objects. A very simple template
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's really all there is to it. All the cool features of generic views come
    from changing the attributes set on the generic view. [Appendix C](apc.xhtml "Appendix C. Generic
    View Reference"), *Generic View Reference*, documents all the generic views and
    their options in detail; the rest of this document will consider some of the common
    ways you might customize and extend generic views.
  prefs: []
  type: TYPE_NORMAL
- en: Making "friendly" template contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed that our sample publisher list template stores all the
    publishers in a variable named `object_list`. While this works just fine, it isn''t
    all that "friendly" to template authors: they have to "just know" that they''re
    dealing with publishers here.'
  prefs: []
  type: TYPE_NORMAL
- en: In Django, if you're dealing with a model object, this is already done for you.
    When you are dealing with an object or queryset, Django populates the context
    using the lower cased version of the model class' name. This is provided in addition
    to the default `object_list` entry, but contains exactly the same data, that is `publisher_list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this still isn''t a good match, you can manually set the name of the context
    variable. The `context_object_name` attribute on a generic view specifies the
    context variable to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Providing a useful `context_object_name` is always a good idea. Your co-workers
    who design templates will thank you.
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often you simply need to present some extra information beyond that provided
    by the generic view. For example, think of showing a list of all the books on
    each publisher detail page. The `DetailView` generic view provides the publisher
    to the context, but how do we get additional information in that template?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to subclass `DetailView` and provide your own implementation
    of the `get_context_data` method. The default implementation simply adds the object
    being displayed to the template, but you can override it to send more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, `get_context_data` will merge the context data of all parent classes
    with those of the current class. To preserve this behavior in your own classes
    where you want to alter the context, you should be sure to call `get_context_data`
    on the super class. When no two classes try to define the same key, this will
    give the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: However, if any class attempts to override a key after parent classes have set
    it (after the call to super), any children of that class will also need to explicitly
    set it after super if they want to be sure to override all parents. If you're
    having trouble, review the method resolution order of your view.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing subsets of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s take a closer look at the `model` argument we''ve been using all
    along. The `model` argument, which specifies the database model that the view
    will operate upon, is available on all the generic views that operate on a single
    object or a collection of objects. However, the `model` argument is not the only
    way to specify the objects that the view will operate upon-you can also specify
    the list of objects using the `queryset` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying `model = Publisher` is really just shorthand for saying `queryset
    = Publisher.objects.all()`. However, by using `queryset` to define a filtered
    list of objects you can be more specific about the objects that will be visible
    in the view. To pick a simple example, we might want to order a list of books
    by publication date, with the most recent first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a pretty simple example, but it illustrates the idea nicely. Of course,
    you''ll usually want to do more than just reorder objects. If you want to present
    a list of books by a particular publisher, you can use the same technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that along with a filtered `queryset`, we're also using a custom template
    name. If we didn't, the generic view would use the same template as the "vanilla"
    object list, which might not be what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that this isn't a very elegant way of doing publisher-specific books.
    If we want to add another publisher page, we'd need another handful of lines in
    the URLconf, and more than a few publishers would get unreasonable. We'll deal
    with this problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get a 404 when requesting `/books/acme/`, check to ensure you actually
    have a Publisher with the name 'ACME Publishing'. Generic views have an `allow_empty`
    parameter for this case.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common need is to filter down the objects given in a list page by some
    key in the URL. Earlier we hard-coded the publisher's name in the URLconf, but
    what if we wanted to write a view that displayed all the books by some arbitrary
    publisher?
  prefs: []
  type: TYPE_NORMAL
- en: Handily, the `ListView` has a `get_queryset()` method we can override. Previously,
    it has just been returning the value of the `queryset` attribute, but now we can
    add more logic. The key part to making this work is that when class-based views
    are called, various useful things are stored on `self`; as well as the request
    (`self.request`), this includes the positional (`self.args`) and name-based (`self.kwargs`)
    arguments captured according to the URLconf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a URLconf with a single captured group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll write the `PublisherBookList` view itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s quite easy to add more logic to the queryset selection;
    if we wanted, we could use `self.request.user` to filter using the current user,
    or other more complex logic. We can also add the publisher into the context at
    the same time, so we can use it in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Performing extra work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last common pattern we''ll look at involves doing some extra work before
    or after calling the generic view. Imagine we had a `last_accessed` field on our
    `Author` model that we were using to keep track of the last time anybody looked
    at that author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic `DetailView` class, of course, wouldn''t know anything about this
    field, but once again we could easily write a custom view to keep that field updated.
    First, we''d need to add an author detail bit in the URLconf to point to a custom
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''d write our new view-`get_object` is the method that retrieves the
    object-so we simply override it and wrap the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The URLconf here uses the named group `pk`-this name is the default name that
    `DetailView` uses to find the value of the primary key used to filter the queryset.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to call the group something else, you can set `pk_url_kwarg` on
    the view. More details can be found in the reference for `DetailView.`
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at only a couple of the generic views Django ships
    with, but the general ideas presented here apply pretty closely to any generic
    view. [Appendix C](apc.xhtml "Appendix C. Generic View Reference"), *Generic View
    Reference*, covers all the available views in detail, and it's recommended reading
    if you want to get the most out of this powerful feature.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section of this book devoted to advanced usage of models,
    templates and views. The following chapters cover a range of functions that are
    very common in modern commercial websites. We will start with a subject essential
    to building interactive websites-user management.
  prefs: []
  type: TYPE_NORMAL
