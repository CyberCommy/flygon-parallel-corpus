- en: Chapter 10. Generic Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here again is a recurring theme of this book: at its worst, web development
    is boring and monotonous. So far, we''ve covered how Django tries to take away
    some of that monotony at the model and template layers, but web developers also
    experience this boredom at the view level.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Django's *generic views* were developed to ease that pain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: They take certain common idioms and patterns found in view development and abstract
    them so that you can quickly write common views of data without having to write
    too much code. We can recognize certain common tasks, like displaying a list of
    objects, and write code that displays a list of any object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the model in question can be passed as an extra argument to the URLconf.
    Django ships with generic display views to do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Display list and detail pages for a single object. If we were creating an application
    to manage conferences, then a `TalkListView` and a `RegisteredUserListView` would
    be examples of list views. A single talk page is an example of what we call a
    detail view.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present date-based objects in year/month/day archive pages, associated detail,
    and latest pages.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to create, update, and delete objects-with or without authorization.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken together, these views provide easy interfaces to perform the most common
    tasks developers encounter when displaying database data in views. Finally, display
    views are only one part of Django's comprehensive class-based view system. For
    a full introduction and detailed description of the other class-based views Django
    provides, see [Appendix C](apc.xhtml "Appendix C. Generic View Reference"), *Generic
    View Reference*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Generic views of objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's generic views really shine when it comes to presenting views of your
    database content. Because it's such a common task, Django comes with a handful
    of built-in generic views that make generating list and detail views of objects
    incredibly easy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at some examples of showing a list of objects or an
    individual object. We''ll be using these models:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we need to define a view:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally hook that view into your urls:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all the Python code we need to write. We still need to write a template,
    however. We could explicitly tell the view which template to use by adding a `template_name`
    attribute to the view, but in the absence of an explicit template Django will
    infer one from the object's name. In this case, the inferred template will be
    `books/publisher_list.html`-the books part comes from the name of the app that
    defines the model, while the "publisher" bit is just the lowercased version of
    the model's name.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when (for example) the `APP_DIRS` option of a `DjangoTemplates` backend
    is set to True in `TEMPLATES`, a template location could be: `/path/to/project/books/templates/books/publisher_list.html`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'This template will be rendered against a context containing a variable called
    `object_list` that contains all the publisher objects. A very simple template
    might look like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's really all there is to it. All the cool features of generic views come
    from changing the attributes set on the generic view. [Appendix C](apc.xhtml "Appendix C. Generic
    View Reference"), *Generic View Reference*, documents all the generic views and
    their options in detail; the rest of this document will consider some of the common
    ways you might customize and extend generic views.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Making "friendly" template contexts
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have noticed that our sample publisher list template stores all the
    publishers in a variable named `object_list`. While this works just fine, it isn''t
    all that "friendly" to template authors: they have to "just know" that they''re
    dealing with publishers here.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In Django, if you're dealing with a model object, this is already done for you.
    When you are dealing with an object or queryset, Django populates the context
    using the lower cased version of the model class' name. This is provided in addition
    to the default `object_list` entry, but contains exactly the same data, that is `publisher_list`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'If this still isn''t a good match, you can manually set the name of the context
    variable. The `context_object_name` attribute on a generic view specifies the
    context variable to use:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Providing a useful `context_object_name` is always a good idea. Your co-workers
    who design templates will thank you.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra context
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often you simply need to present some extra information beyond that provided
    by the generic view. For example, think of showing a list of all the books on
    each publisher detail page. The `DetailView` generic view provides the publisher
    to the context, but how do we get additional information in that template?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to subclass `DetailView` and provide your own implementation
    of the `get_context_data` method. The default implementation simply adds the object
    being displayed to the template, but you can override it to send more:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, `get_context_data` will merge the context data of all parent classes
    with those of the current class. To preserve this behavior in your own classes
    where you want to alter the context, you should be sure to call `get_context_data`
    on the super class. When no two classes try to define the same key, this will
    give the expected results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: However, if any class attempts to override a key after parent classes have set
    it (after the call to super), any children of that class will also need to explicitly
    set it after super if they want to be sure to override all parents. If you're
    having trouble, review the method resolution order of your view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Viewing subsets of objects
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s take a closer look at the `model` argument we''ve been using all
    along. The `model` argument, which specifies the database model that the view
    will operate upon, is available on all the generic views that operate on a single
    object or a collection of objects. However, the `model` argument is not the only
    way to specify the objects that the view will operate upon-you can also specify
    the list of objects using the `queryset` argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Specifying `model = Publisher` is really just shorthand for saying `queryset
    = Publisher.objects.all()`. However, by using `queryset` to define a filtered
    list of objects you can be more specific about the objects that will be visible
    in the view. To pick a simple example, we might want to order a list of books
    by publication date, with the most recent first:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That''s a pretty simple example, but it illustrates the idea nicely. Of course,
    you''ll usually want to do more than just reorder objects. If you want to present
    a list of books by a particular publisher, you can use the same technique:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that along with a filtered `queryset`, we're also using a custom template
    name. If we didn't, the generic view would use the same template as the "vanilla"
    object list, which might not be what we want.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that this isn't a very elegant way of doing publisher-specific books.
    If we want to add another publisher page, we'd need another handful of lines in
    the URLconf, and more than a few publishers would get unreasonable. We'll deal
    with this problem in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get a 404 when requesting `/books/acme/`, check to ensure you actually
    have a Publisher with the name 'ACME Publishing'. Generic views have an `allow_empty`
    parameter for this case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic filtering
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common need is to filter down the objects given in a list page by some
    key in the URL. Earlier we hard-coded the publisher's name in the URLconf, but
    what if we wanted to write a view that displayed all the books by some arbitrary
    publisher?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Handily, the `ListView` has a `get_queryset()` method we can override. Previously,
    it has just been returning the value of the `queryset` attribute, but now we can
    add more logic. The key part to making this work is that when class-based views
    are called, various useful things are stored on `self`; as well as the request
    (`self.request`), this includes the positional (`self.args`) and name-based (`self.kwargs`)
    arguments captured according to the URLconf.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，`ListView` 有一个我们可以重写的 `get_queryset()` 方法。以前，它只是返回 `queryset` 属性的值，但现在我们可以添加更多逻辑。使这项工作的关键部分是，当调用基于类的视图时，各种有用的东西都存储在
    `self` 上；除了请求（`self.request`）之外，还包括根据 URLconf 捕获的位置参数（`self.args`）和基于名称的参数（`self.kwargs`）。
- en: 'Here, we have a URLconf with a single captured group:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个带有单个捕获组的 URLconf：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll write the `PublisherBookList` view itself:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 `PublisherBookList` 视图本身：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, it''s quite easy to add more logic to the queryset selection;
    if we wanted, we could use `self.request.user` to filter using the current user,
    or other more complex logic. We can also add the publisher into the context at
    the same time, so we can use it in the template:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，向查询集选择添加更多逻辑非常容易；如果我们想的话，我们可以使用 `self.request.user` 来使用当前用户进行过滤，或者其他更复杂的逻辑。我们还可以同时将发布者添加到上下文中，这样我们可以在模板中使用它：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Performing extra work
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行额外的工作
- en: 'The last common pattern we''ll look at involves doing some extra work before
    or after calling the generic view. Imagine we had a `last_accessed` field on our
    `Author` model that we were using to keep track of the last time anybody looked
    at that author:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下最后一个常见模式，它涉及在调用通用视图之前或之后做一些额外的工作。想象一下，我们在我们的 `Author` 模型上有一个 `last_accessed`
    字段，我们正在使用它来跟踪任何人最后一次查看该作者的时间：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The generic `DetailView` class, of course, wouldn''t know anything about this
    field, but once again we could easily write a custom view to keep that field updated.
    First, we''d need to add an author detail bit in the URLconf to point to a custom
    view:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通用的 `DetailView` 类不会知道这个字段，但我们可以再次轻松地编写一个自定义视图来保持该字段更新。首先，我们需要在 URLconf 中添加一个作者详细信息，指向一个自定义视图：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we''d write our new view-`get_object` is the method that retrieves the
    object-so we simply override it and wrap the call:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会编写我们的新视图 - `get_object` 是检索对象的方法 - 所以我们只需重写它并包装调用：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The URLconf here uses the named group `pk`-this name is the default name that
    `DetailView` uses to find the value of the primary key used to filter the queryset.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 URLconf 使用了命名组 `pk` - 这个名称是 `DetailView` 用来查找用于过滤查询集的主键值的默认名称。
- en: If you want to call the group something else, you can set `pk_url_kwarg` on
    the view. More details can be found in the reference for `DetailView.`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想给组起一个别的名字，你可以在视图上设置 `pk_url_kwarg`。更多细节可以在 `DetailView` 的参考中找到。
- en: What's next?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: In this chapter, we looked at only a couple of the generic views Django ships
    with, but the general ideas presented here apply pretty closely to any generic
    view. [Appendix C](apc.xhtml "Appendix C. Generic View Reference"), *Generic View
    Reference*, covers all the available views in detail, and it's recommended reading
    if you want to get the most out of this powerful feature.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们只看了 Django 预装的一些通用视图，但这里提出的一般思想几乎适用于任何通用视图。附录 C，通用视图参考，详细介绍了所有可用的视图，如果你想充分利用这一强大功能，建议阅读。
- en: This concludes the section of this book devoted to advanced usage of models,
    templates and views. The following chapters cover a range of functions that are
    very common in modern commercial websites. We will start with a subject essential
    to building interactive websites-user management.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本书专门讨论模型、模板和视图的高级用法的部分。接下来的章节涵盖了现代商业网站中非常常见的一系列功能。我们将从构建交互式网站至关重要的主题开始 -
    用户管理。
