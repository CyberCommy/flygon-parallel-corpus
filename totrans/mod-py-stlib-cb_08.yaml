- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Asking for passwords—when asking for a password in a terminal-based software,
    make sure you don't leak it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing passwords—how can passwords be stored without a risk of leaking them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying a file's integrity—how to check that a file transferred over a network
    wasn't corrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify a message's integrity—how to check that a message you are sending to
    another software hasn't been altered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While cryptography is generally perceived as a complex field, there are tasks
    based on it that are part of our everyday lives as software developers, or at
    least they should be, to ensure a minimum level of security in our code base.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter tries to cover recipes for most of the common tasks that you will
    have to face every day that can help to make your software resilient to attacks.
  prefs: []
  type: TYPE_NORMAL
- en: While software written in Python will hardly suffer from exploitation, such
    as buffer overflows (unless there are bugs in the interpreter or compiled libraries
    you rely on), there are still a whole bunch of cases where you might be leaking
    information that must remain undisclosed.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terminal-based programs, it's common to ask for passwords from our users.
    It's usually a bad idea to do so from command options, as on Unix-like systems,
    they will be visible to anyone with access to the shell who is able to run a `ps`
    command to get the list of processes, and to anyone willing to run a `history`
    command to get the list of recently executed commands.
  prefs: []
  type: TYPE_NORMAL
- en: While there are ways to tweak the command arguments to hide them from the list
    of processes, it's always best to ask for passwords interactively so that no trace
    of them is left.
  prefs: []
  type: TYPE_NORMAL
- en: But, asking for them interactively is not enough, unless you also ensure they
    are not displayed while typing, otherwise anyone looking at your screen can grab
    all your passwords.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Luckily, the Python standard library provides an easy way to input passwords
    from a prompt without showing them back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `getpass.getpass` function will use the `termios` library on most systems
    to disable the echoing back of the characters written by the user. To avoid messing
    with the rest of the application input, it will be done within a new file descriptor
    for the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: On systems that do not support this, it will use more basic calls to read characters
    directly from `sys.stdin` without echoing them back.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoiding storing passwords in plain text is a known best practice, as software
    usually only needs to check whether the password provided by the user is correct,
    and the hash of the password can be stored and compared with the hash of the provided
    password. If the two hashes match, the passwords are equal; if they don't, the
    provided password is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Storing passwords is a pretty standard practice, and usually they are stored
    as a hash plus some salt. The salt is a randomly generated string that is joined
    with the password before hashing. Being randomly generated, it ensures that even
    hashes of equal passwords get different results.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library provides a pretty complete set of hashing functions,
    some of them very well-suited to storing passwords.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3 introduced key derivation functions, which are especially convenient
    when storing passwords. Both `pbkdf2` and `scrypt` are provided. While `scrypt`
    is more robust against attacks as it's both memory- and CPU-heavy, it only works
    on systems that provide OpenSSL 1.1+. While `pbkdf2` works on any system, in worst
    cases a Python-provided fallback is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, while from a security point of view `scrypt` would be preferred, we will
    rely on `pbkdf2` due to its wider availability and the fact that it''s been available
    since Python 3.4 (`scrypt` is only available on Python 3.6+):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The two functions can be used to hash the user-provided password for storage
    on disk or into a database (`hash_password`) and to verify the password against
    the stored one when a user tries to log back in (`verify_password`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two functions involved here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hash_password`: Encodes a provided password in a way that is safe to store
    on a database or file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verify_password`: Given an encoded password and a plain text one provided
    by the user, it verifies whether the provided password matches the encoded (and
    thus saved) one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash_password` actually does multiple things; it doesn''t just hash the password.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing it does is generate some random salt that should be added to
    the password. That's just the `sha256` hash of some random bytes read from `os.urandom`.
    It then extracts a string representation of the hashed salt as a set of hexadecimal
    numbers (`hexdigest`).
  prefs: []
  type: TYPE_NORMAL
- en: The salt is then provided to `pbkdf2_hmac` together with the password itself
    to hash the password in a randomized way. As `pbkdf2_hmac` requires bytes as its
    input, the two strings (password and salt) are previously encoded in pure bytes.
    The salt is encoded as plain ASCII as the hexadecimal representation of a hash
    will only contain the 0-9 and A-F characters. While the password is encoded as
    `utf-8`, it could contain any character. (Is there anyone with emojis in their
    passwords?)
  prefs: []
  type: TYPE_NORMAL
- en: The resulting `pbkdf2` is a bunch of bytes, as we want to store it into a database;
    we use `binascii.hexlify` to convert the bunch of bytes into their hexadecimal
    representation in a string format. `hexlify` is a convenient way to convert bytes
    to strings without losing data. It just prints all the bytes as two hexadecimal
    digits, so the resulting data will be twice as big as the original data, but apart
    from that, it's exactly the same as the converted data.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, the function joins together the hash with its salt. As we know that
    the `hexdigest` of a `sha256` hash (the salt) is always 64 characters long. By
    joining them together, we can grab back the salt by reading the first 64 characters
    of the resulting string.
  prefs: []
  type: TYPE_NORMAL
- en: This will permit `verify_password` to verify the password and to verify whether
    the salt used to encode it is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our password, `verify_password` can then be used to verify provided
    passwords against it. So it takes two arguments: the hashed password and the new
    password that should be verified.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing `verify_password` does is extract the salt from the hashed password
    (remember, we placed it as the first 64 characters of the string resulting from
    `hash_password`).
  prefs: []
  type: TYPE_NORMAL
- en: The extracted salt and the password candidate are then provided to `pbkdf2_hmac`
    to compute their hash and then convert it into a string with `binascii.hexlify`.
    If the resulting hash matches with the hash part of the previously stored password
    (the characters after the salt), it means that the two passwords match.
  prefs: []
  type: TYPE_NORMAL
- en: If the resulting hash doesn't match, it means that the provided password is
    wrong. As you can see, it's very important that we made the salt and the password
    available together, because we need it to be able to verify the password, and
    a different salt would result in a different hash and thus we'd never be able
    to verify the password.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a file's integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever downloaded a file from a public network, you might have noticed
    that their URLs are frequently in the form of `http://files.host.com/somefile.tar.gz#md5=3b3f5b2327421800ef00c38ab5ad81a6`.
  prefs: []
  type: TYPE_NORMAL
- en: That's because the download might go wrong and the data you got might be partially
    corrupted. So the URL includes an MD5 hash that you can use to verify that the
    downloaded file is fine through the `md5sum` tool.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies when you download a file from a Python script. If the file
    provided has an MD5 hash for verification, you might want to check whether the
    retrieved file is valid and, in cases where it is not, then you can retry downloading
    it again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within `hashlib`, there are multiple supported hashing algorithms, and probably
    the most widespread one is `md5`, so we can rely on `hashlib` to verify our downloaded
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our file can then be downloaded and verified with `verify_file`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, I might download the `wrapt` distribution from the **Python Package
    Index** (**PyPI**) and I might want to verify that it was correctly downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file name would be `wrapt-1.10.11.tar.gz#sha256=d4d560d479f2c21e1b5443bbd15fe7ec4b37fe7e53d335d3b9b0a7b1226fe3c6`
    on which I could run my `verify_file` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing the function does is open the file in binary mode. As all hash
    functions require bytes and we don't even know the content of the file, reading
    it in binary mode is the most convenient solution.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it checks whether the requested hashing algorithm is available in `hashlib`.
    That's done through `getattr` by trying to grab `hashlib.md5`, `hashlib.sha256`,
    and so on. If the algorithm is not supported, it won't be a valid `hashlib` attribute
    (as it won't exist in the module) and will throw `AttributeError`. To make those
    easier to understand, they are trapped and a new `ValueError` is raised that states
    clearly that the algorithm is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file is opened and the algorithm is verified, an empty hash gets created
    (notice that right after `getattr`, the parenthesis will lead to the creation
    of the returned hash).
  prefs: []
  type: TYPE_NORMAL
- en: We start with an empty one because the file might be very big, and we don't
    want to read the complete file and throw it at the hashing function at once.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we start with an empty hash and we read the file in chunks of 4 KB,
    then each chunk is fed to the hashing algorithm to update the hash.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once we have the hash computed, we grab its representation as hexadecimal
    numbers and compare it to the one provided to the function.
  prefs: []
  type: TYPE_NORMAL
- en: If the two match, the file was properly downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a message's integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When sending messages through a public network or storages accessible to other
    users and systems, we need to know whether the message contains the original content
    or whether it was intercepted and modified by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: That's a typical form of a man-in-the-middle attack and it's something that
    can modify anything in our content, which is stored in a place that other people
    can read too, such as an unencrypted network or a disk on a shared system.
  prefs: []
  type: TYPE_NORMAL
- en: The HMAC algorithm can be used to guarantee that a message wasn't altered from
    its original state and it's frequently used to sign digital documents to ensure
    their integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good scenario for HMAC might be a password-reset link; those links usually
    include a parameter about the user for whom the password should be reset: [http://myapp.com/reset-password?user=myuser@email.net](http://myapp.com/reset-password?user=myuser@email.net).'
  prefs: []
  type: TYPE_NORMAL
- en: But anyone might replace the user argument and reset other people's passwords.
    So, we want to ensure that the link we provide wasn't actually modified, since
    it was sent by attaching an HMAC to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That will result in something such as: [http://myapp.com/reset-password?user=myuser@email.net&signature=8efc6e7161004cfb09d05af69cc0af86bb5edb5e88bd477ba545a9929821f582](http://myapp.com/reset-password?user=myuser@email.net&signature=8efc6e7161004cfb09d05af69cc0af86bb5edb5e88bd477ba545a9929821f582).'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, any attempt at modifying the user will make the signature invalid,
    thus making it impossible to reset other people's passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is deploying REST APIs to authenticate and verify requests.
    Amazon Web Services uses HMAC as an authentication system for its web services.
    When you register, an access key and a secret are provided to you. Any request
    you make must be hashed with HMAC, using the secret key to ensure that you are
    actually the user stated in the request (as you owned its secret key), and the
    request itself wasn't changed in any way because details of it are hashed with
    HMAC too.
  prefs: []
  type: TYPE_NORMAL
- en: The HMAC signature is frequently involved in cases where your software has to
    send messages to itself or receive messages from a verified partner that can own
    a secret key.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library provides an `hmac` module that, combined with the hashing
    functions provided in `hashlib`, can serve the purpose of computing the message''s
    authentication code for any provided message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our functions can then be used to compute a signed message and we can check
    that a signed message wasn''t altered in any way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to change the message field of the signed message, it won''t be
    valid anymore, and only the real message will match the signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our purpose is to ensure that any given message can't be changed in any way
    or it will invalidate the signature attached to the message.
  prefs: []
  type: TYPE_NORMAL
- en: So the `compute_signature` function, given a message and a private secret key,
    returns all the data that the signed message should include when it's sent to
    the receiver. The sent data includes the message itself, the signature, and a
    timestamp. The timestamp is included because, in many cases, it's a good idea
    to ensure that the message is a recent one. If you are receiving an API request
    signed with HMAC or a cookie that you just set, you might want to ensure that
    you are handling a recent message and not one that was sent an hour ago. The timestamp
    can't be tampered with as it's included in the signature together with the message,
    and its presence makes it harder for attackers to guess the secret key, as two
    identical messages will result in having two different signatures, thanks to the
    timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Once the message and the timestamp are known, the `compute_signature` function
    hands them to `hmac.new`, together with the secret key, to compute the signature
    itself. For convenience, the signature is represented as the characters that compose
    the hexadecimal numbers that represent the bytes the signature is made of. This
    ensures that it can be transferred as plain text in HTTP headers or some similar
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our signed message as returned by `compute_signature`, this can
    be stored somewhere and, when loading it back, we can use `verify_signature` to
    check that it wasn't tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: The `verify_signature` function takes the same steps as `compute_signature`.
    The signed message includes the message itself, the timestamp, and the signature.
    So `verify_signature` grabs the message and the timestamp and joins them with
    the secret key to compute the signature. If the computed signature matches the
    signature provided in the signed message, it means the message wasn't altered
    in any way. Otherwise, even a minor change to the message or to the timestamp
    will make the signature invalid.
  prefs: []
  type: TYPE_NORMAL
