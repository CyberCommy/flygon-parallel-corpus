- en: Working with Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container-based software development lifecycle requires easy image packaging
    and reliable ways to distribute containerized applications - these are key aspects
    that the Docker ecosystem has solved. We used Dockerfiles and Docker images in
    the previous chapters. Simply put, a Dockerfile defines build instructions for
    creating a Docker image, an immutable, layered snapshot of container data that
    can be used for instantiating containers. These two concepts allow us to create
    easy and standardized packaging for container applications. In order to provide
    reliable and scalable distribution for Docker images, we can use image registries.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the usage of Docker registries, mainly the
    publicly accessible Docker Hub and private Azure Container Registry, and we will
    also introduce Docker Content Trust – a concept for publishing and managing signed
    collections of content. With this introduction to container image management,
    you will be ready to fully enter the world of Kubernetes on Windows!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing and sharing container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cloud container builders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image tagging and versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring the integrity of the image supply chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop for Windows 2.0.0.3 or later installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure CLI installed. You can find detailed installation instructions in
    [Chapter 2](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*, Managing State in Containers*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation of Docker Desktop for Windows and its detailed requirements
    were covered in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*, Creating
    Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use cloud-hosted registries, you will need your own Azure account.
    If you haven't created an account for the previous chapters, you can find out
    how to obtain a limited free account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from this book's official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Storing and sharing container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you have already pulled your first `hello-world` container with the `docker
    pull hello-world` command and even used the `docker run hello-world` command.
    Under the hood, a few things happen during an image pull:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine connects to the so-called Docker image registry. The registry
    can be specified explicitly, but by default, this is the official public registry,
    called Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Engine authenticates to the registry, if needed. This can be the case
    if you are running a private registry or paid plan for Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The selected `hello-world` image is downloaded as a set of layers identified
    by SHA256 digests. Each layer is unpacked after being downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image is stored locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A similar procedure happens if you execute the `docker run` command and the
    image is not present in the local store. The first time, it will be pulled, and
    later, the locally cached image will be used.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with GitHub or other source repository managed hosting,
    you will find many concepts in image management and image registries similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, intuitively, the image registry is an organized, hierarchical system for
    storing Docker images. The hierarchy of images consists of the following levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registry**: This is the top level of the hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: Registries host multiple repositories, which are storage units
    for images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tag**: A versioning label for a single image. Repositories group multiple
    images identified by the same image name and different tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each image in the registry is identified by an image name and tag, and the
    hierarchy above is reflected in the final image name. The following scheme is
    used: `<registryAddress>/<userName>/<repositoryName>:<tag>` ,for example, `localregistry:5000/ptylenda/test-application:1.0.0`.
    When using Docker commands, some of these parts are optional and if you do not
    provide a value, the default will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<registryAddress>` is the DNS name or IP address (together with the port)
    of the registry that is used for storing the image. If you omit this part, the
    default Docker Hub registry (`docker.io`) will be used. Currently, there is no
    way of changing the default value of the registry address, so if you would like
    to use a custom registry, you have to always provide this part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<userName>` identifies the user or organization that owns the image. In the
    case of Docker Hub, this is a so-called Docker ID. Whether this part is required
    depends on the registry – for Docker Hub, if you do not provide a Docker ID, it
    will assume official images, which are a curated set of Docker repositories that
    are maintained and reviewed by Docker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<repositoryName>` is a unique name within your account. The image name is
    formed as `<registryAddress>/<userName>/<repositoryName>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tag>` is a unique label within a given image repository that is used for
    organizing images, in most cases using a versioning scheme, for example, `1.0.0`.
    If this value is not provided, the default, `latest`, will be used. We will focus
    on tagging and versioning images later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With multi-architecture Docker image variants, it is possible to have different
    images under the same image name and tag for different architectures. The version
    of the image will be automatically chosen based on the architecture of the machine
    running the Docker client. Identifying such images can be performed explicitly
    using an additional `@sha256:<shaTag>` part after the image tag, for example, `docker.io/adamparco/demo:latest@sha256:2b77acdfea5dc5baa489ffab2a0b4a387666d1d526490e31845eb64e3e73ed20`.
    For more details, please go to [https://engineering.docker.com/2019/04/multi-arch-images/](https://engineering.docker.com/2019/04/multi-arch-images/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how Docker images are identified, let's take a look at how
    to push an image to the Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing an image to the Docker registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharing container images using the registry is performed via an image push.
    This process uploads the required image layers to the selected repository in a registry
    and makes it available for pull by other users that have access to a given repository.
    In the case of Docker Hub, which we will use for this demonstration, your repositories
    will be public, unless you have a paid plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pushing images to Docker Hub requires authentication. If you haven''t already
    registered at Docker Hub, please navigate to [https://hub.docker.com/](https://hub.docker.com/) and
    follow the instructions there. After registration, you will need your Docker ID
    and password in order to log in to the services using the `docker login` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout this book, we will be using the `packtpubkubernetesonwindows` Docker
    ID in order to demonstrate our examples. It is recommended that you create your
    own account to be able to fully follow the examples in this book. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create an image that can actually be pushed to the registry.
    We will use the following Dockerfile to create the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile creates an IIS web host image, which serves a minimalistic web
    page that displays This is an IIS demonstration!.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the Dockerfile in your current directory. To build it, issue the following
    `docker build` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that you have to supply your Docker ID as part of the repository
    name in order to be able to push the image to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful build, you are ready to perform an image push to the registry.
    This can be performed with the `docker push` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/df5b226c-5dab-4ad9-b754-623195333b48.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker pushes the image as a set of layers, which also optimizes the push process
    if already known layers are being used. Also, note that in the case of Windows-based
    images, you will see a Skipped foreign layer message. The reason for this is that
    any layers that come from a registry other than Docker Hub, such as **Microsoft
    Container Registry **(**MCR**), will not be pushed to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can also navigate to the Docker Hub web page and check your image details
    – for the example image, you can check it here: [https://cloud.docker.com/repository/docker/packtpubkubernetesonwindows/iis-demo/](https://cloud.docker.com/repository/docker/packtpubkubernetesonwindows/iis-demo/).
    Any user that has access to your repository can now use the `docker pull <dockerId>/iis-demo`
    command in order to use your image.
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully pushed your first image to Docker Hub! Now, let's take
    a look at pushing images to custom image registries.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom local registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to choosing storage for your images, you are not limited to using
    the default Docker Hub. In fact, in most cases, when you are running production
    code, you may want to use a locally hosted Docker Registry, which is an open source,
    highly scalable application for storing and distributing Docker images. You should
    consider this solution in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to distribute Docker images in an isolated network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need strict control where the images are stored and distributed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would like to compliment your CI/CD workflow to enable faster and more scalable
    delivery of images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed information about the deployment of Docker Registry can be found in
    the official documentation: [https://docs.docker.com/registry/deploying/](https://docs.docker.com/registry/deploying/).
  prefs: []
  type: TYPE_NORMAL
- en: For Kubernetes deployments, it is a common practice to host your own Docker
    Registry alongside or even inside the Kubernetes cluster. There are numerous automations
    available for this use case, for example, the official Helm chart for the deployment
    of registries on Kubernetes: [https://github.com/helm/charts/tree/master/stable/docker-registry](https://github.com/helm/charts/tree/master/stable/docker-registry).
  prefs: []
  type: TYPE_NORMAL
- en: In order to use a custom image registry, all you need to do is specify the registry
    address (and port, if needed) in the image name when using pull or push commands,
    for example, `localregistry:5000/ptylenda/test-application:1.0.0`, where `localregistry:5000`
    is the domain name and port of a locally hosted Docker registry. In fact, you
    have already used a custom Docker image registry when you pulled images for your
    demonstration Windows IIS application: `mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`.
    The `mcr.microsoft.com` registry is the MCR, which is the official registry for
    Microsoft Published images. The main difference between other public registries
    and MCR is that it is tightly integrated with Docker Hub and leverages its UI
    for providing a browsable catalog of images. Docker Engine is capable of using
    any system that exposes the Docker Registry HTTP API ([https://docs.docker.com/registry/spec/api/](https://docs.docker.com/registry/spec/api/))
    as a container image registry.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, it is not possible to change the default container image registry
    for Docker Engine. Unless you specify the registry address in the image name,
    the target registry will always be assumed to be `docker.io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from hosting your own local image registry, there are a couple of cloud-based
    alternatives that provide private image registries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container Registry** (**ACR**) [https://azure.microsoft.com/en-in/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/)).
    We will cover this registry in the next section as part of a demonstration of
    how to use cloud hosting for container builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Enterprise and its Docker Trusted Registry ([https://www.docker.com/products/image-registry](https://www.docker.com/products/image-registry)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IBM Cloud Container Registry ([https://www.ibm.com/cloud/container-registry](https://www.ibm.com/cloud/container-registry)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud Container Registry ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/)[).](https://cloud.google.com/container-registry/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RedHat Quay.io and Quay Enterprise ([https://quay.io](https://quay.io)). Quay
    is an interesting solution if you would like to host not only the registry but
    also the build automation and web catalog on-premises, similar to Docker Hub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use Docker Hub to automate Docker
    image builds and how to host your own registry using ACR.
  prefs: []
  type: TYPE_NORMAL
- en: Using cloud container builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features that Docker Hub offers is **automated builds** (**autobuilds**).
    This is especially useful in Continuous Integration and Continuous Deployment
    scenarios where you would like to ensure that each push to your code repository
    results in a build, a publish, and potentially a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Docker Hub does not support Windows images, but this is likely to
    change in the near future. We will demonstrate this usage on a Linux image, but
    all the principles remain the same. For Windows container cloud builds, check
    out the next section about Azure Container Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up automated builds, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a GitHub repository where your application code resides, together with
    a Dockerfile that defines the Docker image for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Docker Hub repository and add an autobuild trigger. This trigger can
    also be added after creating the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customize the build rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, enable autotests. This is a validation feature provided by Docker
    Hub where you can define your test suite in order to test each new image push.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's begin by creating a GitHub repository!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you don''t have a GitHub account, you can create one for free at [https://github.com/join](https://github.com/join).
    In this example, we will create a dedicated public repository called `nginx-demo-index`
    in the `hands-on-kubernetes-on-windows` organization. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to [https://github.com/](https://github.com/) and use the *+* sign
    to create a new repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fcf0245d-dd47-4e5f-a565-c58b2d83161a.png)'
  prefs: []
  type: TYPE_IMG
- en: Hosting an organization is not required; you can just use your own personal
    namespace. The repository is intended to only contain the application source code
    (in our case, just a static `index.html` web page) and the Dockerfile that's required
    to build the image, which aligns with the suggested best practices for Docker
    development.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created the repository, we can push some source code for the
    image. You can find the source code for our minimalistic Docker image for hosting
    a static web page using nginx in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03/02_nginx-demo-index](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03/02_nginx-demo-index).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to clone the newly created repository, in PowerShell, navigate to
    the directory where you would like to have the repository and use the `git clone`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy all the required source files to the repository and perform a push using
    the `git push` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should be able to see the files in the repository when you
    navigate to GitHub web page, for example, [https://github.com/hands-on-kubernetes-on-windows/nginx-demo-index](https://github.com/hands-on-kubernetes-on-windows/nginx-demo-index):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1670f0cc-d298-40ca-af47-8ed0a4bab5cc.png)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to create the actual Docker Hub repository and configure autobuild.
    Let's proceed!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Docker Hub repository with autobuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integrating a Docker Hub repository with autobuild requires connecting your
    GitHub account to your Docker Hub account and creating the repository itself.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://hub.docker.com/](https://hub.docker.com/) and navigate to Account
    Settings. In the Linked Accounts section, click Connect for GitHub provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/26d3b045-45d7-43a1-8c3a-9297dcd220f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Authorize Docker Hub Builder to access your repositories. At this point, if
    you need to, you can also grant access to any organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the accounts have been connected, open [https://hub.docker.com/](https://hub.docker.com/) again
    and click the Create Repository section''s *+* button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f600ce6d-28b1-4d5b-bee2-372a87a5a500.png)'
  prefs: []
  type: TYPE_IMG
- en: Fill in all the required details. In our case, the name of our repository will
    be `packtpubkubernetesonwindows/nginx-demo-index`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Build Settings, choose the GitHub icon and select the GitHub repository that
    you have just created, as shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the build settings by clicking Click here to customize the build settings
    in order to understand what the default configuration is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b6f2033b-4472-45fc-9284-c9a8d790f6e2.png)'
  prefs: []
  type: TYPE_IMG
- en: The default settings are suitable for our image as we would like to trigger
    the build whenever new code is pushed to the master branch. A Dockerfile with
    the name Dockerfile in the root of your GitHub repository should be used for building
    images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Create & Build to save and immediately start a build based on the current
    code in the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Recent Builds, you should see a Pending build of your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/41d65d6b-3606-4f04-8e68-7201701450f4.png)'
  prefs: []
  type: TYPE_IMG
- en: After a few minutes, the build should finish and the `packtpubkubernetesonwindows/nginx-demo-index:latest`
    image should be available. You can verify this by pulling the image using the `docker
    pull packtpubkubernetesonwindows/nginx-demo-index:latest` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's take a look at how to easily trigger Docker image builds with a new
    code commit.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering the Docker Hub autobuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the autobuild setup created in the previous section, triggering a new
    Docker image build is as simple as committing new code to your GitHub repository.
    In order to do that, you have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduce a change to the source code for the image on GitHub; for example,
    modify the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit and push the code change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Builds tab for this image repository on Docker Hub, you should almost
    immediately see that a new image build has been triggered (source commit: [https://github.com/hands-on-kubernetes-on-windows/nginx-demo-index/tree/5ee600041912cdba3c82da5331542f48701f0f28](https://github.com/hands-on-kubernetes-on-windows/nginx-demo-index/tree/5ee600041912cdba3c82da5331542f48701f0f28)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b5e4b8e7-dfa9-426c-ba4a-81a4795a8514.png)'
  prefs: []
  type: TYPE_IMG
- en: If your build fails, you can always inspect the Docker build logs in the build
    details and Build logs tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the build succeeds, verify your image by running a new container on your
    Windows machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The image will be automatically pulled from the Docker Hub repository. Navigate
    to `http://localhost:8080` in your web browser. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1fdd74ee-dd50-4340-99f3-d08b0c09d6b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations – you have successfully created and triggered a Docker image
    autobuild on Docker Hub! In the next section, you will learn how to create a similar
    setup for Windows-based images using Azure Container Registry.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Azure Container Registry** (**ACR**) is a fully managed private Docker registry
    provided by Azure Cloud. In this section, we will create a new instance of ACR
    using the Azure CLI. You will learn how to achieve similar build automation as
    provided by Docker Hub but with the possibility of building Windows images and
    using a private registry.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find detailed installation instructions for the Azure CLI in [Chapter
    2](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*, Managing State in Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an Azure Container Registry instance, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you are logged in to the Azure CLI by using the `az login` command
    in PowerShell. Proceed by creating a dedicated resource group for your ACR instance.
    In this example, we will use the `acr-resource-group` resource group and `westeurope`
    as the Azure location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the PowerShell script available in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter03/03_CreateAzureContainerRegistry.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter03/03_CreateAzureContainerRegistry.ps1).
    Remember to provide a globally unique ACR name in order to be able to create the
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a basic-tier ACR instance with a globally unique name (for demonstration
    purposes, we have provided `handsonkubernetesonwinregistry`, but you have to provide
    your own unique name as it will be a part of the registry''s DNS name):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in other service tiers of Azure Container Registry, please
    refer to the official documentation: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-skus](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-skus).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be provided with detailed information regarding your newly created
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important information is `"loginServer": "handsonkubernetesonwinregistry.azurecr.io"`,
    which will be used for pushing and pulling Docker images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last step is to log in to the registry so that you can use the
    registry in the Docker CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With ACR set up, we are ready to build a Docker image using ACR in the cloud
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image using Azure Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we will use a simple Windows IIS image that hosts
    a static HTML web page. You can find the Docker image source in this book''s GitHub
    repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03/04_iis-demo-index](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03/04_iis-demo-index).
    To build the image in ACR, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository with the image source code and navigate to the `Chapter03/04_iis-demo-index`
    directory in PowerShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the `az acr build` command in order to begin the Docker image build
    in the cloud environment (remember to provide the Docker build context directory,
    which in this example is denoted by the *dot* for the current directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `az acr build` command starts an ACR quick task. This uploads the Docker
    build context to the cloud and runs the build process remotely. After a few minutes,
    the build process should finish. You can expect output similar to the local `docker
    build` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can verify the image by running a container on your local machine
    and pulling the image from ACR. You need to use the full DNS name for the registry
    (in this example, this is `handsonkubernetesonwinregistry.azurecr.io`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:8080` in a web browser and verify that the container
    is running as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/eef79d64-be77-413c-a3c0-d383ae9b2c21.png)'
  prefs: []
  type: TYPE_IMG
- en: You have successfully executed your ACR build quick task! Now, we can start
    automating the ACR build trigger for a GitHub repository code push in a similar
    fashion to how we would using Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic builds for Azure Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Container Registry offers similar functionality to Docker Hub for the
    automation of Docker image builds on code push. The pipeline is highly customizable
    and can support building multiple container images at once, but in this example,
    we will focus on automating a single image build on the GitHub repository code
    push.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more advanced multi-step and multi-container scenarios, check out the official
    documentation: [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-tutorial-multistep-task](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-tutorial-multistep-task).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integrating ACR and GitHub can be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GitHub repository and push the Docker image source code. In this
    example, we will use source code from [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03/04_iis-demo-index](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter03/04_iis-demo-index),
    which will be pushed to a new GitHub repository, that is, [https://github.com/hands-on-kubernetes-on-windows/iis-demo-index](https://github.com/hands-on-kubernetes-on-windows/iis-demo-index).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a GitHub **Personal Access Token** (**PAT**) in order to access the
    repository in ACR. Navigate to [https://github.com/settings/tokens/new](https://github.com/settings/tokens/new).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a PAT description and choose the repo:status and public_repo scopes (for
    private repositories, you need to use a full repo scope):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/972e23d8-a90d-4160-b5e2-08abf11d5f1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Click the Generate token button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be provided with a PAT value. Copy the token to a secure location as
    you will need it to set up integration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s create an ACR task called `iis-demo-index-task`. This will be triggered
    automatically when code is pushed to [https://github.com/hands-on-kubernetes-on-windows/iis-demo-index](https://github.com/hands-on-kubernetes-on-windows/iis-demo-index).
    The required parameters are similar to the build configuration for Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run into an `az acr task create: ''utputformat'' is not a valid value
    for ''--output''. See ''az acr task create --help''.` error being returned by
    the Azure CLI, ensure that you are escaping/quoting curly brackets for PowerShell
    properly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your ACR task definition using the `az acr task run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the source code for your Docker image, introduce a change and commit and
    push it to the GitHub repository. For example, modify the static text so that
    it reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the ACR task logs to verify that the task was indeed triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output similar to the following, which indicates that a new
    task instance was triggered by the push:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba48c49b-f339-4610-907d-fd4037c0eb77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the task is finished, pull the image tagged with Run ID (in this case,
    this is cb5). You can also use the `latest` tag, but this requires removing a
    locally cached image using the `docker rmi` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new container using the `handsonkubernetesonwinregistry.azurecr.io/iis-demo-index:cb5`
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:8080` in a web browser and verify that the container
    is running as expected. Also, verify that the static HTML page contains changes
    that were introduced in the code push:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/bb195a4c-6ff0-4d10-b036-7af9ff898fbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Other cloud service providers have similar offerings for setting up Docker image
    registries and build pipelines. If you are interested in Google Cloud Platform
    services, please check out GCP Cloud Build: [https://cloud.google.com/cloud-build/docs/quickstart-docker](https://cloud.google.com/cloud-build/docs/quickstart-docker).
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully set up your Docker image build pipeline using GitHub and
    Azure Container Registry – congratulations! Now, we will take a quick look at
    best practices for image tagging and versioning.
  prefs: []
  type: TYPE_NORMAL
- en: Image tagging and versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker images use tags in order to provide different versions of the same image
    in the repository – each image tag corresponds to a given Docker image ID. Specifying
    tags for Docker images is often performed during an image build, but you can also
    add tags explicitly using the `docker tag` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we pulled the `latest` image tag (as it was not specified
    explicitly) of the .NET Core SDK and then tagged the image with the `mydotnetsdk:v1`
    and `mydotnetsdk:v2` tags in the local image cache. Now, it is possible to use
    these tags while performing operations on your local machine, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the `latest` tag, which is often used when working with
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Using the latest tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the Docker CLI assumes a special tag called `latest`. This means
    that if you perform the `docker pull applicationimage` command or the `docker
    run -it applicationimage` command, or use `FROM applicationimage` in your Dockerfile,
    the `applicationimage:latest` tag will be used. Similarly, when you execute `docker
    build -t applicationimage .`, the resulting Docker image will be tagged with the `latest`
    tag and each subsequent build will produce a new version of `applicationimage:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand that `latest` behaves just like any other Docker
    image tag. It can be seen as a default value that is always used by Docker whenever
    no tag has been provided by user. This has some consequences that may cause confusion,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: During an image build, if you specify your tag for the image, the latest tag
    will not be added. This means that if you push `applicationimage:v1` to the registry,
    it doesn't mean that `applicationimage:latest` will be updated. You have to perform
    it explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the image owner pushes a new Docker image version to the repository and
    it is tagged again with the `latest` tag, this doesn't mean that your locally
    cached image will be updated and used during `docker build`. You have to tell
    the Docker CLI to attempt to pull a newer version of the image by using the `--pull`
    argument for `docker build`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `latest` tag for the Dockerfile's `FROM` instruction can lead to different
    images being built in different points in time, which is generally not desirable.
    For example, you may be building your image using the `mcr.microsoft.com/dotnet/core/sdk` image
    at a point in time when `latest` points to version 2.2 of the SDK, but after a
    few months, building the same Dockerfile will result in version 3.0 being used
    as the base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general best practice (this is also the same for Kubernetes) is to avoid
    deploying production containers using the `latest` tag and use the `latest` tag
    just for development scenarios and ease of use for your local environment. Similarly,
    to ensure that your Docker images are predictable and self-descriptive, you should
    avoid using base images with the `latest` tag in a Dockerfile – use a specific
    tag instead.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to efficiently manage the versioning and tagging of Docker images,
    you can use** Semantic Versioning** (**Semver**) as a general strategy. This versioning
    scheme is widely adopted among image distributors and helps consumers understand
    how your image evolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, Semver suggests the scheme of using three numbers – major, minor,
    and patch – separated with dots, `<major>.<minor>.<patch>`, where each number
    is incremented as needed. As an example, 2.1.5 means that the major version of
    the image is 2, the minor version is 1, and the patch version is currently 5\.
    The meaning of these release numbers and incrementation rules are similar to what
    you would expect for versioning non-containerized applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: Increment if you are introducing features that break compatibility
    or introduce other breaking changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: Increment if you are introducing features that are fully compatible
    with previous releases. Consumers do not need to upgrade usages of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: Increment if you are publishing bug fixes or patches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details regarding Semver as a general concept can be found here: [https://semver.org/](https://semver.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practices for using Semver when building/pushing Docker images can
    be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When building a new version of your image, always create a new patch tag (for
    example, 2.1.5).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always overwrite existing major and minor tags (for example, 2 and 2.1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never overwrite patch tags. This ensures that image consumers who would like
    to use a specific version of your application can be sure that it does not change
    over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always overwrite the existing `latest` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following set of commands shows an example of building and tagging a new
    version of the `applicationimage` Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may also introduce additional tags that add correlation to your build system
    IDs or git commit SHA-1 hash, which was used for the image build.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring the integrity of the image supply chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providing content trust of the image supply chain is one of the most important,
    but often neglected, topics in managing Docker images. In any distributed system
    that communicates and transfers data over an untrusted medium (such as the internet),
    it is crucial to provide a means of content trust – a way of verifying both the
    source (publisher) and the integrity of data entering the system. For Docker,
    this is especially true for pushing and pulling images (data), which is performed
    by Docker Engine.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker ecosystem describes the concept of **Docker Content Trust** (**DCT**),
    which provides a means of verifying the digital signatures of data being transferred
    between the Docker Engine and the Docker Registry. This verification allows the
    publishers to sign their images and the consumer (Docker Engine) to verify the
    signatures to ensure the integrity and source of the images.
  prefs: []
  type: TYPE_NORMAL
- en: In the Docker CLI, it is possible to sign an image using the `docker trust`
    command, which is built on top of Docker Notary. This is a tool that's used for
    publishing and managing trusted collections of content. Signing images requires
    a Docker Registry with an associated Notary server, for example, Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about content trust for a private Azure Container Registry, please
    refer to [https://docs.microsoft.com/en-us/azure/container-registry/container-registry-content-trust](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-content-trust).
  prefs: []
  type: TYPE_NORMAL
- en: Signing an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, we will sign one of the Docker images we have built and pushed
    to Docker Hub in this chapter, that is, `packtpubkubernetesonwindows/iis-demo-index`.
    To follow along, you will need to perform the operations on your own image repository, `<dockerId>/iis-demo-index`.
    Signing can be performed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a delegation key pair. Locally, this can be done using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You will be asked for a passphrase for the private key. Choose a safe password
    and continue. The private delegation key will be stored in `~/.docker/trust/private` by
    default (also on Windows) and the public delegation key will be saved in the current
    working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the delegation public key to the Notary server (for Docker Hub, it is `notary.docker.io`).
    Loading the key is performed for a particular image repository, which in Notary
    is identified by a **Globally Unique Name** (**GUN**). For Docker Hub, they have
    the form of `docker.io/<dockerId>/<repository>`. Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you are performing the delegation for your repository for the first time,
    you will be automatically asked for initiation using the local Notary canonical
    root key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tag the image so that it has a specific tag that can be signed, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the private delegation key to sign the new tag and push it to Docker Hub,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be performed by `docker push`, providing that you have
    set the `DOCKER_CONTENT_TRUST` environment variable in PowerShell before pushing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can inspect the remote trust data for the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's try running a container with DCT enabled on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling DCT for the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to enforce DCT when using the Docker CLI for `push`, `build`, `create`,
    `pull`, and `run`, you have to set the `DOCKER_CONTENT_TRUST` environment variable
    to `1`. By default, DCT is disabled for Docker client. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `DOCKER_CONTENT_TRUST` environment variable in the current PowerShell
    session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a new container using the signed image that we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the container starts without any problem. Now, try creating
    a new container using the `latest` tag, which was not signed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This short scenario shows how DCT can be used to ensure the integrity and source
    of the image that's used for container creation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how the Docker ecosystem provides an infrastructure
    for storing and sharing container images using Docker Registry. The concepts of
    the image registry and automated cloud builds have been demonstrated using a public
    Docker Hub and a private Azure Container Registry, which you set up from scratch
    using the Azure CLI. You also learned about the best practices for tagging and
    versioning images using the semantic versioning scheme. Finally, you were introduced
    to ensuring image integrity using **Docker Content Trust** (**DCT**).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to perform our first deep dive into the Kubernetes
    ecosystem in order to understand some key concepts and how they currently fit
    Windows containers support.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Docker Registry and how does it relate to Docker Hub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an image tag?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the standard image repository naming scheme for Docker Hub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Azure Container Registry and how does it differ from Docker Hub?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `latest` tag and when is it recommended to use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we version (tag) images using semantic versioning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you use Docker Content Trust?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the answers to these questions in the *Assessments* section of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information concerning managing Docker container images and image
    registries, please refer to the following Packt books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker on Windows: From 101 to production with Docker on Windows* ([https://www.packtpub.com/virtualization-and-cloud/docker-windows-second-edition](https://www.packtpub.com/virtualization-and-cloud/docker-windows-second-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learn Docker – Fundamentals of Docker 18.x* ([https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x](https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you would like to know more about Azure Container Registry and how it fits
    into the Azure ecosystem, take a look at the following Packt book:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Azure for Architects – Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/azure-architects-second-edition](https://www.packtpub.com/virtualization-and-cloud/azure-architects-second-edition))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also refer to the official Docker documentation, which gives a good
    overview of Docker Hub ([https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/))
    and the open source Docker Registry ([https://docs.docker.com/registry/](https://docs.docker.com/registry/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
