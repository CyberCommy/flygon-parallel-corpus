- en: '*Chapter 4*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you''ll be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the concept of classes and objects in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the four underlying principles of object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create simple classes and access them using objects in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement inheritance in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with method overloading and overriding in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and use annotations in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we've looked at the basics of Java and how to use simple constructs
    such as **conditional** statements and looping statements, and how methods are
    implemented in Java. These basic ideas are very important to understand and are
    useful when building simple programs. However, to build and maintain large and
    complex programs, the basic types and constructs do not suffice. What makes Java
    really powerful is the fact that it is an object-oriented programming language.
    It allows you to build and integrate complex programs effectively, while maintaining
    a consistent structure, making it easy to scale, maintain, and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, we will introduce a programming paradigm called object-oriented
    programming (OOP), which lies at the core of Java. We will have a look at how
    OOP is done in Java and how you can implement it to design better programs.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this lesson with a definition of OOP and the principles underlying
    it, will look at OOP constructs called **classes** and **objects**, and will conclude
    the lesson by looking at a concept called **inheritance**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write two simple OOP applications in Java: one to represent people
    who are normally found in a university, such as students, lecturers, and the staff,
    and the other to represent domestic animals in a farm. Let''s get started!'
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OOP is governed by four main principles, as follows. Throughout the rest of
    this lesson, we will delve further into each of these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance**: We will learn how we can reuse code by using hierarchies of
    classes and inheriting behavior from derived classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: We will also look at how we can hide the implementation
    details from the outside world while providing a consistent interface to communicate
    with our objects through methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction**: We will look at how we can focus on the important details
    of an object and ignore the other details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: We will also have a look at how we can define abstract behaviors
    and let other classes provide implementations for these behaviors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A paradigm in programming is a style of writing programs. Different languages
    support different paradigms. A language can support more than one paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object-oriented programming, often referred to as OOP, is a style of programming
    in which we deal with objects. Objects are entities that have properties to hold
    their data and methods to manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's break this down into simpler terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In OOP, we primarily deal with objects and classes. An object is a representation
    of a real-world item. An example of an object is your car or yourself. An object
    has properties associated with it and actions it can perform. For example, your
    car has wheels, doors, an engine, and gears, which are all properties, and it
    can perform actions such as speeding, braking, and stopping, which are all called
    methods. The following diagram is an illustration of the properties and methods
    you have, as a person. Properties can sometimes be referred to as **fields**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Representation of objects relating to humans](img/C09581_Figure_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Representation of objects relating to humans'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In OOP, we define classes as blueprints of our items and objects as instances
    of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a class is `Person` and an example of an object/instance of `Person`
    is a student or lecturer. These are specific example objects that belong to the
    `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 Representation of an instance of a class](img/C09581_Figure_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 Representation of an instance of a class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding diagram, the `Person` class is used to represent all people,
    regardless of their gender, age, or height. From this class, we can create specific
    examples of people, as shown in the boxes inside the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we mainly deal with classes and objects, so it is very important that
    you understand the difference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Java, everything except primitive data types are objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the format of a class definition in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A class definition in Java consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`, `private`, `protected`, or have no modifier. A `public` class is
    accessible from other classes in other packages. A `private` class is only accessible
    from within the class it is declared. A `protected` class member is accessible
    within all classes in the same package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class name**: The name should begin with an initial letter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**: The class body is surrounded by braces, { }. This is where we define
    the properties and methods of the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming Conventions for Class Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Naming conventions for classes in Java are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Class names should use camelCase. That is, the first word should start with
    a capital letter and all of the inner words should have a capitalized first word,
    for example, `Cat`, `CatOwner`, and `House`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names should be nouns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names should be descriptive and should not be initials, unless they are
    widely known.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of how the `Person` class would be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The modifier is public, meaning that the class can be accessed from other Java
    packages. The class name is `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more robust example of the `Person` class with a few properties and
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These properties are used to hold the state of the object. That is, `age` holds
    the age of the current person, which can be different from that of the next person.
    `name` is used to hold the name of the current person, which will also be different
    from the next person. They answer the question: who is this person?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods are used to hold the logic of the class. That is, they answer the
    question: what can this person do? Methods can be private, public, or protected.'
  prefs: []
  type: TYPE_NORMAL
- en: The operations in the methods can be as complex as your application needs. You
    can even call methods from other methods, as well as adding parameters to those
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Working with Classes and Objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ IDEA and create a file called `Person.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a public class with the name `Person` with three properties, that is,
    `age`, `height`, and `name`. The `age` and `height` properties will hold integer
    values, whereas the `name` property will hold a string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define three methods, that is, `walk()`, `sleep()`, and `takeShower()`. Write
    the print statements for each so that you can print out the text to the console
    when they are called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pass the `speed` parameter to the `walk()` method. If the `speed` is above
    10, we print the output to the console, otherwise we don''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `Person` class, we can create objects for it using the
    `new` keyword. In the following code, we have created three objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `me` variable is now an object of the `Person` class. It represents a specific
    type of person, me.
  prefs: []
  type: TYPE_NORMAL
- en: With this object, we can do anything we wish, such as calling the `walk()` method,
    calling the `sleep()` method, and much more. We can do this as long as there are
    methods in the class. Later, we will look at how we can add all of this behavior
    to a class. This code will not have any output since we do not have the **main**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12: Using the Person Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To call the member functions of a class, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in IntelliJ called `PersonTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `PersonTest` class, create the `main` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `main` method, create three objects of the `Person` class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `walk()` method for the first object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the class and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same using the `myNeighbour` and `lecturer` objects instead of `me`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program again and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a new class called `PersonTest` and inside it created
    three objects of the `Person` class. We then called the methods of the `me` object.
    From this program, it is evident that the `Person` class is a blueprint from which
    we can create as many objects as we wish. We can manipulate each of these objects
    separately as they are completely different and independent. We can pass these
    objects around as if they were just like any other variables, and can even pass
    them to other objects as parameters. This is the flexibility of object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We didn't call `me.takeShower()` because this method is declared private in
    the `Person` class. Private methods cannot be called outside their class.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to create an object of a class, we need a constructor. A constructor
    is called when you want to create an object of a class. When we create a class
    without a constructor, Java creates an empty default constructor for us that takes
    no parameters. If a class is created without a constructor, we can still instantiate
    it with the default constructor. A good example of this is the `Person` class
    that we used previously. When we wanted a new object of the `Person` class, we
    wrote the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor is `Person()`, and it returns a new instance of the
    `Person` class. We then assign this returned instance to our variable, `me`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A constructor is just like any other method, except for a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor has the same name as the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor can be `public` or `private`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor doesn't return anything, even `void`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Let''s create a simple constructor for our `Person`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This constructor takes one argument, an integer called `myAge`, and assigns
    its value to the `age` property in the class. Remember that the constructor implicitly
    returns an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the constructor to create the `me` object again, this time passing
    `age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The this Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `Person` class, we saw the following line in our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, as we saw earlier, we are setting the `age` variable in our current
    object to the new value, `myAge`, which is passed in as a parameter. Sometimes,
    we wish to be explicit about the object we are referring to. When we want to refer
    to the properties in the current object we are dealing with, we use the `this`
    keyword. As an example, we could rewrite the preceding line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this new line, `this.age` is used to refer to the age property in the current
    object we are dealing with. `this` is used to access the current object's instance
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the preceding line, we are setting the current object's `age`
    to the value that's passed into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to referring to the current object, `this` can also be used to invoke
    a class' other constructors if you have more than one constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Person` class, we will create a second constructor that takes no parameter.
    If this constructor is invoked, it invokes the other constructor we created with
    a default value of 28:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the call of `Person me = new Person()` is made, the second constructor
    will call the first constructor with `myAge` set to 28\. The first constructor
    will then set the current object's `age` to 28\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12: Creating a Simple Class in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scenario: Let''s imagine we want to create a program for an animal farm. In
    this program, we need to keep track of all the animals that are on the farm. To
    start with, we need a way to represent the animals. We will create an animal class
    to represent a single animal and then create instances of this class to represent
    the specific animals themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective: We will create a Java class to represent animals and create instances
    of that class. By the end of this activity, we should have a simple `Animal` class
    and a few instances of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aim: To understand how to create classes and objects in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Follow these steps to complete the activity
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in the IDE and name it `Animals`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project, create a new file called `Animal.java` under the **src/** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `Animal` and add the instance variables `legs`, `ears`,
    `eyes`, `family`, and `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a constructor with no parameters and initialize `legs` to 4, `ears` to
    2, and `eyes` to 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define another parameterized constructor which takes the `legs`, `ears`, and
    `eyes` as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add getters and setters for `name` and `family`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another file called `Animals.java`, define the `main` method, and create
    two objects of the `Animal` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another animal with two `legs`, two `ears`, and two `eyes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To set the animals' `name` and `family`, we will use the getters and setters
    we created in the class and print names of the animals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Output of the Animal class](img/C09581_Figure_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Output of the Animal class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 314.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13: Writing a Calculator Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this activity you'll create a Calculator class that, given two operands
    and one operator, can execute the operation and return the result. This class
    will have one operate method which will execute the operation using the two operands.
    The operands and the operator will be fields in the class, set through the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: With the Calculator class ready, write an application that executes some sample
    operations and prints the results to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class `Calculator` with three fields: `double` `operand1`, `double`
    `operand2` and `String` `operator`. Add a constructor that sets all three fields.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this class, add an `operate` method that will check what operator is ("+",
    "-", "x" or "/") and executes the correct operation, returning the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `main` method to this class so that you can write a few sample cases and
    print the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 318.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will have a look at another important principle of OOP,
    called inheritance. Inheritance in OOP has the same meaning as it has in English.
    Let's look at an example by using our family trees. Our parents inherit from our
    grandparents. We then inherit from our parents, and finally, our children inherit,
    or will inherit, from us. Similarly, a class can inherit the properties of another
    class. These properties include methods and fields. Then, another class can still
    inherit from it, and so on. This forms what we call an **inheritance hierarchy**.
  prefs: []
  type: TYPE_NORMAL
- en: The class being inherited from is called the **superclass** or the **base**
    class, and the class that is inheriting is called the **subclass** or the **derived**
    class. In Java, a class can only inherit from one superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An example of inheritance is a management hierarchy in a company or in the
    government:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Level Inheritance**: In single level inheritance, a class inherits
    from only one other class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.5: Representation of single level inheritance](img/C09581_Figure_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Representation of single level inheritance'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Multi-level inheritance**: In multi-level inheritance, a class can inherit
    from another class that also inherits from another class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.6: Representation of multi-level inheritance](img/C09581_Figure_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Representation of multi-level inheritance'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Multiple inheritance**: Here, a class can inherit from more than one class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.7: Representation of multiple inheritance](img/C09581_Figure_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Representation of multiple inheritance'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Multiple inheritance is not directly supported in Java, but can be achieved
    by using **interfaces**, which will be covered in the next lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of Inheritance in OOP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's go back to our `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: It is clear that there are common properties and actions that all people support,
    despite their gender or race. For example, in terms of properties, everyone has
    a name, and everyone has an age, height, and weight. With regard to common actions,
    all people sleep, all people eat, and all people breathe, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing code for all of these properties and methods in all of our
    `Person` classes, we can define all of these common properties and actions in
    one class and let the other Person classes inherit from this class. That way,
    we won't have to rewrite the properties and methods in these subclasses. Therefore,
    inheritance allows us to write more concise code by reusing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a class to inherit from another class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We use the `extends` keyword to denote inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted our `Student` class to extend the `Person` class,
    we would declare it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this `Student` class, we have access to the public properties and methods
    that we defined earlier in the `Person` class. When we create an instance of this
    `Student` class, we automatically have access to the methods we defined in the
    `Person` class earlier, such as `walk()` and `sleep()`. We don't need to recreate
    those methods anymore as our `Student` class is now a subclass of the `Person`
    class. We, however, don't have access to private methods such as `takeShower()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Please note that a subclass only has access to the public properties and methods
    in its superclass. If a property or method is declared as private in the superclass,
    we cannot access it from the subclass. By default, the properties we declared
    are only accessible from classes in the same package, unless we specifically put
    the `public` modifier before them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Person` class, let''s define some common properties and methods that
    all people have. Then, we will inherit these properties from this class to create
    other classes, such as `Student` and `Lecturer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined four properties, two constructors, and seven methods.
    Can you explain what each method does? The methods are fairly simple for now so
    that we can focus on the core concepts of inheritance. We have also modified the
    constructors to take three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `Student` class that inherits from this `Person` class, create
    an object of the class, and set the name of the student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a new `Student` class that inherits from the `Person` class.
    We have also created a new instance of the `Student` class and set its name. Note
    that we didn''t redefine the `setName()` method in the `Student` class because
    it is already defined in the `Person` class. We can also call other methods on
    our `student` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we did not create these methods in the `Student` class as they are
    already defined in the `Person` class from which the `Student` class inherits.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Inheritance in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write down the expected output of the preceding program. Explain the output
    by looking at the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a `Lecturer` class that inherits from the same `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Please note how Inheritance has helped us reduce the amount of code we write
    by reusing the same `Person` class. Without inheritance, we would have had to
    repeat the same methods and properties in all of our classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14: Creating a Calculator Using Inheritance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous activity, you created a `Calculator` class that contained all
    the known operations in the same class. This makes this class harder to extend
    when you think about adding new operations. The operator method would grow indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this better, you will use OOP practices to split the operator logic
    out of this class into its own class. In this activity you''ll create a class
    Operator that defaults to the sum operation and then three other classes that
    implement the other three operations: subtraction, multiplication and division.
    This Operator class has a `matches` method that, given a String returns a boolean
    that is true if the String represents that operator or false if not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the operation logic in their own classes, write a new class called `CalculatorWithFixedOperators`
    with three fields: `double` `operand1`, `double` `operand2` and `operator` of
    type `Operator`. This class will have the same constructor that the previous calculator,
    but instead of storing the operator as a String, it will check for the operator
    classes using the matches method to determine the correct operator.'
  prefs: []
  type: TYPE_NORMAL
- en: As the previous calculator, this calculator also has a method operate that returns
    a double, but instead of any login in there, it delegates the current operator,
    determined in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class `Operator` that has one String field initialized in the constructor
    that represents the operator. This class should have a default constructor that
    represents the default operator, which is `sum`. The operator class should also
    have a method called operate that receives two doubles and return the result of
    the operator as a double. The default operation is sum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create three other classes: `Subtraction`, `Multiplication` and `Division`.
    They extend from Operator and override the `operate` method with each operation
    that they represent. They also need a no-argument constructor that calls super
    passing the operator that they represent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class, called `CalculatorWithFixedOperators`. This class will
    contain four fields that are constants (finals) and represent the four possible
    operations. It should also have three other fields: `operand1` and `operator2`
    of type double and `operator` of type `Operator`. These other three fields will
    be initialized in the constructor that will receive the operands and the operator
    as a String. Using the match methods of the possible operators, determine which
    one will be set as the operator fields.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the previous `Calculator` class, this one will also have an `operate` method,
    but it will only delegate to the `operator` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last, write a `main` method that calls the new calculator a few times, printing
    the results of the operation for each time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewriting the calculator to use more classes seems more complex than the initial
    code. But it abstracts some important behavior which opens some possibilities
    that will be explored in future activities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 319.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next principle of OOP we will discuss is called overloading. Overloading
    is a powerful concept in OOP that allows us to reuse method names as long as they
    have different signatures. A **method signature** is the method name, its parameters,
    and the order of the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Representation of a method signature](img/C09581_Figure_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Representation of a method signature'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding is an example of a method that withdraws funds from a given bank
    name. The method returns a double and accepts a String parameter. The method signature
    here is the name of the `getMyFundsFromBank()` method and the String parameter
    `bankName`. The signature doesn't include the return type of the method, only
    the name and the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: With overloading, we are able to define more than one method with the same method
    names but different parameters. This can be useful in defining methods that do
    the same thing but take different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a class called `Sum` with three overloaded methods that add the
    parameters that are passed and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `sum()` method is overloaded to take different parameters
    and return the sum. The method name is the same, but each of the methods takes
    a different set of parameters. This difference in the method signatures allows
    us to use the same name as many times as we wish.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering about the benefits overloading brings to OOP. Imagine
    a scenario where we wouldn't be able to reuse a certain method name more than
    once, as in certain languages, such as C. For us to be able to accept different
    sets of parameters, we would need to come up with six different method names.
    Coming up with six different names for methods that essentially do the same thing
    is tiresome and painful when dealing with large programs. Overloading saves us
    from such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `Student` class and create two overloaded methods. In
    the first method, we will print a string to print "Going to class...", regardless
    of which day of the week it is. In the second method, we will pass the day of
    the week and check whether it is the weekend. If it is the weekend, we will print
    out a different string in comparison to the rest of the week. Here is how we will
    implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Lecturer` class we created and add two overloaded methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`teachClass()` prints out "Teaching a random class"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`teachClass(String className)` prints out "`Teaching` " + `className`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can overload the main method in a class, but once the program starts up,
    the JVM will only call `main(String[] args)`. We can call our overloaded `main`
    method from this `main` method. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `main` method is overloaded three times. However, when
    we run our program, the main method whose signature is `main(String[] args)` will
    be called. From anywhere in our code, we can then freely call the other main methods.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like methods, constructors can be overloaded too. When the same constructors
    are declared with different parameters in the same class, this is known as **constructor
    overloading**. The compiler differentiates which constructor is to be called,
    depending on the number of parameters and their data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our discussion on constructors, we created a second constructor for our
    `Person` class that takes `age`, `height`, and `weight` as parameters. We can
    have this constructor in the same class as the constructor that takes in no parameters.
    This is because the two constructors have a different signature and can hence
    be used side by side. Let''s look at how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The two constructors have same name (the class name) but take different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Add a third constructor that takes `age`, `height`, `weight`, and `name`. Inside
    the constructor, set all the class variables to the passed parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphism and Overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next principle of OOP we will cover is called polymorphism. The term "**polymorphism**"
    stems from biology in that an organism can take many forms and stages. This term
    is also used in OOP in that sub-classes can define their unique behaviors yet
    still share some functionalities with their parent classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's illustrate this with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Person` example, we had a method, `walk`. In our `Student` class, which
    inherits from the `Person` class, we will redefine the same `walk` method, but
    now walking to class instead of just walking. In our `Lecturer` class, we will
    also redefine the same `walk` method and this time walk to the staff room instead
    of walking to class. This method must have the same signature and return type
    as the `walk` method in the superclass for this to be considered polymorphic.
    Here is what the implementation looks like in our `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When we call `student.walk(20)`, this method in our `Student` class will be
    called instead of the same method in the `Person` class. That is, we have provided
    a unique way to walk for our `Student` class that isn't the same for the `Lecturer`
    and `Person` classes.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we refer to such a method as overridden and the process as method overriding.
    The Java virtual machine (JVM) calls the appropriate method for the object that
    is referred.
  prefs: []
  type: TYPE_NORMAL
- en: The Difference between Overriding and Overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at the difference between method overloading and overriding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method overloading deals with the notion of having two or more methods in the
    same class with the same name but different arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Method overriding means having two methods with the same arguments, but different
    implementations. One of them would exist in the parent class, while another would
    exist in the child class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now cover another important topic that will help us write better Java
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations are a way in which we can add metadata to our programs. This metadata
    can include information such as the version of a class we are developing. This
    is useful in scenarios where a class is deprecated or where we are overriding
    a certain method. Such metadata is not part of the program itself, but can help
    us catch errors or offer guidance. Annotations have no direct effect on the operation
    of the code they annotate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a scenario. How do we ensure that we are overriding a certain
    method and not creating another completely different method? When overriding a
    method, a single mistake such as using a different return type will cause the
    method to not be overridden anymore. Such a mistake is easy to make but can lead
    to software bugs later on if not taken care of early in the software development
    stages. How, then, do we enforce overriding? The answer, as you might have already
    guessed, is using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: The @ character indicates to the compiler that what follows is an annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enforce overriding in our `Student` class with an annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have added the `@Override` line above the method name to indicate
    that the method is overridden from the superclass. This annotation will be checked
    by the compiler when you're compiling the program and it will immediately know
    that we are trying to override this method. It will check whether this method
    exists in the superclass and whether the overriding has been done correctly. If
    it hasn't, it will report an error to indicate that the method is not correct.
    This, in a way, will have prevented us from making a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java contains built-in annotations, and you can also create your own. Annotations
    can be applied to declarations of classes, properties, methods, and other program
    elements. When used on a declaration, each annotation appears, by convention,
    on its own line. Let''s look at a few examples of the built-in annotations in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1: Table with different annotations and their use](img/C09581_Table_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 4.1: Table with different annotations and their use'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating Your Own Annotation Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Annotations are created using the **interface** keyword. Let''s declare an
    annotation so that we can add the author information of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This annotation accepts the name of the author and the date. We can then use
    this annotation in our `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can replace the name and date with your values in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you work with objects, it is important that you understand **references**.
    A reference is an address that indicates where an object's variables and methods
    are stored.
  prefs: []
  type: TYPE_NORMAL
- en: When we assign objects to variables or pass them to methods as parameters, we
    aren't actually passing the object itself or its copy – we are passing references
    to the objects themselves in memory.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how references work, let's illustrate this with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `Rectangle`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of what happens in the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: We create two variables, `r1` and `r2`, of type `Rectangle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new `Rectangle` object is assigned to `r1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of `r1` is assigned to `r2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The width and height of `r2` are changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The values of the two objects are finally printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might have expected the values of `r1` and `r2` to have different values.
    However, the output says otherwise. This is because when we used `r2 = r1 ,` we
    created a reference from `r2` to `r1` instead of creating `r2` as a new object
    copied from `r1`. That is, `r2` points to the same object that was pointed to
    by `r1`. Either variable can be used to refer to the object and change its variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Representation of objects r1, r2](img/C09581_Figure_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Representation of objects r1, r2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want `r2` to refer to a new object, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: References in Java become particularly important when arguments are passed to
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are no explicit pointers or pointer arithmetic in Java, as there is in
    C and C++. By using references, however, most pointer capabilities are duplicated
    without many of their drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15: Understanding Inheritance and Polymorphism in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scenario: Imagine we want our `Animals` class we created in Activity one to
    be more object oriented. That way, it would be easier to maintain it and scale
    it in the future in case our farm needs to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective: We are going to create classes to inherit from our `Animals` class,
    implement overloaded and overridden methods, and create an annotation to version
    our classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aim: To understand how to inherit from a class, overload and override methods,
    and create annotations in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `Animals` project we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project, create a new file named `Cat.java` in the `src/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `Cat.java` and inherit from the `Animals` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In it, create a new instance of the `Cat` class and set the family to "`Cat`",
    the name to "`Puppy`", `ears` to two, `eyes` to two, and `legs` to four. Don't
    redefine these methods and fields – instead, use the inherited ones from the `Animals`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the `family`, `name`, `ears`, `legs`, and `eyes`. What is the output?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 322.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, we have learned that classes are blueprints from which we can
    create objects, while objects are instances of a class and provide a specific
    implementation of that class. A class can be public, private, or protected. A
    class has a default constructor that takes no parameters. We can have user-defined
    constructors in Java. The `this` keyword is used to refer to the current instance
    of a class.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned that inheritance is a property where a subclass inherits the
    properties of a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to study overloading, polymorphism, annotation, and references in
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will have a look at the use of interfaces and the `Object`
    class in Java.
  prefs: []
  type: TYPE_NORMAL
