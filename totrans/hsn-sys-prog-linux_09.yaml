- en: Process Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine this scenario: while working on a project as a systems programmer (using
    C on Linux), there is a requirement that, from within the **graphical user interface (GUI**)
    frontend application, when the end user clicks a certain button, the application
    must display the content of a system-generated PDF document. We can assume a PDF
    reader software application is available to us. But, how exactly, will you run
    it from within your C code?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will teach you how to perform this important task. Here, we will
    learn some core Unix/Linux systems programming concepts: How the Unix `exec` model
    works, the predecessor/successor terminology, and how to use up to seven `exec`
    family APIs to make the whole thing actually work in code. Along the way, of course,
    code examples are used to clearly illustrate the concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, the reader will learn about the following key areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of the `exec` operation and its semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the `exec` operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `exec`—the wrong and right ways to do so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling with the `exec`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the seven `exec` family APIs and how to use them in code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the exercises in this chapter requires the Poppler package (PDF utils) to
    be installed; it can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On Ubuntu: `sudo apt install poppler-utils`
  prefs: []
  type: TYPE_NORMAL
- en: On Fedora: `sudo dnf install poppler-utils-<version#>`
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the Fedora case: to get the version number, just type the above command,
    and after typing `poppler-utils-` press the *Tab* key twice; it will autocomplete
    providing a list of choices. Choose the latest version and press *Enter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Process execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we study how the Unix/Linux OS, at the level of the system programmer, executes
    programs. First, we will teach you to understand the important `exec` semantics;
    once this is clear, you can program it, using the `exec` family of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a program to a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As has been mentioned before, a program is a binary file on a storage medium;
    by itself, it is a dead object. To run it and thus make it come alive, into a
    process*, *we have to execute it. When you run a program from, say, the shell,
    it does indeed come alive and become a process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the previous code, from the shell (itself a process: bash), we run
    or execute the `ps(1)` program; `ps` does run; it is now a process; it does its
    job (here printing out the processes currently alive in this terminal''s session),
    and then politely dies, leaving us back on the shell''s prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A moment''s reflection will reveal that to have the `ps(1)` program become
    the `ps` process, some work probably had to be done by the **operating** **system**
    (**OS**). Indeed, that is the case: The OS executes a program and makes it a running
    process ultimately via an API, a system call, called the `execve(2)`. For now,
    though, let''s leave the APIs aside and focus on the concept.'
  prefs: []
  type: TYPE_NORMAL
- en: The exec Unix axiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual
    Memory*,which covered virtual memory, that a process can be visualized as a box
    (a rectangle), having a **virtual address space** (**VAS**); the VAS consists
    of homogeneous regions (technically, mappings) called segments. Essentially, a
    process''s VAS is thus made up of several segments—text (code), data segments,
    library (and other) mappings, and a stack. For your convenience, the diagram representing
    a process''s VAS is reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec63b079-fa41-4cab-be3a-c912d5369c85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1 : The process virtual address space (VAS)'
  prefs: []
  type: TYPE_NORMAL
- en: The lower end has a virtual address of `0`, and addresses increase as we go
    up; we have an upward-growing heap and a downward-growing stack.
  prefs: []
  type: TYPE_NORMAL
- en: Every process alive on the machine will have just such a process VAS; thus,
    it stands to reason, the shell in our preceding small example, bash, has such
    a process VAS (along with all its other attributes such as **process identifier** (**PID**),
    open files, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: So, let's imagine that the shell process bash has a **PID** of 3,396\. Now,
    when we run `ps` from the shell, what actually happens?
  prefs: []
  type: TYPE_NORMAL
- en: Well, obviously, as a first step, the shell checks whether `ps` is a built-in
    command; if so, it runs it; if not, which is the case, it continues on to the
    second step. Now, the shell parses the `PATH` environment variable, and, say,
    locates `ps` in `/bin` . The third step, the interesting one!, is where the shell
    process now executes `/bin/ps` via an API. We shall leave the discussion of the
    exact API(s) until later; for now, we shall just refer to the possible APIs as
    the `exec` APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t lose the forest for the trees; a key point we now come to is this: The
    `exec`, when it occurs, causes the calling process (bash) to execute the called
    **process** (`ps`) by having (among other setups), `ps` overwrite it''s **Virtual
    Address Space** (**VAS**). Yes, you read that right—process execution on Unix,
    and thus Linux, is effected by having one process—the `caller`—get overwritten
    by the process to execute— the `callee`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminology**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some important terminology to help us: The process that is calling
    the `exec` (`bash`, in our example), is called the *predecessor*; the process
    that gets called and executed (`ps` in our example), is called the *successor*.'
  prefs: []
  type: TYPE_NORMAL
- en: Key points during an exec operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following sums up important points to note when a predecessor process execs a
    successor:'
  prefs: []
  type: TYPE_NORMAL
- en: The successor process overwrites (or overlays) the predecessor's virtual address
    space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In effect, the predecessor's text, data, library, and stack segments are now
    replaced by that of the successor's.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OS will take care of the size adjustments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No new process has been created—the successor now runs in the context of the
    old predecessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several predecessor attributes (including but not limited to the PID and open
    files) thus get auto-inherited by the successor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (The astute reader could then question why, in our previous example, the PID
    of `ps` is not 3,396 ? Patience, please, we shall have the precise answer on the
    GitHub repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'On a successful exec, there is no possibility of returning to the predecessor;
    it''s gone. Colloquially, performing an exec is like committing suicide for the
    predecessor: After successful execution, the successor is all that''s left; returning
    to the predecessor is out of the question:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b9370fcb-5c9a-4169-a06e-d84998fdf879.png)*Fig 2: The exec operation*'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the exec axiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you test this `exec` axiom described above? Sure. Let's try this in three
    different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment 1 – on the CLI, no frills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the simple steps here:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a shell (a Terminal window, typically, on a GUI-based Linux)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the window, or more precisely, at the shell prompt, type this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What do you notice? Can you explain it?
  prefs: []
  type: TYPE_NORMAL
- en: Hey, come on, please try it out first, and then read on.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, the terminal window process is the predecessor here; upon an `exec` it's
    overwritten by the successor process `ps`, which does its work and exits (you
    probably did not see the output as it disappeared too quickly). `ps `is the successor
    process, and, of course, we cannot return to the predecessor (the Terminal window)—`ps`
    has literally replaced its VAS.  Thus, the Terminal window effectively disappears.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment 2 – on the CLI, again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we''ll make it easier on you! Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a shell (a Terminal window, typically, on a GUI-based Linux).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window, or more precisely, at the shell prompt, run `ps` followed by
    `bash ` —yes, we're spawning a subshell here, followed by `ps` once more. (Check
    out the next screenshot; notice the PIDs of the original and sub-shell Bash processes
    - 3,396 and 13,040.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the sub-shell, `exec` the `ps` command; this `ps` successor process overwrites
    (or overlays) the process image of the predecessor process—the bash sub-shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the output: In the `exec ps` command output, the PID of `ps` is the
    PID of the bash subshell process: 13,040! This suggests that it''s running in
    the context of that process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also notice we''re back to the original bash shell process PID 3,396 now, as,
    of course, we cannot return to the predecessor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fe76029-5ac1-418b-bdac-2c603d074b07.png)'
  prefs: []
  type: TYPE_IMG
- en: A third experimental run will follow shortly, once we've got some `exec` APIs
    to play with.
  prefs: []
  type: TYPE_NORMAL
- en: The point of no return
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s important for the systems programmer to understand that, once an `exec`
    operation is successful, there is no return to the predecessor process. To illustrate
    this, consider the rough call graph here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`main()` calls `foo()`*, *which calls `exec(something)`; once the `exec` is
    successful, `bar()` will never run!'
  prefs: []
  type: TYPE_NORMAL
- en: Why not? We cannot reach it in the predecessor's execution path as the entire
    execution context has now changed—to the context of the successor process (something).
    The PID remains intact though.
  prefs: []
  type: TYPE_NORMAL
- en: Only if the `exec` fails will the function `bar()` get control (as, of course,
    we would still be in the context of the predecessor).
  prefs: []
  type: TYPE_NORMAL
- en: As a further fine point, note that it's possible that the `exec()` operation
    itself succeeds, but the process being executed, something, fails. That's OK;
    it does not change the semantics; `bar()` will still not execute, as the successor
    has taken over.
  prefs: []
  type: TYPE_NORMAL
- en: Family time – the exec family APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have understood the `exec` semantics, it''s time we saw how to
    perform the `exec` operation programmatically. Unix and Linux provide several
    C APIs, seven in fact, that all ultimately do the same job: They have the predecessor
    process `exec` the successor.'
  prefs: []
  type: TYPE_NORMAL
- en: So, there are seven APIs that all do the same thing? Mostly, yes; hence they
    are called the `exec` family of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Hang on, though we said seven APIs, but the list above has six; indeed: the
    seventh is special in a sense and not shown above. As usual, have a bit of patience;
    we will cover it!'
  prefs: []
  type: TYPE_NORMAL
- en: The reality is that though each API will ultimately perform the same job, using
    a particular one helps based on the situation you are in (convenience-wise). Lets
    not nitpick, and, for now, at least, disregard their differences; instead, let's
    focus on understanding the first one; the rest will automatically and easily follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the first API, the `execl(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Does it take two, three, or more parameters? Well, in case you are new to it,
    the ellipse— `...` — represents a variable argument list or `varargs`, a feature
    supported by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the path name to the application you would like to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the second parameter onward, the `varargs` , the argument(s) to pass to
    the successor process are inclusive of `argv[0]`. Think about it, in the simple
    experiments above, we passed along parameters on the command line via the shell
    process; in reality, it was really the shell process, the predecessor, that passed
    arguments required by the successor process. This makes sense: Who else but the
    predecessor would pass arguments to the successor?'
  prefs: []
  type: TYPE_NORMAL
- en: 'How will the compiler know that you are done passing along arguments? Simple:
    you must null terminate the argument list: `execl(const char *pathname_to_successor_program,
    const char *argv0, const char *argv1, ..., const char *argvn, (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can see why it''s named the way it is: the `execl` API, of course,
    performs an exec; the last letter `l` implies long format; each argument of the
    successor process is passed to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To clarify this, let''s write a simple example C program; its job is to invoke
    the `uname` process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For readability, only the relevant parts of the code are displayed here; to
    view and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to the `execl` API is the path name of the successor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second parameter is the name of the program. Be careful: a fairly typical
    newbie mistake is to leave it out!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this simple case, we only then pass along whatever the user sends as the
    argument `argv[1]`: `-a` or `-r` ; we don''t even perform robust error checking
    to ensure the correct parameter is passed by the user (we leave it as an exercise
    for you).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we just attempt to null-terminate with a single `0`, the compiler complains,
    with a warning such as this (this could differ depending on the `gcc` compiler
    version you use):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning: missing sentinel in function call [-Wformat=]`.'
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate the warning, you must typecast the `0` with `(char *)` as shown
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use a `printf()` to demonstrate that control will never reach it.
    Why is this? Well, think about it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either the `execl` succeeds; thus the successor process (`uname`) takes over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or the `execl` fails; the `FATAL` macro performs error reporting and terminates
    the predecessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s build and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass an argument; we show a few examples here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It does work (though, as can be seen from the last case, the `execl_eg`program's
    argument the error checking isn't great).
  prefs: []
  type: TYPE_NORMAL
- en: 'We encourage you to try this simple program out yourself; in fact, experiment
    a bit: for example, change the first parameter to some unknown (for example, `/bin/oname`)
    and see what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: The wrong way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, to show the right way to do something, it's useful to first see it
    done the wrong way!
  prefs: []
  type: TYPE_NORMAL
- en: Error handling and the exec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some programmer''s show off: They don''t use an *if* condition to check whether
    the `exec` API failed; they just write the line of code after an `exec` to be
    the failure case!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, take the previous program, but change the code to this, the
    wrong way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, yes: The only reason control will ever reach the `''FATAL()''` line
    is if the exec operation failed. This sounds cool, but please, do not code like
    that. Be professional, follow the rules and good coding style guidelines; you''ll
    be a better programmer and glad for it! (An innocent freshly minted programmer
    might not even realize that what follows the `execl` above is actually error handling;
    who could blame him? And he might attempt to put some business logic there!)'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a zero as an argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we have a (fictional) requirement: From within our C code, we must
    execute the program `/projectx/do_this_now` passing along three parameters: `-1`,
    `0` and `55`. Like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/projectx/do_this_now -1 0 55`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the syntax of the `exec` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execl(const char *pathname_to_successor_program, const char *argv0, const
    char *argv1, ..., const char *argvn, (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it seems quite trivial; let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execl("/projectx/do_this_now", "do_this_now", -1, 0, 55, (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: Whoops! The compiler will, or *could*, interpret the second argument to the
    successor `0` (after the `-1`) as the `NULL` terminator, and would therefore not
    see the following argument `55`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixing this is easy; we just have to remember that *each argument to the* successor
    *process is of data type character pointer*, not integer; the `NULL` terminator
    itself is an integer (though to keep the compiler happy we typecast it to `(char
    *)`), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execl("/projectx/do_this_now", "do_this_now", "-1", "0", "55", (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the name of the successor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No, we are not debating how to hack who will succeed Queen Elizabeth II to
    the throne here, sorry. What we are referring to is this: How can you correctly
    specify the name of the successor process; that is, can we programmatically change
    it to whatever we like?'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it looks trivial indeed: The second parameter to the `execl`
    is the `argv[0]` argument to pass to the successor; in effect, it appears, its
    name! So, let''s try it out: We write a couple of C programs; the first one, the
    predecessor (`ch9/predcs_name.c`) is passed a name parameter from the user. It
    then execs another program of ours, `successor_setnm`  via the `execl` passing
    along the user-supplied name as the first parameter (within the API, it sets the
    successor `argv[0]` parameter to the predecessor''s `argv[1]`), like so: `execl("./successor_setnm",
    argv[1], argv[1], (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the `execl` syntax: `execl(pathname_to_successor_program, argv0, argv1,
    ..., argvn, 0);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the thinking here is: The predecessor has set the successor''s `argv[0]`
    value to `argv[1]`, and thus the successor''s name should be the predecessor''s
    `argv[1]`. However, it does not work out; see the output from a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We deliberately have the successor process invoke the `pause(2)` system call
    (it simply causes it to sleep until it receives a signal). This way, we can run
    it in the background, and then run `ps` to lookup the successor PID and name!
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting: We find that, though the name is not what we want in `ps` output
    (above), it is correct in the `printf`*;* implying that `argv[0]` has been correctly
    received and set to the successor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, we must clean up; lets kill off the background process now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as is now apparent, what we''ve done preceding is not enough: To reflect
    the name we want at the level of the OS, we need an alternate API; one such API
    is the `prctl(2)` system call (or even the `pthread_setname_np(3)` pthreads API).
    Without getting into too much detail here, we use it with the `PR_SET_NAME` parameter
    (as usual, please see the man page on `prctl(2)` for full details). Hence, the
    correct code using the `prctl(2)` system call (only the relevant code snippet
    from `successor_setnm.c` is displayed here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we  now run it the right way *(*the logic involves passing along an optional
    second parameter which will be used to `_correctly_` set the successor process
    name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This time it works exactly as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining exec family APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great, we''ve covered in detail how to and how not to use the first of the
    `exec` family of APIs—the `execl(3)`. What about the remainder? Let''s check them
    out; reproduced for the reader''s convenience is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned several times, the `execl` syntax is this: `execl(const char *pathname_to_successor_program,
    const char *argv0, const char *argv1, ..., const char *argvn, (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall, it''s named `execl`; the `l` implies a long format variable argument
    list: each argument of the successor process is passed to it in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the other APIs in the family.
  prefs: []
  type: TYPE_NORMAL
- en: The execlp API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `execlp` is a slight variation on the `execl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int **execlp**(const char ***file**, const char *arg, ...);`'
  prefs: []
  type: TYPE_NORMAL
- en: As before, the `l` in `execlp` implies a long format variable argument list;
    the `p` implies that the environment variable `PATH` is searched for the program
    to execute. As you are probably aware, the PATH environment variable consists
    of a set of colon-delimited (`:`) directories to search for the program file to
    run; the first match is the program that is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on our Ubuntu VM (where we are logged in as the user `seawolf`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, if you execute a process via the `execlp`, you need not give the absolute
    or full path name as the first parameter, but just the program name; see how the
    following two examples differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execl("/bin/uname", "uname", argv[1], (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**execlp**("uname", "uname", argv[1], (char *)0);`'
  prefs: []
  type: TYPE_NORMAL
- en: With the `execl`, you have to specify the full path name to `uname`; with the
    `execlp`, you need not; the library routine will perform the work of looking up
    the PATH and figuring out the match to `uname`! (It would find the first match
    in `/bin`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `which` utility to locate a program, in effect finding it''s first
    match in the path. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ which uname`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin/uname`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs: []
  type: TYPE_NORMAL
- en: This, the fact the `execlp` automatically searches the path, indeed is convenient;
    note though, this is at the possible cost of security!
  prefs: []
  type: TYPE_NORMAL
- en: Hackers write programs called Trojans - essentially, programs that pretend to
    be something they're not; these are obviously dangerous. If a hacker can place
    a Trojan version of `uname` in your, say, home directory, and modify the PATH
    environment variable to search your home directory first, then they could take
    control when you (think) you are running `uname`.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, it's always better to specify the full `pathname` when
    executing a program (hence, avoid using the `execlp`, `execvp`, and the `execvpe`
    APIs).
  prefs: []
  type: TYPE_NORMAL
- en: What if the PATH environment variable is undefined? In this case, the APIs default
    to searching the current working directory (the `cwd`) of the process as well
    as something called the `confstr` path, which usually defaults to the directory `/bin` followed
    by `/usr/bin`*.*
  prefs: []
  type: TYPE_NORMAL
- en: The execle API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now for the `execle(3)` API; its signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int **execle**(const char *path, const char *arg, ...,char * const envp[]);`'
  prefs: []
  type: TYPE_NORMAL
- en: As before, the `l` in `execle` implies a long format variable argument list;
    the `e` implies that we can pass along an array of environment variables to the
    successor process.
  prefs: []
  type: TYPE_NORMAL
- en: The process environment consists of a set of `<name>=<value>` variable pairs.
    The environment is actually unique to each process and is stored within the process
    stack segment. You can see the entire list via either the `printenv`*,* `env`*,*
    or `set` commands (*set* is a shell built-in). Programmatically, use the `extern`
    `char **environ` to gain access to the process's environment.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the successor will inherit the environment of the predecessor process.
    What if this is not what is required; for example, we would like to execute a
    process but change the value of, say, the PATH (or perhaps introduce a new environment
    variable into the mix). To do so, we would have the predecessor process make a
    copy of the environment, modify it as required (perhaps adding, editing, deleting
    variables as required), and then pass along the pointer to the new environment
    to the successor process. That's precisely what the last parameter `char * const
    envp[]` is meant for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Old Unix programs used to accept a third argument to `main()`: `char **arge`,
    which represented the process environment. This is now considered deprecated;
    use the `extern environ`  instead.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no mechanism to pass just a few environment variables to the successor
    process; the whole bunch—in the form of a two-dimensional array of strings (which
    is itself `NULL`-terminated) must be passed.
  prefs: []
  type: TYPE_NORMAL
- en: The execv API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *execv(3) *API''s signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int **execv**(const char *path, char *const argv[]);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen, the first parameter is the pathname of the successor process.
    The second parameter is, similar to the environment list above, a two-dimensional
    array of strings (each of them `NULL`-terminated) holding all the arguments to
    pass to the successor, starting from `argv[0]`. Think about it, it''s identical
    to what we, C programmers, are so used to; this is the signature of the `main()` function
    in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int main(int argc, char *argv[]);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`argc`, of course, is the number of parameters received, including the program
    name itself (held in `argv[0]`), and **`argv`** is a pointer to a two-dimensional
    array of strings (each of them `NULL`-terminated) holding all the arguments starting
    from `argv[0]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we colloquially call this the short format (as opposed to the long format we
    used earlier - the `l` style). When you see the `v` (short for argv), it represents
    the short format argument-passing style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the remaining two APIs are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: The `execvp(3)`: short format arguments, and path being searched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `execvpe(3)`: short format arguments, path being searched, and environment
    list being explicitly passed to the successor. Additionally, this API requires
    the feature test macro `_GNU_SOURCE` to be defined (which, incidentally, we do
    in all this book's source code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `exec` functions with the `p` in them—the ones that search the `PATH`—the `execlp`,
    `execvp`, and `execvpe`, have an additional feature: If the file they are searching
    for is found but permission to open it is lacking, they will not fail immediately
    (like the other `exec` APIs that would fail and set `errno` to `EACCESS`); instead,
    they will continue searching the remainder of the `PATH` for the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Exec at the OS level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have covered six of the seven *exec family* APIs. Finally,
    the seventh one is the `execve(2)`. Did you notice? The `2` in brackets conveys
    that it's a system call(recall the details covered regarding system calls in [Chapter
    1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System Architecture*).
  prefs: []
  type: TYPE_NORMAL
- en: The fact is, all the preceding six `exec` APIs are within `glibc`—the library
    layer; only the `execve(2)` is a system call. You will realize that, ultimately,
    to have a process be able to execute another program—thus launching or running
    a successor—will require OS-level support. So, yes, the reality is that all the
    above six `exec` APIs are merely wrappers; they transform their arguments and
    invoke the `execve` system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the signature of the `execve(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int execve(const char *filename, char *const argv[], char *const envp[]);`'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the exec family APIs summary table.
  prefs: []
  type: TYPE_NORMAL
- en: Summary table – exec family of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a table to summarize all seven of the `exec` family APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Exec API** | **Arguments: long format (l)** | **Arguments: short format
    (v)** | **PATH searched? (p)** | **Environment passed? (e)** | **API layer** |'
  prefs: []
  type: TYPE_TB
- en: '| `execl` | Y | N | N | N | Lib |'
  prefs: []
  type: TYPE_TB
- en: '| `execlp` | Y | N | Y | N | Lib |'
  prefs: []
  type: TYPE_TB
- en: '| `execle` | Y | N | N | Y | Lib |'
  prefs: []
  type: TYPE_TB
- en: '| `execv` | N | Y | N | N | Lib |'
  prefs: []
  type: TYPE_TB
- en: '| `execvp` | N | Y | Y | N | Lib |'
  prefs: []
  type: TYPE_TB
- en: '| `execvpe` | N | Y | Y | Y | Lib |'
  prefs: []
  type: TYPE_TB
- en: '| `execve` | N | Y | N | Y | SysCall |'
  prefs: []
  type: TYPE_TB
- en: 'The exec APIs format: `exec<foo>`, where `<foo>` is differing combinations
    of `{l,v,p,e}`.'
  prefs: []
  type: TYPE_NORMAL
- en: All the listed APIs, on success, as we have learned, do not return at all. Only
    upon failure, would you see a return value; as per the usual norms, the global
    variable `errno` will get set to reflect the cause of the error, which can be
    conveniently looked up via the `perror(3)` or `strerror(3)` APIs (as an example,
    within the book's provided source code, check out the `FATAL` macro within the `common.h`header
    file).
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the introduction to this chapter, we mentioned a requirement: from within
    a GUI frontend, to display the content of a system-generated PDF document. Lets
    do this here.'
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we would require a PDF reader application; we can assume we have one.
    Indeed, on many Linux distributions, the evince application is a good PDF reader
    application, usually preinstalled (true on Ubuntu and Fedora, among others).
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, here, we shall not bother with a GUI frontend application, we shall use
    plain old C to write a CLI app that, given a PDF document `pathname`, executes
    the evince PDF reader application. What PDF document do we display? Ah, that''s
    a surprise! (take a look):'
  prefs: []
  type: TYPE_NORMAL
- en: 'For readability, only the relevant parts of the code are displayed as follows;
    to view and run it, the entire source code is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We invoke the preceding function from `main()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We build it, then perform a sample run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here is a screenshot of the action!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ff50ecc-cff5-47a5-9b82-fc5ec961629c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What if we are running Linux on the console only (no GUI)? Then, of course,
    the preceding app will not work (and evince is unlikely to even be installed).
    Here is an example of this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, why not try modifying the above app to use a CLI PDF toolset instead;
    one such toolset is from the Poppler project (see the following note). Within
    it, one of the interesting utilities it provides is `pdftohtml`. Why not use it
    to generate HTML from a PDF document? We leave it as an exercise for the reader
    (see the *Questions* section on the GitHub repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'These useful PDF utilities are provided by an open source project called Poppler.
    You can easily install these PDF utilities, on an Ubuntu box: `sudo apt install
    poppler-utils`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quite easily trace what happens in the `pdfrdr_exec` program; here,
    we use the `ltrace(1)` to see the library calls issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The key call: the `execv` of course is seen; interestingly, `ltrace` then helpfully
    tells us that there''s no return ... from it. We then see the library APIs of
    the evince software itself.'
  prefs: []
  type: TYPE_NORMAL
- en: What if we use `strace(1)` to see the system calls issued?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the very first one is the `execve(2)`, proving that the `execv(3)` library
    API invokes the `execve(2)` system call. The rest of the output, of course, is
    the system calls issued by the evince process as it executes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the Unix/Linux `exec` programming model; the key concept
    of the predecessor and successor processes, and, importantly, how the successor
    (more-or-less completely) overlays the predecessor. The seven `exec` family APIs were
    covered, along with several code examples. Error handling, successor name specification,
    and so on, were covered as well. The systems programmer will now have sufficient
    knowledge to write C code that correctly executes a given program from within
    a process.
  prefs: []
  type: TYPE_NORMAL
