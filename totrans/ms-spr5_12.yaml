- en: Spring Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we discussed a number of Spring Projects--Spring MVC,
    Spring Boot, Spring Cloud, Spring Cloud Data Flow, and Spring Reactive. The challenges
    with enterprise application development do not end with choosing the right framework.
    One of the biggest challenges is the appropriate use of the frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the best practices of enterprise application
    development with the Spring Framework. We talk about best practices related to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of enterprise applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependency versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven standard directory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maven defines a standard directory layout for all projects. Once all projects
    adopt this layout, it allows developers to switch between projects with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example directory layout for a web project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77e1c8cb-2c06-43ea-9210-4edd6be11c53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are some of the important standard directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/java`: All application-related source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/resources`: All application-related resources--Spring context files,
    property files, logging configuration, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main/webapp`: All resources related to the web application--view files
    (JSP, view templates, static content, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/test/java`: All unit testing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/test/resources`: All resources related to unit testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core design aims is **Separation of Concerns** (**SoC**). One of
    the good practices, irrespective of the size of an application or microservice,
    is to create a layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each layer in a layered architecture has one concern, and it should implement
    it well. Layering the applications also helps in simplifying unit tests. The code
    in each layer can be completely unit tested by mocking out the following layer.
    The following figure shows some of the important layers in a typical microservice/web
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e19c9390-8813-4d6b-8ecb-9ae44c96be43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The layers shown in the previous diagram are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: In a microservice, the presentation layer is where
    the Rest Controllers reside. In a typical web application, this layer would also
    contain the view-related content--JSPs, templates, and static content. The presentation
    layer talks to the services layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services layer**: This acts a facade to the business layer. Different views--mobile,
    web, and tablets, this might need different kinds of data. The Services layer
    understands their needs and provides the right data based on the presentation
    layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business layer**: This is where all the business logic is. Another best practice
    is to the put most of the business logic into the Domain Model. The business layer
    talks to data layer to get the data and add business logic on top of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence layer**: This takes care of retrieving and storing data to the
    database. This layer typically contains the JPA mappings or the JDBC code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended that you have different Spring contexts for each of the layers.
    This helps in separating concerns of each layer. This also helps in unit testing
    code for the specific layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application `context.xml` can be used to import contexts from all the layers.
    This can be context that is loaded when an application is run. Some of the possible
    spring context names are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application-context.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`presentation-context.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`services-context.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`business-context.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`persistence-context.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate API and impl for important layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another best practice to ensure loosely coupled application layers is to have
    separate API and implementation modules in each layer. The following screenshot
    shows the data layer with two submodules--API and impl:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51c87159-b8f4-442c-ad92-f7a2f3e9774d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The data `pom.xml` defines two child modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `api` module is used to define the interface that the data layer offers.
    The `impl` module is used to create the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The business layer should be built using the API from the data layer. The business
    layer should not depend on the implementation (the `impl` module) of the data
    layer. This helps in creating a clear separation between the two layers. The implementation
    of the data layer can be changed without affecting the business layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an extract from the `pom.xml` file of the business
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While the `data-api` dependency has the default scope--compile--the `data-impl`
    dependency has a scope runtime. This ensures that the `data-impl` module is not
    available during the compilation of business layer.
  prefs: []
  type: TYPE_NORMAL
- en: While separate `API` and `impl` can be implemented for all layers, it is recommended
    that you use it at least for the business layer.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checked exceptions**: When a service method throws this exception, all the
    consumer methods should either handle or throw the exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unchecked exceptions**: The consumer method is not required to handle or
    throw the exception thrown by the service method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeException` and all its subclasses are unchecked exceptions. All other
    exceptions are checked exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checked exceptions can make your code cumbersome to read. Take a look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of the execute method in the `PreparedStatement` class is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`SQLException` is a checked exception. So, any method that calls the `execute()`
    method should either handle the exception or throw it. In the preceding example,
    we are handling the exception using a `try-catch` block.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring's approach to exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring takes a different approach to this problem. It makes most of the exceptions
    unchecked. The code becomes simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The update method in `JDBCTemplate` does not declare throwing any exception.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We recommend an approach very similar to the one used by Spring Framework. When
    deciding what exceptions to throw from a method, always think about the consumer
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Can the consumer of the method do something about the exception?
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, if the execution of the query failed, the `consumer`
    method would not be able to do anything except show an error page to the user.
    In that kind of a scenario, we should not complicate things and force the consumer
    to handle the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend the following approach to exception handling in applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Think about the consumer. If the consumer of the method cannot do anything useful
    (except logging or showing an error page) about the exception, make it unchecked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the topmost layer, typically the presentation layer, have `catch all` exception
    handling to display an error page or to send an error response to the consumer.
    Refer to `@ControllerAdvice` in [Chapter 3,](fbc94f01-19b5-4ff2-8955-5bee445b71f5.xhtml)
    *Building Web Application with Spring MVC* for more details about implementing
    catch all exception handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping your Spring configuration light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the problems with Spring before annotations was the size of the application
    context XML files. Application context XML files ran into hundreds of lines (sometimes,
    even thousands of lines). However, with annotations, there is no need for such
    long application context XML files anymore.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you use component scans to locate and autowire the beans instead
    of manually wiring the beans in XML files. Keep your application context XML files
    very small. We recommend that you use Java `@Configuration` wherever some framework-related
    configuration is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the basePackageClasses attribute in ComponentScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using component scan, we recommend that you use the `basePackageClasses`
    attribute. The following snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `basePackageClasses` attribute is the type-safe alternative to `basePackages()`
    in order to specify the packages to scan for the annotated components. The package
    of each specified class will be scanned.
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that even when the package is renamed or moved, the component
    scan would work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Not using version numbers in schema references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring can recognize the correct version of the schemas from the dependencies.
    Hence, it is not necessary to use version numbers in the schema references anymore.
    The class snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Preferring constructor injection over setter injection for mandatory dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of dependencies for beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandatory dependencies**: These are dependencies that you want to be available
    for the bean. If the dependency is not available, you would want the context to
    fail loading up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional dependencies**: These are dependencies that are optional. They are
    not always available. It''s fine to load the context even if these are not available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We recommend that you wire mandatory dependencies using constructor injection
    instead of setter injection. This would ensure that the context would fail to
    load if the mandatory dependency is missing. The following snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An extract from the Spring documentation ([https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection))
    is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring team generally advocates constructor injection as it enables one
    to implement application components as immutable objects and ensure that the required
    dependencies are not null. Furthermore, constructor-injected components are always
    returned to the client (calling) code in a fully initialized state. As a side
    note, a large number of constructor arguments is a bad code smell, implying that
    the class likely has too many responsibilities and should be refactored to better
    address proper Separation of Concerns. Setter injection should primarily only
    be used for optional dependencies that can be assigned reasonable default values
    within the class. Otherwise, not-null checks must be performed everywhere the
    code uses the dependency. One benefit of setter injection is that setter methods
    make objects of that class amenable to reconfiguration or re-injection later.
    Management through [JMX MBeans](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#jmx)
    is therefore a compelling use case for setter injection.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependency versions for Spring Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using Spring Boot, then the simplest option to manage dependency
    versions is to use `spring-boot-starter-parent` as the parent POM. This is the
    option we used in all our project examples in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Versions of more than 200 dependencies are managed by `spring-boot-starter-parent`.
    Before a Spring Boot release, it is ensured that all the versions of these dependencies
    play well together. The following are some of the dependency versions that are
    managed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you do not override any of the versions of the managed
    dependencies in the project POM file. This ensures that when we upgrade our Spring
    Boot version, we would get the latest version upgrades of all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you have to use a custom corporate POM as a parent POM. The following
    snippet shows how to manage dependency versions in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not using Spring Boot, then you can manage all basic Spring dependencies
    using Spring BOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the basic aim of unit testing is to find defects, approaches for writing
    unit tests for each of the layers are different. In this section, we will take
    a quick look at unit testing examples and best practices for different layers.
  prefs: []
  type: TYPE_NORMAL
- en: The business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing tests for the business layer, we recommend that you avoid using
    Spring Framework in the unit tests. This will ensure that your tests are framework
    independent and will run faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a unit test written without using Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Spring Framework is used to wire dependencies in the running application. However,
    in your unit tests, using the `@InjectMocks` Mockito annotation in combination
    with `@Mock` is the best option.
  prefs: []
  type: TYPE_NORMAL
- en: Web layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests for web layers involve testing the Controllers--REST and otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Mock MVC for web layers built on Spring MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jersey Test Framework is a good choice for REST Services built using Jersey
    and JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A quick example of setting up the Mock MVC framework is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using `@WebMvcTest` will allow us to use autowire `MockMvc` and execute web
    requests. A great feature of `@WebMVCTest` is that it only instantiates the controller
    components. All other Spring components are expected to be mocked and can be autowired
    using `@MockBean`.
  prefs: []
  type: TYPE_NORMAL
- en: The data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot offers a simple annotation `@DataJpaTest` for data layer unit tests.
    A simple example is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`@DataJpaTest` may also inject a `TestEntityManager` bean, which provides an
    alternative to the standard JPA `entityManager` specifically designed for tests.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use `TestEntityManager` outside of `@DataJpaTest`, you can also
    use the `@AutoConfigureTestEntityManager` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Data JPA tests are run against an embedded database by default. This ensures
    that tests can be run as many times as you would want without affecting the database.
  prefs: []
  type: TYPE_NORMAL
- en: Other best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We recommend that you follow the Test-Driven Development (TDD) approach to develop
    code. Writing tests before code results in a clear understanding of the complexity
    and dependencies of the code unit being written. In my experience, this leads
    to better design and better code.
  prefs: []
  type: TYPE_NORMAL
- en: The best projects that I worked on recognize that unit tests are more important
    than the source code. Applications evolve. Architectures of a few years back are
    legacy today. By having great unit tests, we can continuously refactor and improve
    our projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few guidelines are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be readable. Other developers should be able to understand
    the test in less than 15 seconds. Aim for tests that serve as documentation for
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should fail only when there is a defect in the production code. This
    seems simple. However, if unit tests use external data, they can fail when external
    data changes. Over a period of time, developers lose confidence in unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should run fast. Slow tests are run infrequently, losing all benefits
    associated with unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests should be run as part of Continuous Integration. As soon as there
    is a commit in the version control, the build (with unit tests) should run and
    notify developers in case of failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While unit tests test a specific layer, integration tests are used to test the
    code in multiple layers. To keep the tests repeatable, we recommend that you use
    an embedded database instead of a real database for integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you create a separate profile for integration tests using
    an embedded database. This ensures that each developer has their own database
    to run the tests against. Let's look at few simple examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `application-production.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `application-integration-test.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We would need to include the H2 driver dependency in the test scope, as shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'An example integration test using the `@ActiveProfiles("integration-test")`
    is shown as follows. The integration tests will now run using an embedded database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Integration tests are critical to be able to continuously deliver working software.
    The features Spring Boot provides make it easy to implement integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing the session state is one of the important challenges in distributing
    and scaling web applications. HTTP is a stateless protocol. The state of the user
    interactions with web applications is typically managed in HttpSession.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to have as little data as possible in a session. Focus on identifying
    and removing data that is not needed in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a distributed application with three instances, as shown here. Each
    of these instances has its own local session copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78a17650-50c7-4644-b871-65f467952a99.png)'
  prefs: []
  type: TYPE_IMG
- en: Imagine a user is being currently served from `App Instance 1`. Imagine if `App
    Instance 1` goes down and the load balancer sends the user to `App Instance 2`.
    `App Instance 2` is not aware of the session state that was available with `App
    Instance 1`. The user has to log in and start off again. That's not a good user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Session provides features to externalize your session store. Instead
    of using the local HttpSession, Spring Session provides alternatives to store
    the session state to different data stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1befe8b9-05f2-45a6-8a0a-fb71a5e8e655.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Session also provides a clear Separation of Concerns. The application
    code remains the same irrespective of the session data store being used. We can
    switch between session data stores through configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will connect Spring Session to use a Redis session store.
    While the code to put data into session remains the same, the data would be stored
    to Redis instead of HTTP Session.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three simple steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Add dependencies for Spring Session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Filter to replace HttpSession with Spring Session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable filtering for Tomcat by extending `AbstractHttpSessionApplicationInitializer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding dependencies for Spring Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependencies needed for Spring Session connecting to a Redis store are
    `spring-session-data-redis` and `lettuce-core`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Filter to replacing HttpSession with Spring Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following configuration creates a Servlet Filter to replace `HTTPSession`
    with a Session implementation from Spring Session--Redis Data Store in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Enabling filtering for Tomcat by extending AbstractHttpSessionApplicationInitializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous step, Servlet Filter needs to be enabled on every request to
    the Servlet Container (Tomcat). The following snippet shows the code involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all the configuration you would need. The great thing with Spring Session
    is the fact that your application code talking to `HTTPSession` does not change!
    You can continue using the HttpSession interface, but in the background, Spring
    Session ensures that the session data is stored to an external data store - Redis
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Spring Session provides simple options to connect to an external session store.
    Backing up your session on an external session store ensures that your user can
    fail over even when one of your application instances goes down.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is essential in order to build a performant application. You would not
    want to hit the external service or the database all the time. Data that does
    not change frequently can be cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides transparent mechanisms to connect and use a Cache. The following
    steps are involved in enabling a cache on an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Spring Boot Starter Cache dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add caching annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's discuss these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Spring Boot Starter Cache dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following snippet shows the `spring-boot-starter-cache` dependency. Itt
    brings in all the dependencies and auto-configuration needed to configure a cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding caching annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to add the caching annotations, indicating when something
    needs to be added or removed from the cache. The following snippet shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the annotations that are supported are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cacheable`: Used to cache the result of a method invocation. The default implementation
    constructs the key based on the parameters passed to the method. The method will
    not be invoked if the value is found in the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CachePut`: Similar to `@Cacheable`. A significant difference is that the method
    is always invoked and the result is put in a cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CacheEvict`: Triggers an evict for a specific element from the cache. Typically
    done when an element is deleted or updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few other important things to note about Spring Caching are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The default cache used is ConcurrentHashMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Caching abstraction is JSR-107-compliant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other caches that can be auto-configured include EhCache, Redis, and Hazelcast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring and Spring Boot depend on the Commons Logging API. They are not dependent
    on any other logging frameworks. Spring Boot provides starters to simplify the
    configuration of specific logging frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Logback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starter `spring-boot-starter-logging` is all that you need to use the Logback
    framework. This dependency is the default logging included in most of the starters,
    including `spring-boot-starter-web`. The dependency is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows logback and related dependencies included in `spring-boot-starter-logging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Log4j2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use Log4j2, we need to use the starter `spring-boot-starter-log4j2`. When
    we use starters such as `spring-boot-starter-web`, we need to ensure that we exclude
    the dependency in `spring-boot-starter-logging`. The following snippet shows the
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows the dependencies used in the `spring-boot-starter-log4j2`
    starter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Framework independent configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Irrespective of the logging framework used, Spring Boot allows a few basic
    configuration options in application properties. A few examples are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the age of microservices, irrespective of the framework you use for logging,
    we recommend that you log to the console (instead of a file) and use a centralized
    logging store tool to capture logs from all microservice instances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some of the best practices in developing Spring-based
    applications. We covered best practices in structuring our projects--layering,
    following the Maven standard directory layout, and using `api` and implementation
    modules. We also discussed how to keep our Spring configuration to a minimum.
    We looked at best practices related to logging, caching, session management, and
    exception handling.
  prefs: []
  type: TYPE_NORMAL
