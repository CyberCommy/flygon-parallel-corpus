- en: Extending TempMessenger with a User Authentication Microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we created a web-based messenger, TempMessenger, which
    consists of two microservices—one that is responsible for storing and retrieving
    messages and another that is responsible for serving web requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look to extend our existing TempMessenger platform
    with a User Authentication microservice. This will consist of a Nameko service
    with a PostgreSQL database dependency that has the ability to create new users
    and authenticate existing users.
  prefs: []
  type: TYPE_NORMAL
- en: We will also replace our Nameko Web Server microservice with a more suitable
    Flask app that will allow us to keep track of web sessions for our users.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to have read the last chapter in order to follow this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Postgres dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a User Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely storing passwords in a Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Flask app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TempMessenger goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some new goals for our new and improved TempMessenger:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can now sign-up for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To send messages, users must be logged in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users not logged in can still read all messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If at any point you would like to refer to all of the code in this chapter
    in its entirety, feel free to view it with tests at: [http://url.marcuspen.com/github-ppb](http://url.marcuspen.com/github-ppb).'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to function in this chapter, your local machine will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker: If you haven''t installed Docker already, please see the official documentation:
    [http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A virtualenv running Python 3.6 or later; you can reuse your virtualenv from
    the last chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pgAdmin: see the official documentation for installation instructions: [http://url.marcuspen.com/pgadmin](http://url.marcuspen.com/pgadmin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A RabbitMQ container running on the default ports: this should be present from
    the last chapter, [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building
    a Web Messenger with Microservices.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Redis container running on the default ports: this should be present from
    the last chapter, [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building
    a Web Messenger with Microservices.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other requirements will be installed as we progress through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All instructions in this chapter are tailored towards macOS or Debian/Ubuntu
    systems; however, I have made an effort to only use multi-platform dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, there will be blocks of code. Different types of code
    will have their own prefixes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`: to be executed in your terminal, always within your virtualenv'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>>`: to be executed in your Nameko/Python shell'
  prefs: []
  type: TYPE_NORMAL
- en: 'No prefix: block of Python code to be used in your editor'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Postgres dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, all the data we wanted to store was temporary. Messages had a fixed
    lifetime and would expire automatically; if our application had a catastrophic
    failure then the worst-case scenario would be that our messages would be lost,
    which for TempMessenger is hardly an issue at all!
  prefs: []
  type: TYPE_NORMAL
- en: However, user accounts are a totally different kettle of fish altogether. They
    must be stored for as long as the user wishes and they must be stored securely.
    We also need a proper schema for these accounts to keep the data consistent. We
    also need to be able to query and update the data with ease.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, Redis probably isn't the best solution. One of the many benefits
    of building microservices is that we aren't tied to a specific technology; just
    because our Message Service uses Redis for storage doesn't mean that our User
    Service has to follow suit...
  prefs: []
  type: TYPE_NORMAL
- en: Starting a Postgres Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, you will start a Postgres Docker container in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start a Postgres container with some basic setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--name` sets the name of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e` allows us to set environment variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_PASSWORD`: The password used to access the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_DB`: The name of the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p` allows us to expose port `5432` on the container to port `5432` on our
    local machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d` allows us to start the container in daemon mode (runs in the background)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are creating a database for a production environment then it is important
    to set a more secure password and keep it safe!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check if the container is up and running by executing the following
    and ensuring that your `postgres` container is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating the user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to store data about our users in Postgres, we first need to create
    a model that will define the fields and type of data we want to store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first need to install two new Python packages: SQLAlchemy and Psycopg.
    SQLAlchemy is a toolkit and object-relational mapper that will serve as our gateway
    into the world of SQL. Psycopg is a PostgreSQL database adapter for Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding `sqlalchemy` (*version 1.2.1 at the time of writing*) and `psycopg2`
    (*version 2.7.4 at the time of writing*) to your `base.in` file. From the root
    of your project folder, within your virtualenv, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will add `sqlalchemy` and `psycopg2` to our requirements and will ensure
    that our virtualenv packages match them exactly. Alternatively, you can `pip install`
    them if you are choosing not to use pip-tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our dependencies folder, create a new file, `users.py`. Usually, you would
    have a different file for your database models, but for the purpose of simplicity
    we will embed it within our dependency. To start, let''s define our imports and
    the base class to be used by our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by importing `Column`, which will be used to declare our database
    columns, and some basic field types: `Integer` and `Unicode`. As for `declarative_base`,
    we use that to create our `Base` class, from which our User model will inherit.
    This will create the mapping between our model and a database table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define a basic model for our `users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our `User` class inherits from the Base class we defined earlier.
    `__tablename__` sets the name of the table. Let''s briefly go over some of the
    database columns we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: A unique identifier and primary key for each user in our database. It''s
    common practice for database models to have their IDs as integers for simplicity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name` and `last_name`: a maximum length of 128 characters should be
    enough for any name. We''ve also used `Unicode` as our type to cater for names
    that include symbols such as Chinese.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: Again, a large field length and `Unicode` to cater for symbols. We''ve
    also made this field unique, which will prevent multiple users with the same email
    address from being created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: We won''t be storing passwords in plain text here; we''ll come
    back to this later!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about SQLAlchemy, see [http://url.marcuspen.com/sqlalchemy](http://url.marcuspen.com/sqlalchemy).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic user model defined, we can create a Nameko dependency
    for it. Luckily for us, some of the work has already been done for us in the form
    of `nameko-sqlalchemy`, an open-source Nameko dependency that will handle all
    of the semantics around database sessions and also gives us some very useful Pyest
    fixtures for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Install `nameko-sqlalchemy` (*version 1.0.0 at the time of writing*) by adding
    it to the `requirements/base.in` file, and follow the same procedure as earlier
    to install `sqlalchemy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a wrapper class that will be used to encapsulate all of
    the logic around managing users. In `users.py`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the basis of our wrapper and will require a database session object
    in the form of `session`. Later, we will add more methods to this class, such
    as `create` and `authenticate`. In order to create our user dependency, first
    let''s add the following to our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a new class, User Store, which will serve as our dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To explain this code, first, let's talk about `DatabaseSession`. This pre-made
    dependency provider for Nameko, given to us by `nameko-sqlalchemy`, already includes
    methods such as `setup` and `get_dependency`, as covered in the previous chapter.
    Therefore, our `UserStore` class is simply inheriting from it to use this existing
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The `DatabaseSession` class' `__init__` method takes the declarative base for
    our models as its only argument. In our `UserStore` class, we override this with
    our own `__init__` method, which amends it to use our `Base` and carry out the
    same functionality as it would have originally done by using Python's in-built
    `super` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about Python''s `super` method, see: [http://url.marcuspen.com/python-super](http://url.marcuspen.com/python-super).'
  prefs: []
  type: TYPE_NORMAL
- en: The original `get_dependency` method in the `DatabaseSession` class simply returns
    a database session; however, we want ours to return an instance of our `UserWrapper`
    so that we can easily call the `create` and `authenticate` methods that we will
    make later. To override this in an elegant way so that we still keep all of the
    logic that generates the database session, we again use the `super` function to
    generate `database_session` and return an instance of our `UserWrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our Nameko dependency in place, we can start to add functionality
    to our `UserWrapper`. We will start by creating users. Add the following to the
    `UserWrapper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This `create` method will create a new `User` object, add it to our database
    session, commit that change to the database, and return the user. Nothing fancy
    here! But let's talk about the process of `self.session.add` and `self.session.commit`.
    When we first `add` the user to the session, this adds the user to our local database
    session in memory, rather than adding them to our actual database. The new user
    has been staged but no changes have actually taken place in our database. This
    is rather useful. Say we wanted to do multiple updates to the database, making
    a number of calls to the database can be expensive, so we first make all the changes
    we want in memory, then `commit` them all with a single database transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you'll notice in the preceding code is that we use `**kwargs`
    instead of defining the actual arguments to create a new `User`. If we were to
    change the user model, this minimizes the changes needed since the keyword arguments
    directly map to the fields.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the User Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we simply had two services in the same module, which is
    fine for any small-scale project. However, now that our platform is starting to
    grow and new roles are being defined between services, let's start to split these
    out by keeping them in different modules. Alongside your `service.py`, create
    a new file, `user_service.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you read the last chapter, then there is nothing new here. We've created
    a new `UserService`, given it the `UserStore` dependency and made an RPC, which
    is simply a pass-through to the `create` method on the dependency. However, here
    we have opted to define the arguments to create a user rather than use `**kwargs`
    like we did in the dependency method. This is because we want the RPC to define
    the contract it has with other services that will interface with it. If another
    service makes an invalid call, then we want the RPC to reject it as soon as possible
    without wasting time making a call to the dependency or, worse, making a database
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are close to the point where we can test this out, but first we need to
    update our `config.yaml` with our database settings. Provided you used the command
    supplied earlier to create a Docker Postgres container, append the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`DB_URIS` is used by `nameko-sqlalchemy` to map a Nameko service and a declarative
    base pair to a Postgres database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also have to create the tables in our Postgres database. Usually, you
    would do this with a database migration tool, such as Alembic. However, for the
    purposes of this book, we will use a small one-off Python script to do this for
    us. In the root of your project directory, create a new file, `setup_db.py`, with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code takes our user model in our dependency module and creates the required
    table in our database for us. `create_engine` is the starting point as it establishes
    a connection with the database. We then use our user model `metadata` (which in
    our case consists of the table name and columns) and call `create_all`, which
    issues the `CREATE` SQL statements to the database using the `engine`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to want to make changes to the User model while retaining your
    existing user data, then learning how to use a database migration tool, such as
    Alembic, is a must and I strongly recommend it.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about how to use Alembic, see [http://url.marcuspen.com/alembic](http://url.marcuspen.com/alembic).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run, in your terminal with your virtualenv simply execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take a look at our new table using a Database Admin tool. There are
    many Database Admin tools out there, my personal favorite being Postico for Mac,
    but for the purposes of this book, we will use pgAdmin, which works on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install pgAdmin from [http://url.marcuspen.com/pgadmin](http://url.marcuspen.com/pgadmin).
    Once installed, open and select Add new server, which will bring up the following
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd0efeea-239c-4f78-8e41-92e76e614c9a.png)'
  prefs: []
  type: TYPE_IMG
- en: Simply give it a name of your choice in the General tab, then in the Connection
    tab, you can fill out the details of our database with the configuration we set
    when we created our Postgres Docker screenshot earlier. However, if you did not
    make any changes to this, you can simply copy the details in the preceding image.
    Remember that the password was set to `secret`. Once you've filled this out, hit
    Save and it should connect to our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once connected, we can start to look at the details of our database. To see
    our table, you''ll need to expand out and action the menus like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f1adc41-40c7-4259-924f-9d9de30657a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should now be able to see our table, which represents our user model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/01d0e8bb-817f-4859-b394-84dd16821d1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now try out creating a user with the Nameko shell. Start our new User
    Service in the terminal by executing the following, within a virtualenv, in the
    root of our project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal window, within your virtualenv, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once in your Nameko shell, execute the following to create a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check pgAdmin to see if the user was successfully created. To refresh
    the data, simply follow the earlier steps to show the user table or click the
    Refresh button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f26eb87a-f620-4449-bb3d-aee5f70aaa38.png)'
  prefs: []
  type: TYPE_IMG
- en: It worked! We now have a functioning User Service that can create new users.
    However, there is one major issue here... We have just committed one of the worst
    offenses a software developer can commit—storing passwords in plain text!
  prefs: []
  type: TYPE_NORMAL
- en: Securely storing passwords in the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The year is 2018 and by now we've probably all heard dozens of stories about
    companies leaking our sensitive data, including passwords, to hackers. In a lot
    of these cases, the passwords that were leaked were stored with extremely poor
    cryptography, meaning that they could be cracked with ease. In some cases, the
    passwords were even stored in plain text!
  prefs: []
  type: TYPE_NORMAL
- en: Either way, this negligence has led to the leak of millions of users' email
    and password combinations. This would not be such an issue if we used different
    passwords for every online account we made... but unfortunately, we are lazy and
    password reuse is quite common practice. Therefore, the responsibility for mitigating
    some of the damage done by hackers infiltrating our servers falls to us, the developers.
  prefs: []
  type: TYPE_NORMAL
- en: In October 2016, the popular video sharing platform Dailymotion suffered a data
    breach in which 85 million accounts were stolen. Of those 85 million accounts,
    18 million had passwords attached to them, but luckily they were hashed using
    Bcrypt. This meant that it would take hackers decades, maybe even centuries, of
    brute-force computing to crack them with today's hardware (source: [http://url.marcuspen.com/dailymotion-hack](http://url.marcuspen.com/dailymotion-hack)).
  prefs: []
  type: TYPE_NORMAL
- en: So despite hackers successfully breaching Dailymotion's servers, some of the
    damage was mitigated by using a hashing algorithm, such as Bcrypt, to store the
    passwords. With this in mind, we will now look at how to implement `bcrypt` hashing
    for our user passwords, rather than storing them insecurely in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bcrypt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by adding `bcrypt` to your `base.in` file and installing it (*version
    3.1.4 at the time of writing*) using the same process as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have issues installing Bcrypt, please see their installation instructions,
    which include details on system package dependencies: [http://url.marcuspen.com/pypi-bcrypt](http://url.marcuspen.com/pypi-bcrypt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for `bcrypt` to create a hash of a password, it requires two things—your
    password and a `salt`. A `salt` is simply a string of random characters. Let''s
    look at how you can create a `salt` in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest way to create a `salt` compatible with Bcrypt. The `$`
    symbols represent different parts of the `salt`, and I''d like to point out the
    second section: `$12`. This part represents how many rounds of work are required
    to hash the password, which by default, is `12`. We can configure this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how in this `salt`, it has changed to `$14`. By increasing this, we
    are also increasing the amount of time it would take to create a  hash of the
    password. This will also increase the amount of time it takes to check the password
    attempt against the hash later on. This is useful since we are trying to prevent
    hackers from brute-forcing password attempts if they do manage to get hold of
    our database. However, the default number of rounds,  `12`, is plenty enough already!
    Let''s now create a hash of a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have simply generated a new `salt` using the default amount of rounds
    and used `hashpw` to generate the hash. Notice how the `salt` is also in the first
    part of the hash for our password? This is quite convenient as it means we don't
    also have to store the `salt` separately, which we'll need when it comes to authenticating
    users later.
  prefs: []
  type: TYPE_NORMAL
- en: Since we used the default number of rounds to generate the `salt`, why not try
    setting your own amount of rounds? Notice how the amount of time taken by `hashpw`
    increases the higher you set this. My machine took almost 2 minutes to create
    a hash when the amount of rounds was set to 20!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at how we check passwords against the hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `checkpw` takes the password attempt that we are checking and
    the hashed password as arguments. When we implement this in our dependency, the
    password attempt will be the part coming from the web request and the hashed password
    will be stored in the database. Since it was a successful attempt, `checkpw` returns
    `True`. Let''s attempt the same operation  with an invalid password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here! It returned `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to learn more about storing passwords and the pitfalls of certain
    methods, I''d suggest you read this short article from Dustin Boswell: [http://url.marcuspen.com/dustwell-passwords](http://url.marcuspen.com/dustwell-passwords).
    It explains nicely how hackers can attempt to crack passwords using brute force
    and rainbow tables. It also goes into a Bcrypt in bit more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashing our user passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to store passwords more securely, let''s amend our `create`
    method to hash our passwords before storing them in the database. Firstly, at
    the top of our `users.py` dependency file, let''s add `bcrypt` to our imports
    and add a new constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our new constant, `HASH_WORK_FACTOR` will be used for the rounds argument that
    `gensalt` uses. I've set it to 15, which will cause it to take slightly longer
    to create password hashes and check passwords, but it will be more secure. Please
    feel free to set this as you wish; just bare in mind that the more you increase
    this, the longer it will take for our application to create and authenticate users
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, outside any classes, we will define a new helper function for hashing
    passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This helper function simply takes our plain text password, generates a `salt`,
    and returns a hashed password. Now, you may have noticed that when using Bcrypt,
    we always have to ensure that the passwords we give it are bytestrings. As you''ll
    notice from the preceding code, we had to `.encode()` the password (which by default
    is UTF-8) before giving it to `hashpw`. Bcrypt also will return the hashed password
    in the bytestring format. The problem this will bring is that our field for passwords
    in our database is currently set to Unicode, making it incompatible with our passwords.
    We have two options here: either call `.decode()` on the password before we store
    it or amend our password field to something that will accept bytestrings, such
    as `LargeBinary`. Let''s go with the latter, as it is cleaner and saves us from
    having to convert our data every time we wish to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s amend the line where we import our field types to include `LargeBinary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update our `User` model to use our new field type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The only problem we have now is that our existing database is not compatible
    with our new schema. To solve this, we can either delete the database table or
    perform a migration. In real-world environments, deleting a whole table is not
    an option, ever! If you have already taken my advice earlier to study Alembic,
    then I''d encourage you to put your knowledge to the test and perform a database
    migration. But for the purposes of this book, I will take advantage of throwaway
    Docker containers and start from scratch. To do this, in the root of your project,
    and inside your virtualenv, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will delete your existing Postgres container, create a new one and run
    the `setup_db.py` script we made earlier. If you check pgAdmin, you'll now see
    that the field type in the column headers for password has changed from `character
    varying (512)` to `bytea`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we are now ready to update our `create` method to use our new `hash_password`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the first three lines of the method we:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the `plain_text_password` from `kwargs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `hash_password` to create our `hashed_password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform an update on `kwargs` to replace the password with the hashed version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the code is unchanged from our previous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out. In your terminal within your virtualenv, start (or restart)
    the User Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal window within your virtualenv, start your Nameko shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside your Nameko shell, execute the following to add a new user again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You should notice (depending on how large you set `HASH_WORK_FACTOR`) that there
    is now a slight delay compared to last time when creating a new user.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the following in your pgAdmin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eaddd97d-b99e-4dfd-b087-1933233f9805.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling duplicate users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we set our email field to be unique, our database already prevents duplicate
    users. However, if you were to try this for yourself, the output we receive back
    is not the best. Try it for yourself by adding the same user again in the Nameko
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with this is that, if there were any other errors when creating
    a new user, there is no nice way for our external services to react to these different
    types of errors without knowing the type of database we are using, which we want
    to avoid at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, let''s start by creating two new exception classes in our `users.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update our imports to include `IntegrityError`, which is the
    type of error SQLAlchemy raises when there is a unique key violation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will amend our `create` method, this time to use our two new exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here is to:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the `self.session.commit()` in a try except block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an `IntegrityError` occurs, rollback our session, which removes the user
    from our database session - not completely necessary in this case, but good practice
    nevertheless.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check to see if it contains the string `'already exists'`. If so, then we know
    that the user already exists and we raise the appropriate exception, `UserAlreadyExists`,
    and give it an error message containing the user's email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, then we have an unexpected error and raise the more generic error tailored
    to our service, `CreateUserError`, and give it the whole error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By doing this, our external services will now be able to differentiate between
    a user error and an unexpected error.
  prefs: []
  type: TYPE_NORMAL
- en: To test this out, restart the User Service and attempt to add the same user
    again in the Nameko shell.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now look at how to authenticate users. This is a very simple process:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the user we want to authenticate from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a `bcrypt.checkpw` giving it the attempted password and the password
    hash of the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raise an exception if the result is `False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the user if it's `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieving users from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with the first point, we will need to add a new dependency method,
    `get`, which returns the user, given the email, if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new exception class in `users.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we will raise in the event of the user not being found. Now we
    will update our imports to include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`NoResultFound`, as the name implies, is raised by SQLAlchemy when a requested
    object is not found in the database. Now we can add a new method to our `UserWrapper`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand what we''ve done in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to query our database, we first must make a query object using our
    user model as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have this, we can use `filter_by` and specify some parameters; in this
    case, we just want to filter by email. `filter_by` always returns an iterable,
    since you could have multiple results, but since we have a unique constraint on
    the email field, it's safe to assume that we are only ever going to have one match
    if it exists. Therefore, we call `.one()`, which returns the single object or
    raises `NoResultFound` if the filter is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We handle `NoResultFound` and raise our own exception, `UserNotFound`, with
    an error message, which better suits our User Service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticating a user's password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now implement an `authenticate` method that will use the `get` method
    we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new exception class that will be raised if there is
    a password mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create another method for our `UserWrapper` to authenticate users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by using our recently created `get` method to retrieve the user we
    want to authenticate from our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `bcrypt.checkpw` to check that the attempted password matches the
    password stored on the user object retrieved from the database. We call `.encode()`
    on the password attempt because our external services aren't going to do this
    for us. Nor should they; this is something specific to Bcrypt and such logic should
    stay in the dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the password is incorrect, we raise our `AuthenticationError` error with
    an appropriate message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All that''s left to do now is to create an RPC on our `UserService` class in
    `user_service.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Nothing special here, just a simple pass-through to the `user_store` dependency
    method we just made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this out. Restart the `user_service` and execute the following
    in your Nameko shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, it should do nothing! Now let''s try it with an incorrect password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That's it! That concludes our work on our User Service. We will now look at
    integrating it with our existing services.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to see how to write some tests for the User Service, you'll find
    them, plus all the code, in the Github repository mentioned at the start of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting out the services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As it stands, we have our `MessageServer` and `WebServer` in the same `service.py`
    module. It''s now time to split these, especially since we will be removing the
    `WebServer` in favor of a Flask server. At the end of this chapter, the goal is
    to have a total of three microservices working together, each with its own specific
    roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/57a9715d-61eb-4d8d-b15c-2dd353b3f03e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram demonstrates how our services will integrate with each
    other. Take note of how the Message Service and User Service are totally unaware
    of each other. A change to the User Service should not require a change to the
    Message Service and vice versa. By splitting these services, we also gain the
    advantage of being able to deploy new code to a single service without affecting
    the others. A bonus from Nameko using RabbitMQ is that, if a service does go down
    for a short period of time, any work will simply be queued until the service comes
    back online. We will now begin to reap some of the benefits of a microservice
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start this refactoring, let''s create a new file within our `temp_messenger`
    folder, `message_service.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All we have done here is take the `MessageService` and all related code from
    our old `service.py` and place it into our new `message_service.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Flask server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a new Flask web server, which will replace our Nameko Web
    Server. Flask is better suited to handling web requests than Nameko and comes
    with a lot more baked in while still being fairly lightweight. One of the features
    we will take advantage of is Sessions, which will allow our server to keep track
    of who's logged in. It also works with Jinja2 for templating, meaning that our
    existing template should already work.
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding `flask` to our `base.in` file, then `pip-compile` and install
    (*version 0.12.2 at the time of writing*) using the same process as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting started with Flask is quite straightforward; we will start by creating
    our new home page endpoint. Within your `temp_messenger` directory, create a new
    file, `web_server.py` , with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We import the following from `flask`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flask`: used to create our Flask app object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render_template`: renders a given template file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our `app`, the only argument being the name of our module derived from
    `__name__`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@app.route` allows you decorate a function with a URL endpoint.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this, we will be able to get our new Flask web server up and running,
    albeit with no functionality. To test this, first export some environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first will set the app to debug mode, one of the features I like about this
    as it will hot-reload when we update our code, unlike a Nameko service. The second
    simply tells Flask where our app lives.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start the Flask app, please ensure that you are not currently running
    your old Nameko web server as this will cause a port clash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within your virtualenv, execute the following in the root of our project to
    start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the Flask server on port `8000`, the same port we had our old
    Nameko web server running on. Provided your local network allows, you can even
    have other devices on the same network navigate to your machine''s IP and use
    TempMessenger! Now go to `http://127.0.0.1:8000` on your browser and you should
    see the following (albeit with no functionality):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b97a2733-ea93-46ee-9911-6cc0bd049e39.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks similar to what we had before right? That's because Flask already uses
    Jinja2 as its default templating engine, so if we want we can delete our old `jinja2.py`
    dependency as it's no longer needed. Flask also looks for a folder called `templates`
    in the same directory as the app, which is how it automatically knew where to
    find `home.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the functionality of retrieving messages from our Message Service.
    This is slightly different from when we were communicating between two Nameko
    services since Flask does not know how to perform RPC''s. First, let''s add the
    following to our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to add some config so that Flask knows where to find our
    RabbitMQ server. We could just add this in our module as a constant, but since
    we already have `AMQP_URI` in our `config.yaml`, it makes no sense to duplicate
    it! In our `web_server.py` module, before `app = Flask(__name__)`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will load all of our config variables from `config.yaml`. Now add the
    following class to `web_server.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Whereas our home page endpoint has a function-based view, here we have a class-based
    view. We've defined a `get` method, which will be used for any `GET` requests
    to this `MessageAPI`. Take note that the names of the methods are important here
    since they map to their respective request types. If we were to add a `post` method
    (and we will later), then that would map to all `POST` requests on the `MessageAPI`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ClusterRpcProxy` allows us to make RPCs outside a Nameko service. It''s used
    as a context manager and allows us to easily call our Message Service. Flask comes
    with a handy helper function, `jsonify`, which converts our list of messages into
    JSON. It''s then a simple task of returning that payload, whereby Flask handles
    the response headers and status code for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the functionality of sending new messages. First, amend your
    flask import to include request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a new post method to the `MessageAPI` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that, rather than obtaining the `request` object from the `post`
    parameters like we did with our Nameko web server, we are importing it from Flask.
    In this context, it is a global object that parses all incoming request data for
    us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `get_json`, which is an inbuilt JSON parser that will replace our `get_request_data`
    function from the last chapter. We specify that `force=True`, which will enforce
    that the request has valid JSON data; otherwise it will return a `400 Bad Request`
    error code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like our old `post_message` HTTP endpoint, we `try` to get `data['message']`
    or return a `400`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then again use `ClusterRpcProxy` to make an RPC to save the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a `204` if all went well. We use `204` rather than a `200` here to indicate
    that, while the request was still successful, there is no content to be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There''s one more thing we need to do before this will work, and that is to
    register our `MessageAPI` with an API endpoint. At the bottom of our `web_server.py`,
    outside the `MessageAPI` class, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will direct any requests to `/messages` to the `MessageAPI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to bring our Message Service back online. In a new terminal
    window and inside your virtualenv, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since we now have multiple services, this requires multiple instances running
    in different terminal windows. If one of your Nameko services is down when you
    make a request, this can cause functionality to hang indefinitely until that service
    is back online. This is a side-effect of Nameko using a messaging queue to consume
    new tasks; the task is simply on the queue, waiting for a service to take it.
  prefs: []
  type: TYPE_NORMAL
- en: Provided that you still have your Flask server running, you should now be able
    to visit our app in all its former glory at `http://127.0.0.1:8000`!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b4105130-c7d8-4265-904c-77168f84e27c.png)'
  prefs: []
  type: TYPE_IMG
- en: Web sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our old functionality back using our new Flask server, we can
    start to add some new features such as logging users in and out, creating new
    users , and allowing only logged in users to send messages. All of these depend
    heavily on web sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web sessions allow us to keep track of users between different requests via
    cookies. In these cookies, we store information that can be passed on from one
    request to the next. For example, we could store whether a user is authenticated,
    what their email address is, and so on. The cookies are signed cryptographically
    using a secret key, which we will need to define before we can use Flask''s Sessions.
    In `config.yaml`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to set your own secret key, this is just an example. In a production-like
    environment, this would have to be kept safe and secure, otherwise a user could
    forge their own session cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now need to tell our `app` to use this secret key. After `app = Flask(__name__),`
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With this done, Flask will now use our `FLASK_SECRET_KEY` from our `config.yaml`
    to sign cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sign-up page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start these new features by adding the ability for new users to sign
    up. In `web_server.py`, add the following new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This new `SignUpView` class will be responsible for dealing with the sign-up
    process. We've added a get method, which will simply render the `sign_up.html`
    template that we will create later.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `web_server.py` module, create the following URL rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you probably already know, this will direct all requests to `/sign_up` to
    our new `SignUpView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create our new template. In the `templates` folder, create a new
    file, `sign_up.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic HTML form, consisting of the fields needed to create a new user
    in our database. The  `action` and `method` forms tell it to make a `post` request
    to the `/sign_up` endpoint. All fields are `text` fields with the exception of
    password, which is of type `password`, which will cause the user input to be masked.
    We also have a Jinja `if` statement that will check to see if the template was
    rendered with an `error_message`. If so, then it will be displayed in a paragraph
    block. We will use this later to display messages such as User already exists to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes made, provided you still have the Flask server running,
    navigate to `http://127.0.0.1:8000/sign_up` and you should see the new sign-up
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/043bf8b2-c94c-429f-8581-b4f28366ad6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This form will not yet do anything, as we have not defined a post method for
    our `SignUpView`. Let''s go ahead and create that. First, update our imports in
    `web_server.py` to include `RemoteError` from Nameko and `session`, `redirect`,
    and `url_for` from Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `SignUpView` class, add the following `post` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a long method, but it''s fairly simple. Let''s go through it
    step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by retrieving all relevant fields for a user from `request.form`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then use `ClusterRpcProxy` to make a `create_user` RPC to our `user_service`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If an error occurs, handle it by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructing an error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging that message to the console using Flask's `app.logger`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the `sign_up.html` template with the error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no errors, then we continue by adding an `authenticated` Boolean
    of `True` to the `session` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the user's email to the `session` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we redirect the user using `url_for`, which will look for the function
    endpoint named `home`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we test this out, if you don''t already have the User Service running,
    in a new terminal within your virtualenv execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: With this, you should now have your User Service, Message Service and Flask
    web server running simultaneously in different terminal windows. If not, then
    start them using the `nameko` and `flask` commands from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `http://127.0.0.1:8000/sign_up` and attempt to create a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/280e4a06-0dea-45cd-97b3-c29bf62fd2ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you hit Submit, it should redirect you to the home page and you should
    have a new user in your database. Check pgAdmin to ensure that they have been
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go back to `http://127.0.0.1:8000/sign_up` and attempt to add the same
    user again. It should keep you on the same page and display the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1921cfef-7c6e-4eb9-8a32-5f82bb38520c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s all well and good having a sign-up page, but our users need to be able
    to navigate to it without knowing the URL! Let''s make some adjustments to our
    `home.html` to add a simple Sign up link. While we are at it, we can also hide
    the ability to send new messages unless they are logged in! In our `home.html`,
    amend our existing `postMessage` form to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is to wrap our form in a Jinja `if` block. If the user
    is `authenticated`, then we will show the `postMessage` form; otherwise, we will
    display a link directing the user to the sign-up page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now also have to update our home endpoint to pass the `authenticated`
    Boolean from the `session` object to the template renderer. First, let''s add
    a new helper function that gets the authenticated state of a user. This should
    sit outside any classes inside your `web_server.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This will attempt to get the `authenticated` Boolean from the `session` object.
    If it's a brand new `session` then we can't guarantee that the `authenticated`
    will be there, so we default it to `False` and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `web_server.py`, update the `home` endpoint to be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This will make a call to `user_authenticated` to get the authenticated Boolean
    of our user. We then render the template by passing it `authenticated`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another nice adjustment we can make is to only allow the user to go to the
    sign up page if they are not authenticated. To do this, we will need to update
    our `get` method in our `SignUpView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If we are authenticated, then we redirect the user to the `home` endpoint; otherwise,
    we render the `sign_up.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: If you still have the browser open that you used to create your first user,
    then if you try to navigate to `http://127.0.0.1:8000/sign_up` it should redirect
    you to the home page of our site since you are already authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: If you open a different browser, on the home page, you should see the new Sign
    up link we made and the ability to send new messages should have disappeared,
    since you have a new session.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a new issue. We have prevented users from sending new messages
    from the app, but they can still send them if they were to use Curl or a REST
    client. To stop this from happening, we need to make a small tweak to our `MessageAPI`.
    At the start of the `MessageAPI` post method, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Be sure not to adjust any of the other code; the `...` denotes the rest of the
    code from our `post` method. This will simply reject the user's request with a
    `401` response that tells the user to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Logging users out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to implement the ability for users to log out. In `web_server.py`,
    add the following `logout` function endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If a user hits this endpoint, Flask will clear their `session` object and redirect
    them to the `home` endpoint. Since the session is cleared, the `authenticated`
    Boolean will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `home.html`, let''s update our page to include the link for users to log
    out. To do this, we will add a new link just after our `postMessage` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Once saved, and provided we are logged in, we should now have a Logout link
    underneath our message form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1bbcc2f0-51be-485b-8af0-9abb6cb5f4e3.png)'
  prefs: []
  type: TYPE_IMG
- en: After clicking the Logout link, you should be redirected back to the home page,
    where you will no longer be able to send messages.
  prefs: []
  type: TYPE_NORMAL
- en: Logging users in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our app can''t be complete without the ability to log a user in! In our `web_server.py`,
    create a new class, `LoginView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Like the get in our `SignUpView`, this one will check to see if the user is
    already `authenticated`. If so, then we will redirect them to the `home` endpoint,
    otherwise, we will render the `login.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of our `web_server.py` module, add the following URL rule for the
    `LoginView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Any request to `/login` will now be directed to our `LoginView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a new template, `login.html` , inside our templates folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is quite similar to our `sign_up.html` template. We create
    a form, but this time we only have the `email` and `password` fields. We also
    have a Jinja `if` block for error messages. However, this one has a hardcoded
    error message rather than one returned from the `LoginView`. This is because it
    is bad practice to tell a user why they failed to log in. If it was a malicious
    user and we were telling them things such as *This user does not exist* or *Password
    incorrect* then this alone would tell them which users exist in our database and
    they could possibly attempt to brute-force passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `home.html` template, let''s also add a link for users to log in. To
    do this, we will add a new link in the `else` statement of our `if authenticated`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to navigate to the Login page from the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23037fa1-de70-4735-8b4a-0894a259f1f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order for our Login page to work, we will need to create a `post` method
    in our `LoginView`. Add the following to `LoginView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that this is quite similar to our `SignUpView` post method.
    Let''s briefly go over what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve the email and password from `request.form`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `ClusterRpcProxy` to make an `authenticate_user` RPC to the `user_service`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a `RemoteError` occurs, then we:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Flask's `app.logger` to log the error to the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the `login.html` template with `login_error` set to `True`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they authenticate successfully, we set `authenticated` to `True` in the `session`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set email to the user's `email` in the `session` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redirect the user to the `home` endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the preceding code, rather than return the error message to the user, we
    choose to log the error message to the console where only we can see it. This
    allows us to see if there are any issues with our authentication system or if
    a malicious user is up to no good, while still letting the user know that they
    supplied invalid information.
  prefs: []
  type: TYPE_NORMAL
- en: Provided our services are all still running, you should now be able to test
    this out! We now have a fully functioning authentication system for TempMessenger
    and our goals are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Prepending the email to our messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that our TempMessenger is missing is accountability. We have no idea
    which users are posting what, which is fine for an anonymous messaging application
    (and if that is what you want, then skip this section altogether). To do this,
    when we store our messages, we will want to also store the email of the user who
    sent it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by revisiting the `messages.py` dependency. Update `save_message`
    in our `RedisClient` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you'll notice is that, in order to call `save_message`, we now
    require the user's email.
  prefs: []
  type: TYPE_NORMAL
- en: What we have also done here is to change the format of the data we are storing
    in Redis from a string to a hash. Redis hashes allow us to store dictionary-like
    objects as the value. They also have the added benefit of being able to pick which
    key from the dictionary we want to get back out later, as opposed to getting the
    whole object out.
  prefs: []
  type: TYPE_NORMAL
- en: So here we create a dictionary of the user's email and password and use `hmset`
    to store it in Redis. `hmset` does not have a `px` or `ex` argument, so instead
    we make a call to `pexpire`, which expires the given key for the given number
    of milliseconds. There is also an `expire` equivalent of this for seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about Redis hashes and other data types, see: [http://url.marcuspen.com/redis-data-types](http://url.marcuspen.com/redis-data-types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now update our `get_all_messages` method in the `RedisClient` to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Since the data has changed to a hash, we also have to retrieve it from Redis
    differently, using the `hget` method. We also get the email corresponding to each
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will move on to `message_service.py`. Within the `MessageService`, update
    the `save_message` RPC to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: All we have done here is update the arguments for the RPC to include `email`
    and pass that to the updated `message_store.save_message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `web_server.py`, we will need to update the `MessageAPI` post method
    to send the user''s email when it makes the RPC to the `MessageService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Two small changes we have just made:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the `email` from the `session` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the RPC to also pass the `email`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to see these changes on our page, we will also need to update the
    `home.html` template. For our JavaScript function, `updateMessages`, update it
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is a minor tweak. If you can't spot it, we've updated the `messageList.push`
    to include the `email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you test this, ensure that your Redis store is empty, as old messages
    will be in the old format and will break our app. You can do this by using `redis-cli`
    inside of our Redis container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, be sure to restart our Message Service so that it takes the new changes
    into effect. Once you have done that, we can test this new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5069299d-f391-4c07-9735-07bb57c96d62.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This now concludes our work on the TempMessenger User Authentication system.
    We started this chapter by using a Postgres database with Python and created a
    Nameko Dependency to encapsulate it. This was different from our Redis dependency
    from the last chapter since the data is permanent and required a lot more planning.
    Despite this, we tucked this logic away and simply exposed two RPC''s: `create_user`
    and `authenticate_user`.'
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how to securely store user passwords in a database. We explored
    some of the ways you can do this incorrectly, such as by storing passwords in
    plain text. We used Bcrypt to cryptographically hash our passwords to prevent
    them from being read if our database was compromised.
  prefs: []
  type: TYPE_NORMAL
- en: When it came to linking the new User Service to the rest of our application,
    we first split out each service into its own module to allow us to deploy, update,
    and manage them independently. We reaped some of the benefits of a microservice
    architecture by showing how easy it was to replace one framework (Nameko) with
    another (Flask) in the Web Server without affecting the rest of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the Flask framework and how to create function-based and class-based
    views. We also looked at Flask session objects and how we could store user data
    from one request to the next.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, we amended our message list to also include the email address of
    the user who sent it.
  prefs: []
  type: TYPE_NORMAL
- en: I'd encourage you to think of new enhancements to make for TempMessenger and
    plan accordingly how you would add them, ensuring that logic from our dependencies
    does not leak outside the service it belongs to—a mistake made by many! Keeping
    our service boundaries well defined is a hard task and sometimes it helps to start
    off with a more monolithic approach and separate them out later once they are
    clear. This is similar to the approach we took with `MessageService` and `WebServer`
    from the last chapter. *Building Microservices* (O'Reilly) by Sam Newman explains
    this very well and also covers in more detail the benefits, drawbacks, and challenges
    associated with building distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter complete, I hope I have given you a deeper insight into how
    you can benefit from a Microservice architecture in practice. The journey we took
    creating this application was purposely modular, not only to reflect the modularity
    of microservices but to demonstrate how we should go about adding new features
    with minimal impact to the rest of the platform.
  prefs: []
  type: TYPE_NORMAL
