- en: '*Chapter 6*: Setting Up Our Project Using create-react-app and Testing with
    Jest'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about the tools that help us build React applications.
    High-level, professional application development, regardless of the language or
    framework, always involves using tooling to help build applications faster and
    with higher code quality. The React development ecosystem is no different. A community
    has gathered around certain tooling and coding methodologies and we will go over
    those in this chapter. These sophisticated tools and methods will help us code
    better applications and help us refactor our code to adapt it to new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning React development methods and about the build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding client-side testing for React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning common tools and practices for React development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of web development and the SPA style of
    coding that we've been learning in the previous chapters. We will once again be
    using Node (npm) and VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in folder `Chap6`.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the [*Chapter 6*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091)
    code folder on your own machine, go to your `HandsOnTypescript` folder and create
    a new folder called `Chap6`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning React development methods and about the build system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the tools and practices used for coding
    and building React applications. Many of these methods are used in general for
    modern JavaScript development, even in competing frameworks such as Angular and
    Vue.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build large, complex applications, we need tools – lots and lots
    of tools. Some of these tools will help us write better quality code, some will
    help us share and manage our code, and still others will exist only to enhance
    developer productivity and make it easier to debug and test our code. Therefore,
    by learning the tooling used to build modern React apps, we will ensure our application
    works as it should with minimal issues.
  prefs: []
  type: TYPE_NORMAL
- en: Project tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen from the prior chapters, modern React development uses many components
    to build a final application. For project structure and base dependencies, most
    developers will use `create-react-app`, which is based on the development tools
    first created for Node development (npm). We've already seen what `create-react-app`
    can do, but in this section, we'll take a deeper look.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to understand how we arrived at using the current state of
    the art in tools and coding. This knowledge will help us better understand why
    a shift to this current style was made and what the benefits are.
  prefs: []
  type: TYPE_NORMAL
- en: How it was done before tooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The web is actually a hodgepodge of different technologies. HTML came first,
    to create text sharing capabilities. Then CSS, for better styling and document
    structure. And then finally, JavaScript, to add some event-driven capabilities
    and programmatic control. So, it''s no wonder that sometimes integrating these
    technologies into a single coherent application can feel awkward and even difficult.
    Let''s look at some examples of bringing these pieces together without using much
    tooling:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your terminal or command line to the `Chap6` folder. Create a new folder
    called `OldStyleWebApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using VS Code create an HTML file called `index.html` and add this code into
    it. We''ll create a simple input and display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create a `.css` file called `core.css` in the same folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `.js` file called `script.js` in the same folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll fill in the CSS and JS files later, but immediately we have an
    issue. How do I run this app? In other words, how do I see it run so I can check
    whether it''s working? Let''s see what we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: In your VS Code, right-click on the `index.html` file and copy its path like
    this:![Figure 6.1 – Copy index.html
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Copy index.html
  prefs: []
  type: TYPE_NORMAL
- en: Now, open your browser and paste this file path into the URL. You should see
    the following:![Figure 6.2 – index.html in the browser
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – index.html in the browser
  prefs: []
  type: TYPE_NORMAL
- en: You may not have already known this, but you do not need an HTTP server in order
    to view HTML files in your browser. However, you can see this process isn't the
    most efficient and it would be better if it could be automated, including auto-refreshing
    when I make changes to any related files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fill in our CSS file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that even if I save this file, the `label` element on the web
    browser does not automatically update. I have to refresh my browser and then it
    will update. What if I have dozens of files that get updated during my development
    session? Having to manually refresh each time would not be a good experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add some code to `script.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We want to read this code carefully as there are multiple issues with it. Let's
    see what those issues are. If we save this file, open the browser debugger tools,
    and then refresh the browser, you can see that it fails immediately with this
    error in the `create-react-app` project tooling. `create-react-app` projects have
    what's called a linter. A linter is a code checker tool that runs in the background
    as you're writing your code. It will check for common errors, such as the one
    we just saw, so that it they do not end up in your production code. There's a
    lot more functionality to linters, but we will explore them more deeply later.
    The point here is we want to avoid these types of errors before running the app.
    And `create-react-app`, or in this case some of the built-in tooling, can help
    us do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try adding the correct variable name and try reloading the browser again.
    Update the `script.js` file like this, save it, and then reload the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the debugger console, the log statement does not find the
    `inputEl`, as it returns `null`. This is happening because we mistyped the `id`
    of the `input` element as `"userNam"` instead of `"userName"`. Now, again, with
    the `create-react-app` project running, this sort of error is simply not possible,
    because the vast majority of React code does not attempt to query or look for
    elements in our HTML page. Instead, we use React components directly and therefore
    we can avoid this class of error altogether. Admittedly it is possible to opt
    out of this behavior and use a reference to HTML elements via `useRef`. However,
    this is something that should be done sparingly, as you are deliberately exiting
    out of the normal React ecosystem behavior by using this Hook and therefore losing
    its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix our `script.js` file and complete it. Update it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code by refreshing the browser, you will see that if you type
    your name into the input box and then click out of the input element, a message
    will display like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Welcome display'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Welcome display
  prefs: []
  type: TYPE_NORMAL
- en: So, this code does work to display a welcome message. However, it's easy to
    make mistakes, and not have any help indicating why. In addition to this, notice
    that we have no TypeScript since browsers don't run TypeScript; they can only
    run JavaScript. This means we are also missing the type indicators that are also
    helpful in avoiding bugs related to incorrect types.
  prefs: []
  type: TYPE_NORMAL
- en: So, we've seen some of the issues around doing things in the original web way.
    But the reality is we haven't even scratched the surface of issues with doing
    development in this manner. For example, having script tags embedded in our HTML
    is a reasonable thing to do when we have only a few scripts to deal with. But
    what about when our dependencies grow? For larger apps, it is quite possible to
    have hundreds of dependencies. Managing that many script tags would be very difficult.
    And not only that – a lot of JavaScript dependencies no longer provide a URL from
    which they can be called.
  prefs: []
  type: TYPE_NORMAL
- en: Having said all this, perhaps one of the biggest issues is the highly free-form
    nature of the code. If you look at the `script.js` file again, you can see there
    is no pattern or structure to the code. Sure, it is likely your team could come
    up with a pattern on its own, but what about new programmers joining the team?
    They would have to learn a unique way of structuring the code that is specific
    to your team.
  prefs: []
  type: TYPE_NORMAL
- en: So, the point is tooling, frameworks, and structure provide consistent, repeatable
    ways of writing and maintaining code. You can consider it a sort of culture of
    programming, where everyone has accepted the norms and practices of the culture
    and therefore knows what to do and how to behave. This makes code easier to write,
    share, and refactor. Now that we've taken a look at free-form coding, let's start
    looking at `create-react-app` more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: create-react-app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In prior chapters, such as [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, and [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development with Hooks*,
    we used `create-react-app` to set up our base application project. Let's look
    more closely at what is inside a `create-react-app` project. To better understand
    the parts that make up a `create-react-app` project, we need to `eject` it first.
    Here, eject simply means that we will reveal all of the internal dependencies
    and scripts that make `create-react-app` work, as normally these are hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning: Ejection is a non-reversable action'
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, you will not eject a `create-react-app` project,
    as there is little value in doing so. We are doing it here only to gain more insights
    into how this project works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project inside of the `Chap6` folder by executing the following
    command from inside that folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s eject the project. Change directories in your command line to the
    new `ejected-app` folder and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then enter `y` at the prompt to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this project from the top of the VS Code explorer menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This folder contains most of the configuration files and scripts that the project
    uses to set itself up. The main thing to note is that the React team by default
    uses **Jest** for testing and **Webpack** for the bundling and minification of
    JavaScript files. We'll discuss Jest in the *Understanding client-side testing
    for React* section, and Webpack is discussed later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you know, this folder contains our project's dependencies. As you can see,
    even before we add our own dependencies, the default set of dependencies is vast.
    It would be quite difficult to try and use HTML script tags to list out these
    dependencies. And in most cases, these dependencies don't support script tag references.
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This folder contains static assets that are used in generating our single-page
    application. This includes our one HTML file called `index.html`, the `manifest.json`
    file that is needed if we are building a PWA application. It is also possible
    to add additional files such as image files for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scripts` folder contains scripts that are used to manage the project, for
    example, scripts that build, start, or kick off tests of the application. Actual
    test files should not be added here. We'll cover testing later, in the *Understanding
    client-side testing for React section*.
  prefs: []
  type: TYPE_NORMAL
- en: '`src`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is, of course, the folder that contains the source files of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '`.gitignore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gitignore` is a file that tells the Git source code repository system which
    files and folders not to track. We will dive deeper into Git later in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in prior chapters, npm is the dependency management system originally
    created for use with the Node server framework. The capabilities and popularity
    of this dependency manager eventually made it a standard for client-side development
    as well. So, the React team uses npm as its base system for project creation and
    dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: On top of listing dependencies for projects, it can also list scripts that can
    be run to manage a project.
  prefs: []
  type: TYPE_NORMAL
- en: It also has configuration capabilities for things such as Jest, ESLint, and
    Babel.
  prefs: []
  type: TYPE_NORMAL
- en: '`Package-lock.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a related file that helps maintain a proper set of dependencies and
    sub-dependencies regardless of their order of installation. We don't need to work
    with this file directly, but knowing that this helps prevent issues when different
    developers update their `npm_modules` folder at different times with a different
    set of existing dependencies is good knowledge to have.
  prefs: []
  type: TYPE_NORMAL
- en: '`tsconfig.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already reviewed this file in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*, and as mentioned in that chapter, it contains the settings
    for the TypeScript compiler to use. Note that, in general, the React team prefers
    stricter compilation settings. Also notice that the target JavaScript version
    is ES5\. This is because some browsers are not compatible with ES6 yet.
  prefs: []
  type: TYPE_NORMAL
- en: '`create-react-app` also contains two very important tools that enable some
    of its functionality: Webpack and ESLint. Webpack is a bundling and minification
    tool that automates the task of gathering all of the files that make up a project,
    removing any extraneous, unused pieces, and consolidating them into a few files.
    By removing extraneous pieces, such as white spaces and unused files or scripts,
    it can drastically lower the file sizes that must be downloaded by user browsers.
    This, of course, enhances the user experience. In addition to this core functionality,
    it provides a "hot reloading" development server, which can allow certain script
    changes to automatically show in the browser without needing a page refresh (although
    most changes do seem to trigger browser refreshes, but at least those are automated).'
  prefs: []
  type: TYPE_NORMAL
- en: ESLint is also an important tool. Since JavaScript is a scripting language and
    not a compiled language, it does not have a compiler that will check syntax and
    code validity (obviously, TypeScript does but the TypeScript compiler focuses
    primarily on typing issues). So, ESLint provides development-time code checking
    to make sure it is valid JavaScript syntax. And in addition, it allows for the
    creation of custom code-formatting rules. These rules are generally used to ensure
    that everyone on the team is coding using the same style; for example, variable
    naming conventions and bracket indentation. Once rules are set up, the ESLint
    service will enforce these rules with warning messages.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are not just specific to JavaScript, but they can also be rules around
    how to write code for frameworks such as React. So, for example, in a `create-react-app`
    project, the ESLint setting is `react-app`, as shown in `package.json`, which
    is a set of coding rules specific to React development. So, many of the messages
    we will see are not necessarily JavaScript errors but rules around best practices
    for coding React apps.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack, although extremely powerful, is also enormously difficult to set up.
    And creating custom rules for ESLint can take a very long time to do. So, fortunately,
    another benefit of using `create-react-app` is that it provides us with good default
    configurations for both of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Transpilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We introduced transpilation in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*. However, we should cover it a little more deeply in
    this chapter since `create-react-app` depends on transpilation for much of its
    code generation. `create-react-app` allows us to use TypeScript or Babel so that
    we can develop code in one language or language version and emit code as a different
    language or language version. Here''s a simple diagram showing the flow of code
    during the transpilation of TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Transpilation from TypeScript to JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Transpilation from TypeScript to JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler will search your project and find all the `ts` or `tsx`
    files inside of the root code folder, usually `src`. If there are errors, it will
    stop and let us know, otherwise, it will parse and convert the TypeScript into
    pure JavaScript as `js` files and that is what is run on systems. Notice in the
    diagram we are also changing the JavaScript version as well. So, transpilation
    is a lot like compilation. Code is checked for validity and some classes of bugs,
    but instead of being converted into byte code that can be run directly, it is
    converted into a different language or language version. Babel is also capable
    of emitting JavaScript and working with TypeScript developer code. However, I
    prefer to use the original TypeScript compiler, as it is made by the same team
    that designs TypeScript and is usually more up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing transpilation as the method of compilation has multiple important benefits.
    For one, developers do not need to worry whether their code will run on a browser,
    or whether the user would need to either upgrade or install a bunch of dependencies
    on that machine first. The TypeScript compiler emits web standard ECMAScript (ES3,
    ES5, ES6, and so on) and therefore the code can be set to run on any modern browser.
  prefs: []
  type: TYPE_NORMAL
- en: Transpilation also allows developers to take advantage of newer versions of
    JavaScript before their final release. Since JavaScript is on an almost annual
    update cycle, this feature can be extremely useful in terms of taking advantage
    of new language features or performance capabilities; for example, when a new
    feature of JavaScript is being considered. The ECMA foundation, the standards
    body that maintains the JavaScript language, goes through several stages before
    accepting changes into an official version of JavaScript. But the TypeScript and
    Babel teams will sometimes accept new JavaScript features when they are still
    in one of these earlier stages. This is how many JavaScript developers were able
    to use async-await in their code before it became an official standard.
  prefs: []
  type: TYPE_NORMAL
- en: Code repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A code repository is a system that allows the sharing of source code among multiple
    developers. Code can be updated, copied, and merged. For large teams, this tool
    is absolutely necessary for building complex applications. The most popular modern
    source code control and repository is Git. And the most popular online repository
    host is GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Although thoroughly learning Git is beyond the scope of this book, it is important
    to understand some of the basic concepts and commands, as you will need them when
    interacting with other developers and maintaining your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more important concepts of any code repository is that of branching.
    This means the ability to indicate multiple versions of a project. For example,
    these branches could be for the version numbers of a project, such as 1.0.0, 1.0.1,
    and so on. It could also be for creating separate versions of an app where perhaps
    some experimental or high-risk code is being tried out. It would not be a good
    idea to place such code into the main branch. Here''s an example of the React
    GitHub page and its many versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – React GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – React GitHub
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many branches. The current stable branch, although
    not visible in this screenshot, is usually called the master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, learning Git well would require a book of its own, so here I''ll just
    go over some of the main commands that you would use daily:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git`: This command is the Git `git` command, you are working on a local copy
    of the repository; you are not directly working on the online repository or affecting
    your teammates'' repositories until you push your changes onto the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone`: This command allows you to copy a repository onto your local machine.
    Note that when you clone, generally, you will default to the master branch. Here''s
    an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`checkout`: This subcommand allows you to change your working branch to a different
    desired branch. So, if you wanted to work in another branch other than the master,
    you would use this command. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`add`: This subcommand adds the files you recently changed as needing to be
    tracked, which indicates you will later commit them into the repository. You can
    do all your changed files in one shot by using `.` after `add` or indicate the
    files explicitly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`commit`: This subcommand indicates that you will eventually update your working
    branch with the files that you just added locally. If you add the `-m` parameter,
    you can add a label inline to describe your commit. This command helps team members
    track which changes were done in each commit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`push`: This subcommand does the actual moving of local committed files into
    the remote repository:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we covered some of the core project tools available for React
    developers. `create-react-app`, ESLint, Webpack, and npm provide invaluable features
    that make development more efficient and less error-prone. We also covered transpilation,
    to understand how we can take advantage of newer language versions, without compromising
    compatibility, on end user devices.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we took a quick look at Git. Currently, it is the most popular
    code-sharing repository. As a professional developer, you will most certainly
    end up using it for projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some important core tools knowledge, we'll continue in the
    next section by discussing testing. Modern development practices make heavy use
    of testing and test frameworks. Fortunately, JavaScript has great testing frameworks
    to help us write good-quality tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding client-side testing for React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a very important part of development. These days, no large projects
    will be written without some level of unit testing. The purpose of tests is to
    ensure that your code is always working correctly and doing the expected things.
    This is especially true when code is modified, that is, refactored. In fact, it
    is probably more difficult to change existing complex code than it is to create
    brand-new code. Unit testing can prevent breaking existing code during refactoring.
    But if code does break, it can also help pinpoint the exact place where code no
    longer works so it can be fixed quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, previously, there were two main testing libraries that were commonly
    used: `create-react-app`. So, for this book, we will be learning about Jest and
    testing-library.'
  prefs: []
  type: TYPE_NORMAL
- en: All unit tests work in the same way. This is true not only for React and JavaScript
    tests, but tests in any language will work in the same manner. So then, what is
    a unit test? A unit test attempts to test one specific portion of code and it
    attempts to assert that something about it is true. That's basically it. To put
    it another way, it means that the test is checking to see whether something expected
    is indeed the case. If it is not, then the test should fail. Although this goal
    is simple, creating high-quality tests is not. So, we'll go over some examples
    here, but please keep in mind that large-application testing can be as complicated
    if not more so than the actual code for creating the app. So, it will take some
    time for you to become proficient in writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things clearer, let''s take a look at a simple test. Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to VS Code and open the file at path `ejected-app/src/App.test.tsx`. This
    is a test for the `App` component. We'll go over the contents of the test in just
    a moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your terminal to `ejected-app` and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 6.7 – Test run options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Test run options
  prefs: []
  type: TYPE_NORMAL
- en: 'If your tests did run or you selected `a`, you should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Tests completed successfully'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Tests completed successfully
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our tests have automatically been found and run (although, currently,
    we only have one). And in this run, the one test is successful, meaning what was
    expected did occur. If any failed, the same UI would indicate how many tests failed
    and how many succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the test in `App.test.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you will notice the filename has the text `test` in it. This is what
    tells Jest that this is a test file. Some teams like to place all their tests
    into a single folder. Some teams prefer to have the test right next to the actual
    file being tested, as in this case. There is no right answer. Do what works best
    for you and your team. In this book, we will put our tests right next to the file
    being tested. Let''s take a look at the contents of our `test` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice among the imports that we have a reference to `@testing-library/react`.
    As mentioned, this library will give us some extra tooling to make the testing
    of the component output easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, notice the `test` function. This function acts as an encapsulated wrapper
    for our single test. This means that all the things relative to this one test
    live inside this function and cannot be accessed from outside of it. This ensures
    that our test is not impacted by other tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter of this function is a description. Descriptions are totally
    arbitrary, and your team will have its own standard for how these descriptions
    should be written. The only thing we need to focus on is making the description
    brief but clear about what is being tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is a function that runs the actual test. In this case,
    the test is checking whether a certain specific text appears within the emitted
    HTML of our `App` component. Let's go over the code line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On *line 6*, we run `render`, passing it the `App` component. This `render`
    function executes our component and gets back certain properties and functions
    that allow us to test the emitted HTML. In this case, we decide only to receive
    the function `getByText`, which simply means to return an element that has certain
    text in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *l**ine 7*, we get our HTML DOM element by calling `getByText` with the parameter
    `/learn react/i`, which is syntax for running a regular expression, but in this
    case, it's hardcoded for text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, on *line 8*, an assertion is made called `expect`, which expects the
    element object called `linkElement` to be in the DOM using the `toBeInTheDocument`
    function. So, an easy way of understanding tests in general is to read their assertions
    like a sentence. For example, we can read this assertion like this, "I expect
    the linkElement to be in the document" (the document is, of course, the browser
    DOM). By reading it this way, it's pretty clear what is intended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we change the code a bit. Update `App.tsx`
    with the following (I''m only showing the `App` function for brevity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you save this file, you should immediately see an error like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Error after changing App.tsx'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Error after changing App.tsx
  prefs: []
  type: TYPE_NORMAL
- en: Again, the test runner is running in watch mode so you should see the test results
    as soon as you save your change. As you can see, our test fails because the text
    `learn react` was not found and therefore the assertion `expect(linkElement).toBeInTheDocument()`
    is not true.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so we''ve taken a look at a built-in test that `create-react-app` provided.
    Let''s now create a new component so we can write our own tests from scratch.
    Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s leave our test running in watch mode, even though it''s showing an error,
    and create a new terminal window by clicking the plus button at the upper-right
    side of the terminal window in VS Code. The button is the plus sign shown here:![Figure
    6.10: Plus sign for a new terminal'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Plus sign for a new terminal'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file called `DisplayText.tsx` in the `src` folder and add
    this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This component will simply display a new message after someone enters their
    name into the input and clicks the `DisplayText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create some state necessary for the workings of our component and event
    handlers to deal with new text and the display of our message (we''ve already
    covered how to create a React component in [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081),
    *React Development with Hooks*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return our UI, which includes an input and a submit button. Note
    the `data-testid` attributes to allow elements to be easily found by our tests
    later. If you run this code and enter your name and click the button, you should
    see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – New component for testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – New component for testing
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our display simply returns the entered text with a welcome message.
    However, even this simple example has several different things to test. For one,
    we would like to make sure that there is text entered into the input and that
    it is words and not numbers or symbols. We also want to make sure that when we
    click the button, the message is displayed and that it starts with the string
    `"Welcome to React testing"` and ends with the user's input text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our component, let''s build our test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be aware of a small issue in our `tsconfig.json` file. As I stated
    earlier, you can place your tests inside of a separate folder, usually called
    `__test__`, or you can place it side by side with your component file. We will
    be placing it side by side for convenience. If we do so, we will need to update
    our `tsconfig.json` file to include this `compilerOption`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the test file for this component by creating a new file called `DisplayText.test.tsx`
    and add this initial code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: From the top, you'll notice we have imported `render` from `@testing-library/react`
    and we've also imported the `@testing-library/jest-dom/extend-expect` extension,
    which allow us to do assertions. The extensions of the `expect` keyword give us
    additional functions that allow us to test in more ways. For example, we are using
    `toHaveValue` to get the value of `input`.
  prefs: []
  type: TYPE_NORMAL
- en: After the imports, you'll notice some new syntax. `describe` is, as the name
    implies, simply a way to create a grouping container with a helpful label. This
    container can have more than one test, but these tests should all be related to
    testing a specific component or feature. In this case, we are trying to test the
    `DisplayText` component so all the tests within `describe` will be testing only
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our first test is started using the function called `it`. This function
    checks that our component, `DisplayText`, can be rendered out as HTML without
    crashing or erroring out. The `render` function attempts to do the rendering and
    the `expect` and `toBeInTheDocument` functions determine whether the rendering
    was a success by checking whether it is in the DOM. As an experiment, add this
    code, `console.log(baseElement.innerHTML)`, within the first test `it` function
    below the line starting with `const { baseElement }`. You should see this HTML
    string in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Log: resultant test HTML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create one more test to show an end-to-end test of our component.
    Add the following code after our second `it` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This test is similar to our second test in that it adds a value within our `input`,
    but then it goes on and gets our `button`, and then our `label`. It then creates
    a `click` event to simulate a button press that in regular code would cause our
    `label` to be populated with our welcome message. It then tests the contents of
    our `label`. Again, once you save this file, our tests should rerun and all of
    them should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s also look at something called snapshots. Obviously, a big part
    of React development is not just the behavior or actions available within our
    app, but the actual UI presented to our users. So, by doing snapshot testing,
    we are able to check that the desired UI, HTML elements, are indeed created by
    our components. Let''s add this code to our tests after our "renders without crashing"
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our `render` function is set to return the root most element
    of the `DisplayText` component by using the `baseElement` property. In addition,
    we can see that we have a new `expect` function called `toMatchSnapshot`. This
    function does a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: The first time it runs, it creates a folder called `__snapshot__` at the root
    of our `src` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then adds or updates a file that has the same name as our test file and ends
    with the extension .`snap`. So, in this case, our test file snapshot file would
    be `DisplayText.test.tsx.snap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The contents of this snapshot file are the emitted HTML elements of our component.
    So the snapshot you have should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is an exact duplicate of our desired HTML as emitted by
    our `DisplayText` component. Notice also the description given and the indication
    that it is `snapshot 1`. As you add more, the number will increment.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now we have a snapshot and our first test run has succeeded. Let''s
    see what happens if we change our `DisplayText` JSX. Update the `DisplayText.tsx`
    file, not your test file, like this (I''ll just show the component definition
    for brevity''s sake):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code remains entirely the same, however, in the `return`, we
    add a dummy `div` tag as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And after selecting `u`, our snapshot file should update successfully and our
    snapshot test should complete. If you open your local snapshot file, you should
    see the same new `div` tag we added to our component earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So now we've seen some simple tests to help us get started. Next, we'll get
    introduced to the topic of mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking is simply replacing specific functionality in our test with default
    values. An example of mocking could be to only pretend to make a network call
    but instead return a hardcoded value. The reason we want to do this is we want
    to only test a single unit or a small piece of our code. By mocking some portions
    of our code that are not specific to what we are testing, we are avoiding confusion
    and making certain our test works consistently. For example, if we were trying
    to test input in our code, we wouldn't want a network call failure to affect the
    result of that test, because a network call has nothing to do with the input element
    specifically. When we want to do end-to-end testing or integration testing, we
    can worry about the network call as well. But that is a different animal from
    unit testing (in some teams, integration testing is handled by the QA team separately)
    and we won't cover it here. Now, when it comes to React components, testing-library
    actually recommends against mocking, because this effectively makes our test less
    like actual code. Having said that, sometimes mocking can still be helpful to
    do, so I will show how to mock components as well.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking with jest.fn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s learn about mocking with Jest as it is also used with Node development.
    The first way to do mocking in Jest is to mock a specific function using `fn`.
    This function takes another function as a parameter that will do whatever you
    need to be done to set up your desired mock. But also, in addition to this ability
    to replace arbitrary existing code and values, creating a mock will give you access
    to a member called `mock`. This member provides metrics about your mock call.
    This is difficult to conceptualize so let''s create an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `DisplayText` component to make a network call to a web API.
    We will use the `DisplayText` that is a function that returns a user''s full name
    based upon their username. We need to first update the `App` function file like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the updated `DisplayText` component code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <form>
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <label>Enter your name</label>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <input data-testid="user-input"                   value={txt}
  prefs: []
  type: TYPE_NORMAL
- en: onChange={onChangeTxt} />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <button data-testid="input-submit"
  prefs: []
  type: TYPE_NORMAL
- en: onClick={onClickShowMsg}>Show Message</                  button>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <label data-testid="final-msg" >{msg}</                 label>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: export default DisplayText;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 6.15 – User''s full name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – User's full name
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the full name of the user with the username **bret** is **Leanne
    Graham**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write our test and mock out our network call using Jest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `DisplayText.test.tsx` and notice that all our tests are failing since
    none of them will have the new property `getUserFullname`. So, let''s update our
    test and mock this function. Here are the new tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: afterEach(cleanup);
  prefs: []
  type: TYPE_NORMAL
- en: 'userFullName and getUserFullnameMock. Since we will be running our mock function
    in several tests, we are creating the getUserFullnameMock function so that we
    can reuse it to give us our mock function getUserFullname and a few other needed
    items.But then the question may be why do they look so complicated? Let''s go
    through the code and figure out what it''s doing: *   After we set the `userFullName`,
    variable we create the `getUserFullnameMock`. function As you can see, the `getUserFullnameMock`
    function takes a `username` as a parameter, just like the real `getUserFullname`
    function, and returns a `promise` and a `Mock` object. *   Inside of `getUserFullnameMock`,
    the definition instantiates a `promise` object and it mocks our `getUserFullname`
    function by using `jest.fn`. We need a promise to simulate a network call and
    also to `await` on it later with the `wait` call from testing-library.*   As mentioned,
    `jest.fn` is used to instantiate a mock and have the mock do whatever it is that
    we may need. In this case, since the `getUserFullname` function we are mocking
    is making a network call, we need to have our `jest.fn` mock return a promise.
    And it does so by returning the `promise` we created on the line immediately above
    it.*   And then, finally, both the `promise` and the new mock function, `getUserFullname`,
    are returned. *   We are going to quite a bit of trouble here, but in this case,
    it is a good idea to eliminate the use of a slow and error-prone network call.
    Otherwise, if the network call fails, we may incorrectly believe our test and
    code have failed.*   Next, let''s see how our mock is used within our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The last test is updated since it tests the welcome message. Update your last
    test like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So by using `jest.fn`, we can mock out a piece of code so that it can give us
    a consistent value. Again, this helps us create consistent, reproducible tests
    where we are testing only a specific unit of code.
  prefs: []
  type: TYPE_NORMAL
- en: Component mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second form of mocking is to replace whole components entirely and use
    them in place of real components when we want to test other code. In order to
    test this, follow the steps given here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our `DisplayText` component show a list of user todos based on
    the inserted username. Update the component like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve created some state to use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we update our input with the value of the username given by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once the **Show Message** button is clicked, we update the message to be displayed
    as well as the list of todos to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to accept a prop to use as our message prefix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly to how we got the user''s `fullname` by using their `username`, we
    get the user''s list of todos by calling the JSONPlaceholder API. First, we find
    the user by calling into the users collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Then we call into the todos collection and match the todos to the previously
    found user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we return an unordered list of todos via the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 6.16 – List user todos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – List user todos
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are displaying the user bret's list of todos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pretend we wanted to test our `DisplayText` component without testing
    this list of todos. How could we refactor this code so that our test wouldn''t
    be so monolithic? Let''s refactor our `DisplayText` component and pull out the
    todos capability as its own component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `DisplayText` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'const onClickShowMsg = async (e:'
  prefs: []
  type: TYPE_NORMAL
- en: React.MouseEvent<HTMLButtonElement, MouseEvent>) =>         {
  prefs: []
  type: TYPE_NORMAL
- en: e.preventDefault();
  prefs: []
  type: TYPE_NORMAL
- en: setTodoControl(null);
  prefs: []
  type: TYPE_NORMAL
- en: setMsg(`Welcome to React testing, ${await
  prefs: []
  type: TYPE_NORMAL
- en: getUserFullname(txt)}`);
  prefs: []
  type: TYPE_NORMAL
- en: 'onClickShowMsg event handler will call setTodoControl and pass our UserTodos
    component the username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create our new `UserTodos` component. Create a file called `UserTodos.tsx`
    and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now taking the username as a prop from our parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we grab our users again from the users collection and filter to find
    our one user by matching the `username`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we grab the matching todos of the found user. We then run the JavaScript
    `map` function to create a collection of `li` elements for each todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `useEffect`, we are indicating that any time our `username` prop changes,
    we want to update our list of todos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we output our todos as unordered list elements. If you run this
    code, you should see this once you click **Show Message**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Refactored todos'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Refactored todos
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now we can add a new test that mocks out our `UserTodos` component and
    therefore allows `DisplayText` to be tested independently. Note also that there
    are two main ways of doing mocks with Jest. We can do an inline call to mock or
    we can use a mock file. For this example, we will use a mock file. Let''s look
    at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src` folder, create a new folder, `__mocks__`. Inside that folder,
    create a file called `UserTodos.tsx` and add this code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This file will be the mocked version of the function component. As you can see,
    it returns nothing and has no real members. This means that unlike the real component,
    it will not make any network call or emit any HTML, which for testing is what
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now update `DisplayText.test.tsx` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we can see that we import our mock `UserTodos` component outside of any
    test. This is necessary as doing it inside a test will not work.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the tests are the same but they now internally use the mock of `UserTodos`.
    Therefore, the test runs faster as there's no network call. As a trial of your
    newfound testing skills, try creating your own test for the `UserTodos` component
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about testing React applications using Jest and
    testing-library. Unit testing is a very important part of application development
    and you will be coding tests almost daily as a professional programmer. It can
    help both to write and refactor code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll continue adding to our developer skillset by discussing
    common tools used in the development of React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Learning common tools and practices for React development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools that can help in writing React applications. There are
    too many to list them exhaustively but we will review some of the most common
    here. These tools are vital for writing and debugging your code, so you should
    spend some time familiarizing yourself with them.
  prefs: []
  type: TYPE_NORMAL
- en: VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve been using VS Code as our code editor for the entirety of this book.
    And for JavaScript development, VS Code is clearly the most popular editor currently
    in use. Here are a few facts you should know in order to make optimal use of VS
    Code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code has a large ecosystem of extensions to help in coding. Many of them
    are dependent upon developer preferences, so you should do a quick search and
    take a look. However, here are some common extensions you should consider using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio IntelliCode**: Provides a language service for AI-driven code
    completion and syntax highlighting.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apollo GraphQL**: Code completion and formatting helpers for GraphQL.'
  prefs: []
  type: TYPE_NORMAL
- en: '**React-related plugins**: There are many React-related plugins that can help
    by providing code snippets or Hooks into services like NPM. Here are just a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – React VS Code plugins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – React VS Code plugins
  prefs: []
  type: TYPE_NORMAL
- en: VS Code has a built-in debugger that allows you to break (stop) on code and
    review variable values. I won't demonstrate it here as the standard for frontend
    development is to use the Chrome debugger, which also allows breaking on code,
    but I will demonstrate it once we start using Node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration files: In VS Code, there are two ways of setting preferences
    for your project, a workspace and the `settings.json` file. There is an enormous
    number of ways VS Code can be configured with regard to fonts, extensions, windows,
    and so on. These configurations can be done globally, or they can be done per
    project. I''ve included a `.vscode/settings.json` file in the `ejected-app` project
    for demonstration purposes. Workspace files are basically the same as settings
    files, except they''re intended for use with multiple projects in a single folder.
    Workspace files are named `<name>.code-workspace`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prettier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing code, it is very important to use a consistent style to improve
    readability. For example, if you imagine a large team with many developers, if
    they each write code in their own style with various ways of doing indentation,
    variable naming, and so on, it would be chaos. Additionally, there are industry-standard
    ways of formatting JavaScript that can make it more readable and therefore more
    understandable. This is what tools like Prettier provide.
  prefs: []
  type: TYPE_NORMAL
- en: Prettier will automatically format your code into a consistent and readable
    format upon every save, no matter who is writing the code. Just remember, after
    installing Prettier, you need to set up `settings.json` or your workspace file
    to use it. Again, I have a sample `settings.json` file in our `ejected-app` project.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chrome browser provides built-in tools for web development. These include
    the ability to see all the HTML of a page, view console messages, break on JavaScript
    code, and view network calls made by the browser. Even without any plugins, it
    is quite extensive. For many frontend developers, Chrome is the main tool for
    debugging code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the debugger for `ejected-app` and learn some of the
    basics:'
  prefs: []
  type: TYPE_NORMAL
- en: If your local instance of `ejected-app` is not running, start it again and open
    your Chrome browser to the default `localhost:3000` URL. Once there, open your
    Chrome debugger by either pressing the *F12* key or going to `root div` tag where
    the rest of our app resides. And in this screenshot, we can see the state where
    we've made our call to the web API to get todos for the user `Bret`. So, then
    we can use the Chrome Debugger to find our HTML elements and check their attributes
    and play with CSS values to get our UI precisely how we would want it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go to the **Console** tab and you should see something like this:![Figure
    6.20: Chrome Debugger Console tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: Chrome Debugger Console tab'
  prefs: []
  type: TYPE_NORMAL
- en: So, here, we can check the values for variables and function return data, making
    sure they are what we want and are expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Chrome Debugger, it is possible to break on running code. Open the
    `UserTodos.tsx` file, then add the breakpoint as shown:![Figure 6.21 – Chrome
    Debugger Sources tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Chrome Debugger Sources tab
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are able to stop on our breakpoint, as indicated by the dot
    next to *line 30*. If you hover over certain variables, you will be able to see
    their current values, even when they contain objects such as other components.
    This is a really useful feature for debugging issues in code. This feature is
    enabled by something called source maps. Source maps are files that map or tie
    source code to minified runtime code. They get created and sent to the browser
    during development time and allow the ability to break on and view variable values
    during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s remove our breakpoint and move to the **Network** tab. This tab
    shows all the network connections made by our browser. This includes not only
    calls for network resources such as data but can include calls to get images or
    static files such as HTML files. If we open this tab and then make our call to
    get todos for the user Bret, we should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Chrome Debugger Network tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Chrome Debugger Network tab
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can view all the data that comes back from our call to the
    web API. This is a handy tool that allows us to compare the data coming from our
    network resource and compare it to what our code seems to be using. We will also
    use this tool later when we do GraphQL calls as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so that was a quick overview of the Chrome Debugger, but Chrome also provides
    extensions that enable React-specific help. React Developer Tools provides information
    about our component hierarchy and attribute information about each component;
    for example, here''s a sample in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – React Developer Tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – React Developer Tools
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this tool reveals our component hierarchy and it shows the currently
    selected component's attributes. It also shows a highlight on the screen of the
    elements that make up our component, when we select the specific component within
    the hierarchy. It's a handy tool for viewing our elements from the standpoint
    of React component structure, as opposed to HTML structure. The Chrome ecosystem
    of extensions is vast and there are also extensions for Redux and Apollo GraphQL.
    We'll explore those in [*Chapter 8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122),
    *Learning Server-Side Development with Node.js and Express*,and [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book, we use VS Code as our code editor. It works great and has become
    the most popular JavaScript and TypeScript editor. However, there is no reason
    why you have to use it. And there are alternatives you should be aware of. I will
    only list out a few of them here, just so you are aware of some options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atom**: Probably the most popular free editor after VS Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sublime Text**: One of the faster and more responsive editors. Also has a
    free version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vim**: A Unix text editor, often used for editing code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webstorm**: A commercial editor from JetBrains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try some of these editors for yourself, as having a good code editor can definitely
    enhance your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: This section reviewed some of the more commonly used tools in React development.
    Although these tools don't do the main work of writing code for our application,
    they are nevertheless enormously important for helping us to write code faster
    and of higher quality. They will also reduce our pain points while writing code,
    because finding bugs can often be as challenging as resolving them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the many tools professional frontend developers
    use to help write high-quality code. Whether it's the VS Code editor used to write
    the code, or the source code repository Git used to share it, all of the tools
    mentioned here are vitally important in doing the work of a frontend engineer.
  prefs: []
  type: TYPE_NORMAL
- en: By learning about these tools, you will become a much better programmer and
    your code quality will increase substantially. Additionally, your quality of life
    as a developer will improve because many of these tools can help track down issues
    more quickly and help you resolve them more easily than trying to tackle it entirely
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend our knowledge of React by learning about
    Redux and React Router. Redux will help us manage global state and React Router
    will help us create client-side URLs. Both frameworks are very popular in the
    React community and provide many features that will help us create a more sophisticated,
    capable application.
  prefs: []
  type: TYPE_NORMAL
