- en: '*Chapter 6*: Setting Up Our Project Using create-react-app and Testing with
    Jest'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about the tools that help us build React applications.
    High-level, professional application development, regardless of the language or
    framework, always involves using tooling to help build applications faster and
    with higher code quality. The React development ecosystem is no different. A community
    has gathered around certain tooling and coding methodologies and we will go over
    those in this chapter. These sophisticated tools and methods will help us code
    better applications and help us refactor our code to adapt it to new requirements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Learning React development methods and about the build system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding client-side testing for React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning common tools and practices for React development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of web development and the SPA style of
    coding that we've been learning in the previous chapters. We will once again be
    using Node (npm) and VS Code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in folder `Chap6`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: To set up the [*Chapter 6*](B15508_06_Final_JC_ePub.xhtml#_idTextAnchor091)
    code folder on your own machine, go to your `HandsOnTypescript` folder and create
    a new folder called `Chap6`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Learning React development methods and about the build system
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the tools and practices used for coding
    and building React applications. Many of these methods are used in general for
    modern JavaScript development, even in competing frameworks such as Angular and
    Vue.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In order to build large, complex applications, we need tools – lots and lots
    of tools. Some of these tools will help us write better quality code, some will
    help us share and manage our code, and still others will exist only to enhance
    developer productivity and make it easier to debug and test our code. Therefore,
    by learning the tooling used to build modern React apps, we will ensure our application
    works as it should with minimal issues.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Project tools
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen from the prior chapters, modern React development uses many components
    to build a final application. For project structure and base dependencies, most
    developers will use `create-react-app`, which is based on the development tools
    first created for Node development (npm). We've already seen what `create-react-app`
    can do, but in this section, we'll take a deeper look.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to understand how we arrived at using the current state of
    the art in tools and coding. This knowledge will help us better understand why
    a shift to this current style was made and what the benefits are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: How it was done before tooling
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The web is actually a hodgepodge of different technologies. HTML came first,
    to create text sharing capabilities. Then CSS, for better styling and document
    structure. And then finally, JavaScript, to add some event-driven capabilities
    and programmatic control. So, it''s no wonder that sometimes integrating these
    technologies into a single coherent application can feel awkward and even difficult.
    Let''s look at some examples of bringing these pieces together without using much
    tooling:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Open your terminal or command line to the `Chap6` folder. Create a new folder
    called `OldStyleWebApp`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using VS Code create an HTML file called `index.html` and add this code into
    it. We''ll create a simple input and display:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a `.css` file called `core.css` in the same folder.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `.js` file called `script.js` in the same folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll fill in the CSS and JS files later, but immediately we have an
    issue. How do I run this app? In other words, how do I see it run so I can check
    whether it''s working? Let''s see what we can do:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In your VS Code, right-click on the `index.html` file and copy its path like
    this:![Figure 6.1 – Copy index.html
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B15508.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Copy index.html
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Now, open your browser and paste this file path into the URL. You should see
    the following:![Figure 6.2 – index.html in the browser
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B15508.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – index.html in the browser
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: You may not have already known this, but you do not need an HTTP server in order
    to view HTML files in your browser. However, you can see this process isn't the
    most efficient and it would be better if it could be automated, including auto-refreshing
    when I make changes to any related files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fill in our CSS file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You'll notice that even if I save this file, the `label` element on the web
    browser does not automatically update. I have to refresh my browser and then it
    will update. What if I have dozens of files that get updated during my development
    session? Having to manually refresh each time would not be a good experience.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add some code to `script.js`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We want to read this code carefully as there are multiple issues with it. Let's
    see what those issues are. If we save this file, open the browser debugger tools,
    and then refresh the browser, you can see that it fails immediately with this
    error in the `create-react-app` project tooling. `create-react-app` projects have
    what's called a linter. A linter is a code checker tool that runs in the background
    as you're writing your code. It will check for common errors, such as the one
    we just saw, so that it they do not end up in your production code. There's a
    lot more functionality to linters, but we will explore them more deeply later.
    The point here is we want to avoid these types of errors before running the app.
    And `create-react-app`, or in this case some of the built-in tooling, can help
    us do that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try adding the correct variable name and try reloading the browser again.
    Update the `script.js` file like this, save it, and then reload the browser:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the debugger console, the log statement does not find the
    `inputEl`, as it returns `null`. This is happening because we mistyped the `id`
    of the `input` element as `"userNam"` instead of `"userName"`. Now, again, with
    the `create-react-app` project running, this sort of error is simply not possible,
    because the vast majority of React code does not attempt to query or look for
    elements in our HTML page. Instead, we use React components directly and therefore
    we can avoid this class of error altogether. Admittedly it is possible to opt
    out of this behavior and use a reference to HTML elements via `useRef`. However,
    this is something that should be done sparingly, as you are deliberately exiting
    out of the normal React ecosystem behavior by using this Hook and therefore losing
    its benefits.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix our `script.js` file and complete it. Update it like so:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run this code by refreshing the browser, you will see that if you type
    your name into the input box and then click out of the input element, a message
    will display like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Welcome display'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B15508.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Welcome display
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: So, this code does work to display a welcome message. However, it's easy to
    make mistakes, and not have any help indicating why. In addition to this, notice
    that we have no TypeScript since browsers don't run TypeScript; they can only
    run JavaScript. This means we are also missing the type indicators that are also
    helpful in avoiding bugs related to incorrect types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: So, we've seen some of the issues around doing things in the original web way.
    But the reality is we haven't even scratched the surface of issues with doing
    development in this manner. For example, having script tags embedded in our HTML
    is a reasonable thing to do when we have only a few scripts to deal with. But
    what about when our dependencies grow? For larger apps, it is quite possible to
    have hundreds of dependencies. Managing that many script tags would be very difficult.
    And not only that – a lot of JavaScript dependencies no longer provide a URL from
    which they can be called.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Having said all this, perhaps one of the biggest issues is the highly free-form
    nature of the code. If you look at the `script.js` file again, you can see there
    is no pattern or structure to the code. Sure, it is likely your team could come
    up with a pattern on its own, but what about new programmers joining the team?
    They would have to learn a unique way of structuring the code that is specific
    to your team.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: So, the point is tooling, frameworks, and structure provide consistent, repeatable
    ways of writing and maintaining code. You can consider it a sort of culture of
    programming, where everyone has accepted the norms and practices of the culture
    and therefore knows what to do and how to behave. This makes code easier to write,
    share, and refactor. Now that we've taken a look at free-form coding, let's start
    looking at `create-react-app` more deeply.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: create-react-app
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In prior chapters, such as [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072),
    *Learning Single-Page Application Concepts and How React Enables Them*, and [*Chapter
    5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081), *React Development with Hooks*,
    we used `create-react-app` to set up our base application project. Let's look
    more closely at what is inside a `create-react-app` project. To better understand
    the parts that make up a `create-react-app` project, we need to `eject` it first.
    Here, eject simply means that we will reveal all of the internal dependencies
    and scripts that make `create-react-app` work, as normally these are hidden.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning: Ejection is a non-reversable action'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, you will not eject a `create-react-app` project,
    as there is little value in doing so. We are doing it here only to gain more insights
    into how this project works.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project inside of the `Chap6` folder by executing the following
    command from inside that folder:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let''s eject the project. Change directories in your command line to the
    new `ejected-app` folder and run this command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then enter `y` at the prompt to continue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this project from the top of the VS Code explorer menu:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`config`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This folder contains most of the configuration files and scripts that the project
    uses to set itself up. The main thing to note is that the React team by default
    uses **Jest** for testing and **Webpack** for the bundling and minification of
    JavaScript files. We'll discuss Jest in the *Understanding client-side testing
    for React* section, and Webpack is discussed later in this section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you know, this folder contains our project's dependencies. As you can see,
    even before we add our own dependencies, the default set of dependencies is vast.
    It would be quite difficult to try and use HTML script tags to list out these
    dependencies. And in most cases, these dependencies don't support script tag references.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`public`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This folder contains static assets that are used in generating our single-page
    application. This includes our one HTML file called `index.html`, the `manifest.json`
    file that is needed if we are building a PWA application. It is also possible
    to add additional files such as image files for deployment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scripts` folder contains scripts that are used to manage the project, for
    example, scripts that build, start, or kick off tests of the application. Actual
    test files should not be added here. We'll cover testing later, in the *Understanding
    client-side testing for React section*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`src`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is, of course, the folder that contains the source files of our project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`.gitignore`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.gitignore` is a file that tells the Git source code repository system which
    files and folders not to track. We will dive deeper into Git later in this section.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in prior chapters, npm is the dependency management system originally
    created for use with the Node server framework. The capabilities and popularity
    of this dependency manager eventually made it a standard for client-side development
    as well. So, the React team uses npm as its base system for project creation and
    dependency management.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: On top of listing dependencies for projects, it can also list scripts that can
    be run to manage a project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: It also has configuration capabilities for things such as Jest, ESLint, and
    Babel.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`Package-lock.json`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a related file that helps maintain a proper set of dependencies and
    sub-dependencies regardless of their order of installation. We don't need to work
    with this file directly, but knowing that this helps prevent issues when different
    developers update their `npm_modules` folder at different times with a different
    set of existing dependencies is good knowledge to have.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`tsconfig.json`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already reviewed this file in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*, and as mentioned in that chapter, it contains the settings
    for the TypeScript compiler to use. Note that, in general, the React team prefers
    stricter compilation settings. Also notice that the target JavaScript version
    is ES5\. This is because some browsers are not compatible with ES6 yet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`create-react-app` also contains two very important tools that enable some
    of its functionality: Webpack and ESLint. Webpack is a bundling and minification
    tool that automates the task of gathering all of the files that make up a project,
    removing any extraneous, unused pieces, and consolidating them into a few files.
    By removing extraneous pieces, such as white spaces and unused files or scripts,
    it can drastically lower the file sizes that must be downloaded by user browsers.
    This, of course, enhances the user experience. In addition to this core functionality,
    it provides a "hot reloading" development server, which can allow certain script
    changes to automatically show in the browser without needing a page refresh (although
    most changes do seem to trigger browser refreshes, but at least those are automated).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: ESLint is also an important tool. Since JavaScript is a scripting language and
    not a compiled language, it does not have a compiler that will check syntax and
    code validity (obviously, TypeScript does but the TypeScript compiler focuses
    primarily on typing issues). So, ESLint provides development-time code checking
    to make sure it is valid JavaScript syntax. And in addition, it allows for the
    creation of custom code-formatting rules. These rules are generally used to ensure
    that everyone on the team is coding using the same style; for example, variable
    naming conventions and bracket indentation. Once rules are set up, the ESLint
    service will enforce these rules with warning messages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The rules are not just specific to JavaScript, but they can also be rules around
    how to write code for frameworks such as React. So, for example, in a `create-react-app`
    project, the ESLint setting is `react-app`, as shown in `package.json`, which
    is a set of coding rules specific to React development. So, many of the messages
    we will see are not necessarily JavaScript errors but rules around best practices
    for coding React apps.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Webpack, although extremely powerful, is also enormously difficult to set up.
    And creating custom rules for ESLint can take a very long time to do. So, fortunately,
    another benefit of using `create-react-app` is that it provides us with good default
    configurations for both of these tools.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack虽然功能强大，但设置起来也非常困难。为ESLint创建自定义规则可能需要很长时间。所幸使用`create-react-app`的另一个好处是它为这两个工具提供了良好的默认配置。
- en: Transpilation
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转译
- en: 'We introduced transpilation in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017),
    *Understanding TypeScript*. However, we should cover it a little more deeply in
    this chapter since `create-react-app` depends on transpilation for much of its
    code generation. `create-react-app` allows us to use TypeScript or Babel so that
    we can develop code in one language or language version and emit code as a different
    language or language version. Here''s a simple diagram showing the flow of code
    during the transpilation of TypeScript:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第1章*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)中介绍了转译，*理解TypeScript*。然而，在这一章中，我们应该更深入地介绍它，因为`create-react-app`在很大程度上依赖于转译来生成其代码。`create-react-app`允许我们使用TypeScript或Babel，以便我们可以用一种语言或语言版本开发代码，并将代码作为不同的语言或语言版本发出。下面是一个简单的图表，显示了在TypeScript转译过程中代码的流动。
- en: '![Figure 6.5 – Transpilation from TypeScript to JavaScript'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5-从TypeScript到JavaScript的转译'
- en: '](img/Figure_6.05_B15508.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.05_B15508.jpg)'
- en: Figure 6.5 – Transpilation from TypeScript to JavaScript
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5-从TypeScript到JavaScript的转译
- en: The TypeScript compiler will search your project and find all the `ts` or `tsx`
    files inside of the root code folder, usually `src`. If there are errors, it will
    stop and let us know, otherwise, it will parse and convert the TypeScript into
    pure JavaScript as `js` files and that is what is run on systems. Notice in the
    diagram we are also changing the JavaScript version as well. So, transpilation
    is a lot like compilation. Code is checked for validity and some classes of bugs,
    but instead of being converted into byte code that can be run directly, it is
    converted into a different language or language version. Babel is also capable
    of emitting JavaScript and working with TypeScript developer code. However, I
    prefer to use the original TypeScript compiler, as it is made by the same team
    that designs TypeScript and is usually more up to date.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将搜索您的项目，并找到根代码文件夹（通常为`src`）中的所有`ts`或`tsx`文件。如果有错误，它会停止并通知我们，否则，它将解析并将TypeScript转换为纯JavaScript作为`js`文件，并在系统上运行。请注意，在图表中，我们还更改了JavaScript版本。因此，转译很像编译。代码被检查有效性和某些类别的错误，但不是转换为可以直接运行的字节码，而是转换为不同的语言或语言版本。Babel也能够发出JavaScript并处理TypeScript开发人员的代码。但是，我更喜欢使用原始的TypeScript编译器，因为它是由设计TypeScript的同一个团队制作的，通常更加更新。
- en: Choosing transpilation as the method of compilation has multiple important benefits.
    For one, developers do not need to worry whether their code will run on a browser,
    or whether the user would need to either upgrade or install a bunch of dependencies
    on that machine first. The TypeScript compiler emits web standard ECMAScript (ES3,
    ES5, ES6, and so on) and therefore the code can be set to run on any modern browser.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选择转译作为编译方法有多个重要的好处。首先，开发人员不需要担心他们的代码是否能在浏览器上运行，或者用户是否需要在机器上升级或安装一堆依赖。TypeScript编译器发出Web标准ECMAScript（ES3、ES5、ES6等），因此代码可以在任何现代浏览器上运行。
- en: Transpilation also allows developers to take advantage of newer versions of
    JavaScript before their final release. Since JavaScript is on an almost annual
    update cycle, this feature can be extremely useful in terms of taking advantage
    of new language features or performance capabilities; for example, when a new
    feature of JavaScript is being considered. The ECMA foundation, the standards
    body that maintains the JavaScript language, goes through several stages before
    accepting changes into an official version of JavaScript. But the TypeScript and
    Babel teams will sometimes accept new JavaScript features when they are still
    in one of these earlier stages. This is how many JavaScript developers were able
    to use async-await in their code before it became an official standard.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 转译还允许开发人员在最终发布之前利用JavaScript的新版本。由于JavaScript几乎每年都会更新一次，这个功能在利用新的语言特性或性能能力方面非常有用；例如，当考虑JavaScript的新功能时。ECMA基金会，维护JavaScript语言的标准机构，在将更改纳入JavaScript的官方版本之前会经历几个阶段。但是TypeScript和Babel团队有时会在这些较早阶段之一接受新的JavaScript功能。这就是许多JavaScript开发人员在它成为官方标准之前就能在他们的代码中使用async-await的方式。
- en: Code repositories
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码存储库
- en: A code repository is a system that allows the sharing of source code among multiple
    developers. Code can be updated, copied, and merged. For large teams, this tool
    is absolutely necessary for building complex applications. The most popular modern
    source code control and repository is Git. And the most popular online repository
    host is GitHub.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码存储库是一个允许多个开发人员共享源代码的系统。代码可以被更新、复制和合并。对于大型团队来说，这个工具对于构建复杂的应用程序是绝对必要的。最流行的现代源代码控制和存储库是Git。而最流行的在线存储库主机是GitHub。
- en: Although thoroughly learning Git is beyond the scope of this book, it is important
    to understand some of the basic concepts and commands, as you will need them when
    interacting with other developers and maintaining your own projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管彻底学习Git超出了本书的范围，但了解一些基本概念和命令是很重要的，因为在与其他开发人员互动和维护自己的项目时，您将需要它们。
- en: 'One of the more important concepts of any code repository is that of branching.
    This means the ability to indicate multiple versions of a project. For example,
    these branches could be for the version numbers of a project, such as 1.0.0, 1.0.1,
    and so on. It could also be for creating separate versions of an app where perhaps
    some experimental or high-risk code is being tried out. It would not be a good
    idea to place such code into the main branch. Here''s an example of the React
    GitHub page and its many versions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – React GitHub'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B15508.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – React GitHub
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many branches. The current stable branch, although
    not visible in this screenshot, is usually called the master.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, learning Git well would require a book of its own, so here I''ll just
    go over some of the main commands that you would use daily:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`git`: This command is the Git `git` command, you are working on a local copy
    of the repository; you are not directly working on the online repository or affecting
    your teammates'' repositories until you push your changes onto the server.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone`: This command allows you to copy a repository onto your local machine.
    Note that when you clone, generally, you will default to the master branch. Here''s
    an example:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`checkout`: This subcommand allows you to change your working branch to a different
    desired branch. So, if you wanted to work in another branch other than the master,
    you would use this command. Here''s an example:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`add`: This subcommand adds the files you recently changed as needing to be
    tracked, which indicates you will later commit them into the repository. You can
    do all your changed files in one shot by using `.` after `add` or indicate the
    files explicitly:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`commit`: This subcommand indicates that you will eventually update your working
    branch with the files that you just added locally. If you add the `-m` parameter,
    you can add a label inline to describe your commit. This command helps team members
    track which changes were done in each commit:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`push`: This subcommand does the actual moving of local committed files into
    the remote repository:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we covered some of the core project tools available for React
    developers. `create-react-app`, ESLint, Webpack, and npm provide invaluable features
    that make development more efficient and less error-prone. We also covered transpilation,
    to understand how we can take advantage of newer language versions, without compromising
    compatibility, on end user devices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we took a quick look at Git. Currently, it is the most popular
    code-sharing repository. As a professional developer, you will most certainly
    end up using it for projects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some important core tools knowledge, we'll continue in the
    next section by discussing testing. Modern development practices make heavy use
    of testing and test frameworks. Fortunately, JavaScript has great testing frameworks
    to help us write good-quality tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Understanding client-side testing for React
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a very important part of development. These days, no large projects
    will be written without some level of unit testing. The purpose of tests is to
    ensure that your code is always working correctly and doing the expected things.
    This is especially true when code is modified, that is, refactored. In fact, it
    is probably more difficult to change existing complex code than it is to create
    brand-new code. Unit testing can prevent breaking existing code during refactoring.
    But if code does break, it can also help pinpoint the exact place where code no
    longer works so it can be fixed quickly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, previously, there were two main testing libraries that were commonly
    used: `create-react-app`. So, for this book, we will be learning about Jest and
    testing-library.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: All unit tests work in the same way. This is true not only for React and JavaScript
    tests, but tests in any language will work in the same manner. So then, what is
    a unit test? A unit test attempts to test one specific portion of code and it
    attempts to assert that something about it is true. That's basically it. To put
    it another way, it means that the test is checking to see whether something expected
    is indeed the case. If it is not, then the test should fail. Although this goal
    is simple, creating high-quality tests is not. So, we'll go over some examples
    here, but please keep in mind that large-application testing can be as complicated
    if not more so than the actual code for creating the app. So, it will take some
    time for you to become proficient in writing tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things clearer, let''s take a look at a simple test. Do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Go to VS Code and open the file at path `ejected-app/src/App.test.tsx`. This
    is a test for the `App` component. We'll go over the contents of the test in just
    a moment.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your terminal to `ejected-app` and run this command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Figure 6.7 – Test run options'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B15508.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Test run options
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'If your tests did run or you selected `a`, you should see the following result:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Tests completed successfully'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B15508.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Tests completed successfully
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our tests have automatically been found and run (although, currently,
    we only have one). And in this run, the one test is successful, meaning what was
    expected did occur. If any failed, the same UI would indicate how many tests failed
    and how many succeeded.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the test in `App.test.tsx`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, you will notice the filename has the text `test` in it. This is what
    tells Jest that this is a test file. Some teams like to place all their tests
    into a single folder. Some teams prefer to have the test right next to the actual
    file being tested, as in this case. There is no right answer. Do what works best
    for you and your team. In this book, we will put our tests right next to the file
    being tested. Let''s take a look at the contents of our `test` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Notice among the imports that we have a reference to `@testing-library/react`.
    As mentioned, this library will give us some extra tooling to make the testing
    of the component output easier.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, notice the `test` function. This function acts as an encapsulated wrapper
    for our single test. This means that all the things relative to this one test
    live inside this function and cannot be accessed from outside of it. This ensures
    that our test is not impacted by other tests.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter of this function is a description. Descriptions are totally
    arbitrary, and your team will have its own standard for how these descriptions
    should be written. The only thing we need to focus on is making the description
    brief but clear about what is being tested.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is a function that runs the actual test. In this case,
    the test is checking whether a certain specific text appears within the emitted
    HTML of our `App` component. Let's go over the code line by line.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On *line 6*, we run `render`, passing it the `App` component. This `render`
    function executes our component and gets back certain properties and functions
    that allow us to test the emitted HTML. In this case, we decide only to receive
    the function `getByText`, which simply means to return an element that has certain
    text in it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *l**ine 7*, we get our HTML DOM element by calling `getByText` with the parameter
    `/learn react/i`, which is syntax for running a regular expression, but in this
    case, it's hardcoded for text.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, on *line 8*, an assertion is made called `expect`, which expects the
    element object called `linkElement` to be in the DOM using the `toBeInTheDocument`
    function. So, an easy way of understanding tests in general is to read their assertions
    like a sentence. For example, we can read this assertion like this, "I expect
    the linkElement to be in the document" (the document is, of course, the browser
    DOM). By reading it this way, it's pretty clear what is intended.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we change the code a bit. Update `App.tsx`
    with the following (I''m only showing the `App` function for brevity):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you save this file, you should immediately see an error like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Error after changing App.tsx'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B15508.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Error after changing App.tsx
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Again, the test runner is running in watch mode so you should see the test results
    as soon as you save your change. As you can see, our test fails because the text
    `learn react` was not found and therefore the assertion `expect(linkElement).toBeInTheDocument()`
    is not true.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so we''ve taken a look at a built-in test that `create-react-app` provided.
    Let''s now create a new component so we can write our own tests from scratch.
    Do the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s leave our test running in watch mode, even though it''s showing an error,
    and create a new terminal window by clicking the plus button at the upper-right
    side of the terminal window in VS Code. The button is the plus sign shown here:![Figure
    6.10: Plus sign for a new terminal'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B15508.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Plus sign for a new terminal'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file called `DisplayText.tsx` in the `src` folder and add
    this code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This component will simply display a new message after someone enters their
    name into the input and clicks the `DisplayText`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create some state necessary for the workings of our component and event
    handlers to deal with new text and the display of our message (we''ve already
    covered how to create a React component in [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081),
    *React Development with Hooks*):'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we return our UI, which includes an input and a submit button. Note
    the `data-testid` attributes to allow elements to be easily found by our tests
    later. If you run this code and enter your name and click the button, you should
    see something like this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – New component for testing'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B15508.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – New component for testing
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our display simply returns the entered text with a welcome message.
    However, even this simple example has several different things to test. For one,
    we would like to make sure that there is text entered into the input and that
    it is words and not numbers or symbols. We also want to make sure that when we
    click the button, the message is displayed and that it starts with the string
    `"Welcome to React testing"` and ends with the user's input text.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our component, let''s build our test for it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be aware of a small issue in our `tsconfig.json` file. As I stated
    earlier, you can place your tests inside of a separate folder, usually called
    `__test__`, or you can place it side by side with your component file. We will
    be placing it side by side for convenience. If we do so, we will need to update
    our `tsconfig.json` file to include this `compilerOption`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the test file for this component by creating a new file called `DisplayText.test.tsx`
    and add this initial code into it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the top, you'll notice we have imported `render` from `@testing-library/react`
    and we've also imported the `@testing-library/jest-dom/extend-expect` extension,
    which allow us to do assertions. The extensions of the `expect` keyword give us
    additional functions that allow us to test in more ways. For example, we are using
    `toHaveValue` to get the value of `input`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: After the imports, you'll notice some new syntax. `describe` is, as the name
    implies, simply a way to create a grouping container with a helpful label. This
    container can have more than one test, but these tests should all be related to
    testing a specific component or feature. In this case, we are trying to test the
    `DisplayText` component so all the tests within `describe` will be testing only
    that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our first test is started using the function called `it`. This function
    checks that our component, `DisplayText`, can be rendered out as HTML without
    crashing or erroring out. The `render` function attempts to do the rendering and
    the `expect` and `toBeInTheDocument` functions determine whether the rendering
    was a success by checking whether it is in the DOM. As an experiment, add this
    code, `console.log(baseElement.innerHTML)`, within the first test `it` function
    below the line starting with `const { baseElement }`. You should see this HTML
    string in the terminal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Log: resultant test HTML'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B15508.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s create one more test to show an end-to-end test of our component.
    Add the following code after our second `it` function:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This test is similar to our second test in that it adds a value within our `input`,
    but then it goes on and gets our `button`, and then our `label`. It then creates
    a `click` event to simulate a button press that in regular code would cause our
    `label` to be populated with our welcome message. It then tests the contents of
    our `label`. Again, once you save this file, our tests should rerun and all of
    them should pass.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s also look at something called snapshots. Obviously, a big part
    of React development is not just the behavior or actions available within our
    app, but the actual UI presented to our users. So, by doing snapshot testing,
    we are able to check that the desired UI, HTML elements, are indeed created by
    our components. Let''s add this code to our tests after our "renders without crashing"
    test:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, our `render` function is set to return the root most element
    of the `DisplayText` component by using the `baseElement` property. In addition,
    we can see that we have a new `expect` function called `toMatchSnapshot`. This
    function does a couple of things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The first time it runs, it creates a folder called `__snapshot__` at the root
    of our `src` folder.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then adds or updates a file that has the same name as our test file and ends
    with the extension .`snap`. So, in this case, our test file snapshot file would
    be `DisplayText.test.tsx.snap`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The contents of this snapshot file are the emitted HTML elements of our component.
    So the snapshot you have should look something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, this is an exact duplicate of our desired HTML as emitted by
    our `DisplayText` component. Notice also the description given and the indication
    that it is `snapshot 1`. As you add more, the number will increment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now we have a snapshot and our first test run has succeeded. Let''s
    see what happens if we change our `DisplayText` JSX. Update the `DisplayText.tsx`
    file, not your test file, like this (I''ll just show the component definition
    for brevity''s sake):'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code remains entirely the same, however, in the `return`, we
    add a dummy `div` tag as shown:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And after selecting `u`, our snapshot file should update successfully and our
    snapshot test should complete. If you open your local snapshot file, you should
    see the same new `div` tag we added to our component earlier.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So now we've seen some simple tests to help us get started. Next, we'll get
    introduced to the topic of mocking.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking is simply replacing specific functionality in our test with default
    values. An example of mocking could be to only pretend to make a network call
    but instead return a hardcoded value. The reason we want to do this is we want
    to only test a single unit or a small piece of our code. By mocking some portions
    of our code that are not specific to what we are testing, we are avoiding confusion
    and making certain our test works consistently. For example, if we were trying
    to test input in our code, we wouldn't want a network call failure to affect the
    result of that test, because a network call has nothing to do with the input element
    specifically. When we want to do end-to-end testing or integration testing, we
    can worry about the network call as well. But that is a different animal from
    unit testing (in some teams, integration testing is handled by the QA team separately)
    and we won't cover it here. Now, when it comes to React components, testing-library
    actually recommends against mocking, because this effectively makes our test less
    like actual code. Having said that, sometimes mocking can still be helpful to
    do, so I will show how to mock components as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Mocking with jest.fn
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s learn about mocking with Jest as it is also used with Node development.
    The first way to do mocking in Jest is to mock a specific function using `fn`.
    This function takes another function as a parameter that will do whatever you
    need to be done to set up your desired mock. But also, in addition to this ability
    to replace arbitrary existing code and values, creating a mock will give you access
    to a member called `mock`. This member provides metrics about your mock call.
    This is difficult to conceptualize so let''s create an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `DisplayText` component to make a network call to a web API.
    We will use the `DisplayText` that is a function that returns a user''s full name
    based upon their username. We need to first update the `App` function file like
    this:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s see the updated `DisplayText` component code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: return (
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <form>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <label>Enter your name</label>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <input data-testid="user-input"                   value={txt}
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: onChange={onChangeTxt} />
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <button data-testid="input-submit"
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: onClick={onClickShowMsg}>Show Message</                  button>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <label data-testid="final-msg" >{msg}</                 label>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: export default DisplayText;
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Figure 6.15 – User''s full name'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B15508.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – User's full name
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the full name of the user with the username **bret** is **Leanne
    Graham**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s write our test and mock out our network call using Jest:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `DisplayText.test.tsx` and notice that all our tests are failing since
    none of them will have the new property `getUserFullname`. So, let''s update our
    test and mock this function. Here are the new tests:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: afterEach(cleanup);
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'userFullName and getUserFullnameMock. Since we will be running our mock function
    in several tests, we are creating the getUserFullnameMock function so that we
    can reuse it to give us our mock function getUserFullname and a few other needed
    items.But then the question may be why do they look so complicated? Let''s go
    through the code and figure out what it''s doing: *   After we set the `userFullName`,
    variable we create the `getUserFullnameMock`. function As you can see, the `getUserFullnameMock`
    function takes a `username` as a parameter, just like the real `getUserFullname`
    function, and returns a `promise` and a `Mock` object. *   Inside of `getUserFullnameMock`,
    the definition instantiates a `promise` object and it mocks our `getUserFullname`
    function by using `jest.fn`. We need a promise to simulate a network call and
    also to `await` on it later with the `wait` call from testing-library.*   As mentioned,
    `jest.fn` is used to instantiate a mock and have the mock do whatever it is that
    we may need. In this case, since the `getUserFullname` function we are mocking
    is making a network call, we need to have our `jest.fn` mock return a promise.
    And it does so by returning the `promise` we created on the line immediately above
    it.*   And then, finally, both the `promise` and the new mock function, `getUserFullname`,
    are returned. *   We are going to quite a bit of trouble here, but in this case,
    it is a good idea to eliminate the use of a slow and error-prone network call.
    Otherwise, if the network call fails, we may incorrectly believe our test and
    code have failed.*   Next, let''s see how our mock is used within our tests:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last test is updated since it tests the welcome message. Update your last
    test like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So by using `jest.fn`, we can mock out a piece of code so that it can give us
    a consistent value. Again, this helps us create consistent, reproducible tests
    where we are testing only a specific unit of code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Component mocking
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second form of mocking is to replace whole components entirely and use
    them in place of real components when we want to test other code. In order to
    test this, follow the steps given here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our `DisplayText` component show a list of user todos based on
    the inserted username. Update the component like this:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we''ve created some state to use later:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we update our input with the value of the username given by the user:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the **Show Message** button is clicked, we update the message to be displayed
    as well as the list of todos to be shown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to accept a prop to use as our message prefix:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similarly to how we got the user''s `fullname` by using their `username`, we
    get the user''s list of todos by calling the JSONPlaceholder API. First, we find
    the user by calling into the users collection:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then we call into the todos collection and match the todos to the previously
    found user.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we return an unordered list of todos via the UI:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 6.16 – List user todos'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B15508.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – List user todos
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are displaying the user bret's list of todos.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s pretend we wanted to test our `DisplayText` component without testing
    this list of todos. How could we refactor this code so that our test wouldn''t
    be so monolithic? Let''s refactor our `DisplayText` component and pull out the
    todos capability as its own component:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `DisplayText` file like this:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'const onClickShowMsg = async (e:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: React.MouseEvent<HTMLButtonElement, MouseEvent>) =>         {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: e.preventDefault();
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: setTodoControl(null);
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: setMsg(`Welcome to React testing, ${await
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: getUserFullname(txt)}`);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'onClickShowMsg event handler will call setTodoControl and pass our UserTodos
    component the username:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s create our new `UserTodos` component. Create a file called `UserTodos.tsx`
    and add this code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are now taking the username as a prop from our parent:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'First, we grab our users again from the users collection and filter to find
    our one user by matching the `username`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we grab the matching todos of the found user. We then run the JavaScript
    `map` function to create a collection of `li` elements for each todo:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By using `useEffect`, we are indicating that any time our `username` prop changes,
    we want to update our list of todos:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And finally, we output our todos as unordered list elements. If you run this
    code, you should see this once you click **Show Message**:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Refactored todos'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B15508.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Refactored todos
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so now we can add a new test that mocks out our `UserTodos` component and
    therefore allows `DisplayText` to be tested independently. Note also that there
    are two main ways of doing mocks with Jest. We can do an inline call to mock or
    we can use a mock file. For this example, we will use a mock file. Let''s look
    at the steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src` folder, create a new folder, `__mocks__`. Inside that folder,
    create a file called `UserTodos.tsx` and add this code into it:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This file will be the mocked version of the function component. As you can see,
    it returns nothing and has no real members. This means that unlike the real component,
    it will not make any network call or emit any HTML, which for testing is what
    we want.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now update `DisplayText.test.tsx` with the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we can see that we import our mock `UserTodos` component outside of any
    test. This is necessary as doing it inside a test will not work.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the tests are the same but they now internally use the mock of `UserTodos`.
    Therefore, the test runs faster as there's no network call. As a trial of your
    newfound testing skills, try creating your own test for the `UserTodos` component
    separately.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about testing React applications using Jest and
    testing-library. Unit testing is a very important part of application development
    and you will be coding tests almost daily as a professional programmer. It can
    help both to write and refactor code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll continue adding to our developer skillset by discussing
    common tools used in the development of React applications.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Learning common tools and practices for React development
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools that can help in writing React applications. There are
    too many to list them exhaustively but we will review some of the most common
    here. These tools are vital for writing and debugging your code, so you should
    spend some time familiarizing yourself with them.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: VS Code
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve been using VS Code as our code editor for the entirety of this book.
    And for JavaScript development, VS Code is clearly the most popular editor currently
    in use. Here are a few facts you should know in order to make optimal use of VS
    Code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code has a large ecosystem of extensions to help in coding. Many of them
    are dependent upon developer preferences, so you should do a quick search and
    take a look. However, here are some common extensions you should consider using:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio IntelliCode**: Provides a language service for AI-driven code
    completion and syntax highlighting.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '**Apollo GraphQL**: Code completion and formatting helpers for GraphQL.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**React-related plugins**: There are many React-related plugins that can help
    by providing code snippets or Hooks into services like NPM. Here are just a few:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – React VS Code plugins'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B15508.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – React VS Code plugins
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: VS Code has a built-in debugger that allows you to break (stop) on code and
    review variable values. I won't demonstrate it here as the standard for frontend
    development is to use the Chrome debugger, which also allows breaking on code,
    but I will demonstrate it once we start using Node.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration files: In VS Code, there are two ways of setting preferences
    for your project, a workspace and the `settings.json` file. There is an enormous
    number of ways VS Code can be configured with regard to fonts, extensions, windows,
    and so on. These configurations can be done globally, or they can be done per
    project. I''ve included a `.vscode/settings.json` file in the `ejected-app` project
    for demonstration purposes. Workspace files are basically the same as settings
    files, except they''re intended for use with multiple projects in a single folder.
    Workspace files are named `<name>.code-workspace`.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prettier
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing code, it is very important to use a consistent style to improve
    readability. For example, if you imagine a large team with many developers, if
    they each write code in their own style with various ways of doing indentation,
    variable naming, and so on, it would be chaos. Additionally, there are industry-standard
    ways of formatting JavaScript that can make it more readable and therefore more
    understandable. This is what tools like Prettier provide.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Prettier will automatically format your code into a consistent and readable
    format upon every save, no matter who is writing the code. Just remember, after
    installing Prettier, you need to set up `settings.json` or your workspace file
    to use it. Again, I have a sample `settings.json` file in our `ejected-app` project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Chrome Debugger
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chrome browser provides built-in tools for web development. These include
    the ability to see all the HTML of a page, view console messages, break on JavaScript
    code, and view network calls made by the browser. Even without any plugins, it
    is quite extensive. For many frontend developers, Chrome is the main tool for
    debugging code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the debugger for `ejected-app` and learn some of the
    basics:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: If your local instance of `ejected-app` is not running, start it again and open
    your Chrome browser to the default `localhost:3000` URL. Once there, open your
    Chrome debugger by either pressing the *F12* key or going to `root div` tag where
    the rest of our app resides. And in this screenshot, we can see the state where
    we've made our call to the web API to get todos for the user `Bret`. So, then
    we can use the Chrome Debugger to find our HTML elements and check their attributes
    and play with CSS values to get our UI precisely how we would want it.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go to the **Console** tab and you should see something like this:![Figure
    6.20: Chrome Debugger Console tab'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.20_B15508.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.20: Chrome Debugger Console tab'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: So, here, we can check the values for variables and function return data, making
    sure they are what we want and are expecting.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Using the Chrome Debugger, it is possible to break on running code. Open the
    `UserTodos.tsx` file, then add the breakpoint as shown:![Figure 6.21 – Chrome
    Debugger Sources tab
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.21_B15508.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – Chrome Debugger Sources tab
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are able to stop on our breakpoint, as indicated by the dot
    next to *line 30*. If you hover over certain variables, you will be able to see
    their current values, even when they contain objects such as other components.
    This is a really useful feature for debugging issues in code. This feature is
    enabled by something called source maps. Source maps are files that map or tie
    source code to minified runtime code. They get created and sent to the browser
    during development time and allow the ability to break on and view variable values
    during runtime.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s remove our breakpoint and move to the **Network** tab. This tab
    shows all the network connections made by our browser. This includes not only
    calls for network resources such as data but can include calls to get images or
    static files such as HTML files. If we open this tab and then make our call to
    get todos for the user Bret, we should see this:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Chrome Debugger Network tab'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.22_B15508.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Chrome Debugger Network tab
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can view all the data that comes back from our call to the
    web API. This is a handy tool that allows us to compare the data coming from our
    network resource and compare it to what our code seems to be using. We will also
    use this tool later when we do GraphQL calls as well.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so that was a quick overview of the Chrome Debugger, but Chrome also provides
    extensions that enable React-specific help. React Developer Tools provides information
    about our component hierarchy and attribute information about each component;
    for example, here''s a sample in our app:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – React Developer Tools'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.23_B15508.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – React Developer Tools
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this tool reveals our component hierarchy and it shows the currently
    selected component's attributes. It also shows a highlight on the screen of the
    elements that make up our component, when we select the specific component within
    the hierarchy. It's a handy tool for viewing our elements from the standpoint
    of React component structure, as opposed to HTML structure. The Chrome ecosystem
    of extensions is vast and there are also extensions for Redux and Apollo GraphQL.
    We'll explore those in [*Chapter 8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122),
    *Learning Server-Side Development with Node.js and Express*,and [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, respectively.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Alternative IDEs
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book, we use VS Code as our code editor. It works great and has become
    the most popular JavaScript and TypeScript editor. However, there is no reason
    why you have to use it. And there are alternatives you should be aware of. I will
    only list out a few of them here, just so you are aware of some options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**Atom**: Probably the most popular free editor after VS Code.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sublime Text**: One of the faster and more responsive editors. Also has a
    free version.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vim**: A Unix text editor, often used for editing code.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Webstorm**: A commercial editor from JetBrains.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try some of these editors for yourself, as having a good code editor can definitely
    enhance your productivity.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This section reviewed some of the more commonly used tools in React development.
    Although these tools don't do the main work of writing code for our application,
    they are nevertheless enormously important for helping us to write code faster
    and of higher quality. They will also reduce our pain points while writing code,
    because finding bugs can often be as challenging as resolving them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the many tools professional frontend developers
    use to help write high-quality code. Whether it's the VS Code editor used to write
    the code, or the source code repository Git used to share it, all of the tools
    mentioned here are vitally important in doing the work of a frontend engineer.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: By learning about these tools, you will become a much better programmer and
    your code quality will increase substantially. Additionally, your quality of life
    as a developer will improve because many of these tools can help track down issues
    more quickly and help you resolve them more easily than trying to tackle it entirely
    on your own.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend our knowledge of React by learning about
    Redux and React Router. Redux will help us manage global state and React Router
    will help us create client-side URLs. Both frameworks are very popular in the
    React community and provide many features that will help us create a more sophisticated,
    capable application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
