- en: Pure Functional Programming in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Go is an attempt to combine the safety and performance of statically typed
    languages with the convenience and fun of dynamically typed interpretative languages."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Rob Pike'
  prefs: []
  type: TYPE_NORMAL
- en: Do you love Go? If so, why? Could it be better? Can you write your code better
    today?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes! Because Go is simple yet powerful; Go does not make me wait; its compiler
    is fast and cross-platform; Go makes concurrent programming easy; Go also provides
    useful tooling, and it has a great development community. Perhaps. Yes, that''s
    what this book is about: using the **functional programming** (**FP**) style of
    coding.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will share the benefits of pure FP as well as its performance
    implications in Go by working through Fibonacci sequence code samples. Starting
    with a simple imperative implementation, you will explore functional implementations
    and learn some test-driven development and benchmark techniques along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to:'
  prefs: []
  type: TYPE_NORMAL
- en: Become grounded in the theory of FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to implement functional solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine what type of FP will best fit your business requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motivation for using FP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FP style of programming can help you write less code in a more concise and
    expressive way, with fewer errors. How is that possible? Well, FP treats computation
    as an evaluation of mathematical functions. FP leverages this computational model
    (and the work of some brilliant mathematicians and logicians) to enable optimizations
    and performance gains that are simply not possible using traditional imperative
    coding techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developing software is not easy. You must handle numerous **non-functional
    requirements** (**NFRs**) first, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software is becoming more and more complex. What is the average number of third-party
    dependencies in your typical application? What did that look like 5 years ago?
    Our applications often must integrate with other services within our own company
    and with our partners as well as external customers. How can we manage this growing
    complexity?
  prefs: []
  type: TYPE_NORMAL
- en: Applications used to run on-site on servers that were given pet names, such
    as Apollo, Gemini, and so on. It seems like every client would have a different
    naming scheme. Nowadays, most applications are deploying into a cloud environment,
    for example, AWS or the Google Cloud Platform. Do you have a lot of software applications
    that run on a lot of servers? If so, you should treat your servers more like cattle;
    there's just so many of them. Also, since you've got auto scaling, what's important
    is not a single server but the herd. As long as you always have at least one server
    in your cluster running for the accounting department, that's all that really
    matters.
  prefs: []
  type: TYPE_NORMAL
- en: With numbers comes complexity. Can you compose your applications to fit together
    like Lego blocks, and do you find it easy to write useful tests that run really
    fast. Alternatively, do you ever feel like there's too much scaffolding/`for`
    loops in your code? Do you like handling the `err != nil` condition so frequently?
    Would you like to see a simpler, cleaner way to do the same thing? Do your applications
    have any global variables? Do you have code in place to always properly manage
    its state and prevent all the possible side effects? Have race conditions ever
    been a problem?
  prefs: []
  type: TYPE_NORMAL
- en: Are you aware of all the possible error conditions in your applications, and
    do you have code in place to handle them? Can you look at the function signature
    of any function in your code and immediately have an intuition as to what it does?
  prefs: []
  type: TYPE_NORMAL
- en: Are you interested in learning about a better way to achieve your NFRs and enjoy
    developing Go software even more than you do right now? Looking for the silver
    bullet? If so, please continue reading. (Note that the rest of this book will
    be written in first person plural since we will be learning together.)
  prefs: []
  type: TYPE_NORMAL
- en: Getting the source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GitHub repository for this book's source code is [https://github.com/l3x/fp-go](https://github.com/l3x/fp-go).
  prefs: []
  type: TYPE_NORMAL
- en: If you store your Go projects in the `~/myprojects` directory, then run `cd
    ~/myprojects; git clone https://github.com/l3x/fp-go.git`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the `cd` command into the first project directory: `cd ~/myprojects/fp-go/1-functional-fundamentals/ch01-pure-fp/01_oop`.'
  prefs: []
  type: TYPE_NORMAL
- en: The directory structure of the source files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Directories correspond to the book''s units and chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40477779-288a-46bb-81b0-e384bd08f0aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Each chapter is divided into sequentially numbered directories that are in the
    order of their appearance in the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to run our first Go application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's make sure we have Go installed, our `GOPATH` is properly set, and
    that we can run a Go application.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a macOS, then check out the instructions on how to use the `brew` command
    to install Go in the appendix; otherwise, to install Go, visit: [http://golang.org/doc/install](http://golang.org/doc/install). To
    set your `GOPATH`, visit: [https://github.com/golang/go/wiki/Setting-GOPATH](https://github.com/golang/go/wiki/Setting-GOPATH).
  prefs: []
  type: TYPE_NORMAL
- en: Many people use a global `GOPATH` to store the source code for all their Go
    applications or, frequently, manually reset their `GOPATH`. I found this practice
    to be troublesome when working with multiple Go projects for multiple clients,
    each of which had differing Go versions and third-party dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example Go applications that we''ll use in this chapter do not have dependencies;
    that is, we don''t have to import any third-party packages. So, all we have to
    do to run our first `app--cars.go--is` verify that Go is installed, set our `GOPATH`,
    and type `go run cars.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ff6f041-0caa-4dbd-8aa7-1cb35e033a80.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a global `GOPATH` is easy for projects that are super simple, like the
    examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](../Text/Ch02.xhtml), *Manipulating Collections*, our Go applications
    will start getting more complex, and we'll get introduced to a simple, more consistent
    way to manage our Go development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative versus declarative programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at why the functional style of programming helps us be more productive
    than the imperative alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '"We are not makers of history. We are made by history."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Martin Luther King, Jr.'
  prefs: []
  type: TYPE_NORMAL
- en: Nearly all computer hardware is designed to execute machine code, which is native
    to the computer, written in the imperative style. The program state is defined
    by the contents of memory, and the statements are instructions in the machine
    language where each statement advances the state of computation forward, toward
    a final outcome. Imperative programs change their state over time, step by step.
    High-level imperative languages, such as C and Go, use variables and more complex
    statements, but they still follow the same paradigm. Since the basic ideas in
    imperative programming are both conceptually similar to low-level code that operates
    directly on computer hardware, most computer languages--such as Go, also known
    as *C of the 21st century*--are largely imperative.
  prefs: []
  type: TYPE_NORMAL
- en: '**Imperative programming** is a programming paradigm that uses statements that
    change a program''s state. It focuses on the step-by-step mechanics of how a program
    operates.'
  prefs: []
  type: TYPE_NORMAL
- en: The term is often used in contrast to **declarative programming**. In declarative
    programming, we declare what we want the results to be. We describe what we want,
    not detailed instructions of how to get it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical, imperative way to find `Blazer` in a slice of cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a functional way of accomplishing the same task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's nine lines of imperative code, compared to two lines in the **functional
    programming** (**FP**) style.
  prefs: []
  type: TYPE_NORMAL
- en: Functional constructs often express our intent more clearly than for loops in
    such cases and are especially useful when we want to filter, transform, or aggregate
    the elements in a dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the imperative example, we must code the *how.* We must:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a Boolean flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare and set a variable value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a looping structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare each iterated value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the functional example, we declare *what* we want to do. We are able to focus
    on what we want to accomplish, rather than bloating our code with the mechanics
    of looping structures, setting variable values, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In FP, iteration is implemented by the library function `contains()`. Leveraging
    library functions means that we code less and allow library developers to focus
    on highly efficient implementations, which have been typically vetted and performance
    enhanced by seasoned professionals. We don't have to write, debug, or test such
    high-quality code for repetitive logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we could look for `Blazer` using the object-oriented
    programming paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we declare our object types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add our methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare a global variable, namely `myCars`, where we will persist
    the state, that is, the list of cars that we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add three cars to the list. The `Car` object encapsulates the data for each
    object, and the `cars` object encapsulates our list of cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Look for `Highlander` and print the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are using `car` objects, but we are essentially doing the same operations
    as we were in the simple imperative code example. We do have objects that have
    state and to which we could add methods, but the underlying mechanisms are the
    same. We assign a state to object properties, modify the internal state by making
    method calls, and advance the state of execution until we arrive at the desired
    outcome. That's imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Insanity is doing the same thing over and over again and expecting different
    results."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Albert Einstein'
  prefs: []
  type: TYPE_NORMAL
- en: We can use this insanity principle to our advantage with pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to variables during an imperative function's execution may
    result in the modification of a variable in the environment in which it has run.
    If we run the same imperative function again, using the same input, the result
    may differ.
  prefs: []
  type: TYPE_NORMAL
- en: Given the results of an imperative function and given the same input, different
    results may be returned each time it is run. Is that not insanity?
  prefs: []
  type: TYPE_NORMAL
- en: '**Pure functions**:'
  prefs: []
  type: TYPE_NORMAL
- en: Treat functions as first-class citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always return the same result given the same input(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have no side effects in the environment in which they run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not allow an external state to affect their results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not allow variable values to change over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two characteristics of a pure function include referential transparency and
    idempotence:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Referential transparency**: This is where a function call can be replaced with
    its corresponding value without changing the program''s behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Idempotence**: This is where a function call can be called repeatedly and
    produce the same result each time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referentially transparent programs are more easily optimized. Let's see whether
    we can perform optimizations using a caching technique and Go's concurrency features.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci sequence - a simple recursion and two performance improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fibonacci sequence is a sequence of numbers where each number is equal
    to the previous two numbers added together. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, 1 plus 1 is 2, 2 plus 3 is 5, 5 plus 8 is 13, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the Fibonacci sequence to help illustrate a number of concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A **recursive function** is a function that calls itself in order to break down
    complex input into simpler ones. With each recursive call, the input problem must
    be simplified in such a way that eventually the base case must be reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Fibonacci sequence can be easily implemented as a recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding recursive function (`Fibonacci`), if the input is the simple
    case of `0` then it returns **0. **Similarly, if the input is `1` or `2` then
    return **1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'An input of 0, 1 or 2 is called the **base case** or **stopping condition**;
    else, `fib` will call itself twice, adding the previous value in the sequence
    to the one preceding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e2ebf78-c7d6-4b9c-98cf-f30eb82b76c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Fibonacci(5) calculation graph
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure *Fibonacci(5) calculation graph*, we can visually see
    how the fifth element in the Fibonacci sequence is calculated. We see **f(3)**
    is calculated twice and **f(2)** is calculated thrice. Only the final leaf nodes
    of **1** are added together to calculate the sum total of **8**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run that code and you'll get `8`. Recursive functions perform identical calculations
    over and over again; **f(3)** is calculated twice and **f(2)** is calculated thrice.
    The deeper the graph, the more redundant calculations get executed. That is terribly
    inefficient. Try it yourself. Pass a value greater than 50 to `fib` and see how
    long you have to wait for the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go provides many ways to improve this performance. We''ll look at two options:
    memoization and concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is an optimization technique used to increase performance by storing
    the results of expensive function calls and returning the cached result when the
    same input occurs again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoization works well because of the following two properties of pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: They always return the same result given the same input(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have no side effects in the environment in which they run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's utilize a memoization technique to speed up our Fibonacci calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a function type named `Memoized()` and define our Fibonacci
    variable to be of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's implement the `Memoize()` function. The key thing to realize here
    is that as soon as our application starts, even before our `main()` function is
    executed, our `fibMem` variable get *wired up*. If we were to step through our
    code we'd see that our `Memoize` function is called. The cache variable is assigned
    and our anonymous function is returned and assigned to our `fibMem` function literal
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Memoize takes a `Memoized()` function type as its input and returns a `Memoized()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of Memoize, we create a variable of the type `map` to act
    as our cache in order to hold computed Fibonacci computations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a closure that is of the type `Memoized()`, which is *return*ed
    by the `Memoize()` function. Note that a **closure** is an inner function that
    closes over or that has access to variables in its outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the closure, if we find the computation for the passed integer, we return
    its value from the cache; else we call the recursive Fibonacci function *(*`mf`)
    with the integer parameter (`key`), whose return value will be stored in `cache[key]`.
    Next time, when the same key is requested its value will be returned directly
    from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: An anonymous function is a function defined with no name. When an anonymous
    function includes logic that can access variables defined in its scope, for example,
    `cache`, and if that anonymous function  can be passed as an argument or returned
    as the value of function calls, which is true in this case, then  we can refer
    to this anonymous function as a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll implement the logic of the Fibonacci Sequence in a function named `fib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we do in our `memoize.go` file is to create the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to see if our wiring works properly. In our `main()` function
    when we execute our `println` statement, we get the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can verify that 5 is the correct answer by glancing back at our `Fibonacci(5)`
    *calculation graph* shown earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to step through our code using a debugger, we'd see that `fibonacci.FibMemoized(5)`
    calls the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And the value of `n` variable is 5\. Since `fibMem` is pre-wired, we start
    executing at the return statement (and we have access to the `cache` variable
    that has already been initialized) . So, we begin executing at the `return` statement
    shown in the following code (from the `Memoize` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since this is the first time through, there are no entries in the cache and
    we skip past the body of the if block and run `temp := mf(key)`
  prefs: []
  type: TYPE_NORMAL
- en: 'That calls the `fib` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And since `x` is greater than 2 we run the last else statement that recursively
    calls `fib` twice. Recursive calls to `fib` continues until the base conditions
    are reached and the final result is calculated and returned.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between an anonymous function and a closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a few simple code examples to understand the difference between
    an anonymous function and a closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical named function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call them both and call an anonymous inline function to say `Hey`
    to Cindy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at a closure named `greeting` and see the difference between
    it and the `anonymousGreeting()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the closure function is declared in the same scope as the `msg` variable,
    the closure has access to it. The `msg` variable is said to be in the same environment
    as the closure; later, we''ll see that a closure''s environment variables and
    data can be passed around and referenced at a later time during a program''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, instead of executing the closure in the `greeting()` function,
    we will return it and assign its return value to the `hey` variable in the `main`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the timestamp is calculated when the `msg` variable is initialized,
    at the time the `greeting("bob")` value is assigned to the `hey` variable.
  prefs: []
  type: TYPE_NORMAL
- en: So, 10 seconds later, when `greeting` is called and the closure is executed,
    it will reference the message that was created 10 seconds ago.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how closures preserve state. Instead of manipulating the
    state in the outside environment, closures allow states to be created, passed
    around, and subsequently referenced.
  prefs: []
  type: TYPE_NORMAL
- en: With functional programming, you still have a state, but it's just passed through
    each function and is accessible even when the outer scopes, from where they originated,
    have already exited.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we'll see a more realistic example of how closures can be
    leveraged to maintain a context of application resources required by an API.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to speed up our recursive Fibonacci function is to use Go's concurrency
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: FP using Go's concurrency constructs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given the expression `result := function1() + function2()`, parallelization
    means that we can run each function on a different CPU core and the total time
    will be approximately the time it takes for the most expensive function to return
    its result. Consider the following explanation for parallelization and concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallelization**: Executing multiple functions at the same time (in different
    CPU cores)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: Breaking a program into pieces that can be executed independently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend that you check out the video* Concurrency is Not Parallelism*, by
    Rob Pike at [https://player.vimeo.com/video/49718712](https://player.vimeo.com/video/49718712).
    This is where he explains concurrency as a decomposition of a complex problem
    into smaller components, where individual components can be run simultaneously
    resulting in improved performance, assuming communication between them is managed.
  prefs: []
  type: TYPE_NORMAL
- en: Go enhances the concurrent execution of Goroutines with synchronization and
    messaging using channels and provides multiway concurrent control with the `Select`
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following language constructs provide a model in Go for concurrent software
    construction that is easy to understand, use, and reason about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goroutine**: A lightweight thread managed by the Go runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go statement**s: The `go` instruction that starts the execution of a function
    call as an independent concurrent thread of control, or Goroutine, in the same
    address space as the calling code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel**: A typed conduit through which you can send and receive values
    with the channel operator, namely `<-`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, `data` is sent to `channel` in the first line. In the
    second line, `data` is assigned the value received from `channel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since Go channels behave as FIFO queues, where the first items in are the first
    items out, and since the calculation for the next number in a Fibonacci sequence
    is a small component, it seems that our Fibonacci sequence function calculation
    is a great candidate for a concurrency implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give it a go. First, let''s define a `Channel` function that uses a
    channel to perform Fibonacci calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare the variables `n1` and `n2` to hold our initial sequence values
    of `0` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a loop for the total number of times given. In each loop, we
    send the next sequential number to the channel and calculate the next number in
    the sequence, until we reach our counter value, which is the last sequential number
    in our sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `FibChanneled` function creates a channel, namely `ch`, using
    the `make()` function and defines it as a channel that contains integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We run our `Channel` (Fibonacci) function as a Goroutine and pass it the `ch`
    channel and the `8` number, which tells `Channel` to produce the first eight numbers
    from the Fibonacci sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we range over the channel and print any values that the channel produces
    for as long as the channel has not been closed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a breather and examine what we've accomplished with our Fibonacci
    sequence examples.
  prefs: []
  type: TYPE_NORMAL
- en: Testing FP using test-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write some tests to verify each technique (simple recursive, memoized,
    and channeled) works properly. We'll use TDD to help us design and write better
    code.
  prefs: []
  type: TYPE_NORMAL
- en: TDD, a software development method where the developer starts with requirements
    and first writes a simple test that will fail. Then, it writes just enough code
    to make it pass. It continues this unit testing pattern repeatedly until there
    are no more reasonable tests that validate the code satisfies the requirements.
    The concept is to *get something working now and perfect it later*. After each
    test, refactoring is performed to implement a little more of the feature requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same or similar test(s) are performed again as well as introducing new
    test code to test the next piece of the feature. The process is iterated as many
    times as necessary until each unit is functioning according to the desired specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79c13566-2ba5-4090-8d9e-dd1619702ed7.png)'
  prefs: []
  type: TYPE_IMG
- en: TDD workflow diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start using a table of input values and their corresponding result values
    to verify that the function under test is working properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the Fibonacci sequence looks like this: `1  1  2  3  5  8  13  21
     34`. Here, the first element is `1 {1, 1}`, the second element is `2 {2, 2}`,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the range statement to iterate through the table, row by row, and check
    each calculated result (`v := FibSimple(ft.a)`) against the expected value (`ft.expected`)
    from that row.
  prefs: []
  type: TYPE_NORMAL
- en: Only if there is a mismatch do we report the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the `ex1_test.go` file, we find the benchmark testing facility in
    action, which allows us to examine the performance of our Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's open a terminal window and write the `cd` command to the first set of
    Go code, our book's source code repository. For me, that directory is `~/clients/packt/dev/fp-go/1-functional-fundamentals/ch01-pure-fp/01_fib`.
  prefs: []
  type: TYPE_NORMAL
- en: A note about paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first example, I used the `~/myprojects/fp-go` path. The path that I
    actually used to create the code in this book is `~/clients/packt/dev/fp-go`.
    So, please don't be confused by those paths. They are the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Also, later in the book, when we start using KISS-Glide, the screenshots may
    reference the `~/dev` directory. That comes from the init script, that is, `MY_DEV_DIR=~/dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few links in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For more information about KISS-Glide, see the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: How to run our tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first benchmark test, we examine the performance of computing the eighth
    number in the Fibonacci sequence. Note that we pass the `-bench=.` argument, which
    means run all benchmark tests. The `./...` argument means to run all the tests
    in this directory and all the child directories as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33f7376d-15ce-4343-87fb-d5118f43194d.png)'
  prefs: []
  type: TYPE_IMG
- en: When we request the eighth number in the sequence, the simple recursive implementation
    runs faster than the memoized and channeled (optimized) versions, `213 ns/op` compared
    to `1302 ns/op` and `2224 ns/op`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when the simple version is executed once, it only takes `3.94 ns/op`.
  prefs: []
  type: TYPE_NORMAL
- en: One very cool feature of Go's benchmark testing facility is that it is smart
    enough to figure out how many times to execute the function under test. The value
    of `b.N` will increase each time until the benchmark runner is satisfied with
    the stability of the benchmark. The faster the function runs under a test, the
    more times the benchmark facility will run it. The more times the benchmark facility
    runs a function, the more accurate the performance metric, for example, `3.94
    ns/op`.
  prefs: []
  type: TYPE_NORMAL
- en: Take the `FibSimple` test for example. When it is passed with `1`, it means
    it only needs to execute once. Since it only takes `3.94 ns/op`, we see it is
    executed 10,000,000 times. However, when `FibSimple` is passed with `40`, we see
    that it takes 2,509,110,502 ns to complete one operation, and the benchmark facility
    is smart enough to only run it once. That way, we can be assured that running
    benchmark tests is as accurate as possible and they run within a reasonable time.
    How nice is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `FibSimple` implementation is recursive and has not been optimized,
    we can test our assumption that the time it takes to calculate each successive
    number in the sequence will increase exponentially. We can do this using a common
    testing technique by calling the private function `benchmarkFibSimple`, which
    avoids directly invoking the test driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We test the first four numbers in the sequence, `20` and then `42`. Since it
    takes about 3 seconds for my computer to calculate the 42nd number in the sequence,
    I decided not to go any higher. No need to wait longer than that when we can easily
    see the exponential growth pattern, without having to wait for more than a minute
    to get our results.
  prefs: []
  type: TYPE_NORMAL
- en: Our benchmark testing has proven that our simple, recursive implementation of
    the Fibonacci sequence behaves as expected. This behavior equates to poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few ways to increase performance.
  prefs: []
  type: TYPE_NORMAL
- en: We have observed that our `FibSimple` implementation always returns the same
    result, given the same input(s), and that there are no side effects in the environment
    in which it runs. For example, if we pass `FibSimple` an `8` value, we know that
    every time the result will be `13`. We used this fact to leverage a caching technique
    called memoization to create the `FibMemoized` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's write some tests to see how effective `MemoizeFcn` is.
  prefs: []
  type: TYPE_NORMAL
- en: Since our `fibTests` structure has been defined in another test in our package,
    in `chapter1/_01_fib/ex1_test.go`, we don't need to define it again. This way,
    we only define the test table once, and we're able to reuse it in subsequent Fibonacci
    function implementations to get a reasonable apples-to-apples comparison of each
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the basic unit test for the `FibMemoized` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It won't return an error unless there is a bug in our code.
  prefs: []
  type: TYPE_NORMAL
- en: That's one of the great things about running unit tests. You don't hear about
    them unless something breaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should write unit tests in order to:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that what you implement meets your feature requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage testing to help you think about how best to implement your solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce quality tests that can be used in your constant integration process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that your implementation meets interface requirements with other parts
    of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make developing integration tests easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguard your work against other developers, who might implement a component
    that could break your code in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the benchmark tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, in the `FibSimple` example, we examine the performance of computing
    the eighth number in the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As before, we carry out a test calling `FibMemoized`, using `1`, `2`, `3`, `4`,
    `20`, and `42` as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete listing for the `FibChanelled` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We performed two optimizations on our original Fibonacci sequence logic using
    a caching technique and Go's concurrency features. We wrote both the optimization
    implementations. More optimizations are possible. In some cases, optimization
    techniques can be combined to produce even faster code.
  prefs: []
  type: TYPE_NORMAL
- en: What if all we had to do was write a simple recursive version and then when
    we compiled our Go code, the Go compiler would automatically generate object code
    with performance optimizations?
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation**: An evaluation strategy that delays the evaluation of an
    expression until its value is needed, which improves performance by avoiding needless
    calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: A journey from imperative programming to pure FP and enlightenment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a journey from imperative to a pure functional way of programming
    a `sum` function. First, let''s look at the imperative `sum` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The integer variable `sum` changes or mutates over time; `sum` is not immutable.
    There are no for loops or mutating variables in pure FP.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we iterate through a series of elements using pure FP? We can do
    this using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable variable**: A variable whose value is assigned during runtime and
    cannot be modified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Go does have constants, but they differ from immutable variables
    in that values are assigned to constants at compile time, rather than at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the last line of the preceding `SumRecursive` function calls itself:
    `SumRecursive(nums[1:])` . That''s recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark test for the imperative SumLoop function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have heard that recursion in Go can be slow. So, let''s write some benchmark
    tests to check it out. First, let''s test the performance of the basic imperative
    function `SumLoop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Results**: It took `46.1 ns/op`.'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark test for the SumRecursive function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know how long the imperative function `SumLoop` takes, let''s write
    a benchmark test to see how long our recursive version, namely `SumRecursive`,
    would take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**Results**: It took `178 ns/op`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tail call recursion is faster in languages such as Prolog, Scheme, Lua, and
    Elixir, and the ECMAScript 6.0-compliant JavaScript engines embrace the pure functional
    style of programming. So, let''s give it a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Results of the benchmark test**: It took `192 ns/op`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TCO**: A tail call is where the last statement of a function is a function
    call. An optimized tail call has been effectively replaced with a `GoTo` statement,
    which eliminates the work required to set up the call stack before the function
    call and restore it afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: We could even use `GoTo` statements to further speed up the tail call recursion,
    but it would still be three times slower than the imperative version.
  prefs: []
  type: TYPE_NORMAL
- en: Why? This is because Go does not provide pure FP support. For example, Go does
    not perform TCOs, nor does it provide immutable variables.
  prefs: []
  type: TYPE_NORMAL
- en: A time of reckoning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why would we want to use pure FP in Go? If writing expressive, easy-to-maintain,
    and insightful code is more important than performance, then perhaps.
  prefs: []
  type: TYPE_NORMAL
- en: What are our alternatives? Later, we'll look at some pure FP libraries that
    have done the heavy lifting for us and have made strides toward being more performant.
  prefs: []
  type: TYPE_NORMAL
- en: Is that all there is to functional programming in Go? No. Not by a long shot.
    What we can do with FP in Go is currently partially limited by the fact that the
    Go compiler currently does not support TCO; However, that may change soon. For
    details see the *How to Propose Changes To Go* section in the Appendix.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another aspect to functional programming that Go fully supports: function
    literals. And as it turns out, that is the single most important characteristic
    that a language must have to support FP.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function literals**: These are functions that are treated as first-class
    citizens of a language, for example, any variable type, such as int and string.
    In Go, functions can be declared as a type, assigned to variables and fields of
    a struct, passed as arguments to other functions, and returned as values from
    other functions. Function literals are closures, giving them access to the scope
    in which they are declared. When function literals are assigned to a variable
    at runtime, for example, `val := func(x int) int { return x + 2}(5)`, we can call
    that **anonymous function** a **function expression**. Function literals are used
    in lambda expressions along with currying. (For details about lambda expressions,
    see [Chapter 10](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*.)'
  prefs: []
  type: TYPE_NORMAL
- en: A quick example of a function literal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See that `{ret = n + 2}` is our anonymous function/function literal/closure/lambda
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: Is written like a function declaration, but without a function name following
    the `func` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is an expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has access to all the variables available in its lexical scope (`n` in our case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used the `defer` statement to delay the execution of our function
    literal until after its surrounding function (`curryAddTwo`) is returned. Since
    our anonymous function has access to all the variables in its scope (`n`), it
    can modify `n`. The modified value is what gets printed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing pure functions, we simply pass input arguments and verify the results.
    There is no environment or context to set up. There is no need for stubs or mocks.
    There are no side effects. Testing could not be easier.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions can be parallelized for performance gains in a horizontally scaled,
    multi-CPU environment. However, given that Go has not yet been optimized to support
    pure functional programming, a pure FP implementation in Go might not meet our
    performance requirements. We won't let that hinder us from leveraging Go's many
    effective non-pure functional programming techniques. We've already seen how we
    can gain performance by adding caching logic and leveraging Go's concurrency features.
    There are many functional patterns that we can use, and we'll soon see how. We'll
    also see how we can leverage them to meet stringent performance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about high-order functions as we explore different
    ways to manipulate collections using FP programming techniques.
  prefs: []
  type: TYPE_NORMAL
