- en: Scapy Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a packet with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving packets with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layering a packet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to a PCAP file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sniffing packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARP man-in-the-middle tool with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy is a powerful Python module for packet manipulation. It can decode and
    create packets for a wide variety of protocols. Scapy can be used for scanning,
    probing, and network discovery tasks inside Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a packet with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, the basic unit of network communication is a packet. So we can start
    by creating a packet with Scapy. Scapy creates packets in layers; each layer is
    nested inside its parent layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we require a Scapy module to be installed in the environment, make sure
    to install it with the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation, make sure it''s working by issuing the `scapy` command
    in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open up an interactive Terminal for Scapy. You can also use this
    for basic debugging of Scapy scripts. A list of all the protocols supported by
    Scapy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can get the details and parameters in each protocol, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the steps to create packets with the `scapy` module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `scapy-packet.py` and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, import the `scapy` module and `pprint` for better readable printing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Packets are crafted by defining the packet headers for each protocol layer
    of TCP/IP and stacking them in the correct order. So, we can create the first
    layer of a TCP packet with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create the IP layer of the packet, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As it''s the network layer, we have to pass the destination IP as the parameter.
    Scapy accepts different IP notations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plain dotted-quad notation:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'CIDR notation:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Hostnames:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can set multiple destinations by passing the destinations as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can create the transport layer. In our case, it is a TCP layer.
    We can create it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we pass the destination port and the flag is set to `S` for a SYN packet.
    We can also pass the destination ports as a list for creating multiple packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we can stack these layers with the `/` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can check the packets generated by printing them with `pprint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `ls()` to inspect a packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option to get the packet details is the `show()` method in the packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a single packet with a script. The script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will create a TCP/IP packet with the SYN flag set, the destination address [https://rejahrehim.com/](https://rejahrehim.com/),
    and the destination port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the script with the `sudo` permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see that `scapy` has identified the source IP as the local IP, and
    automatically added those details to the packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will have noticed, the first line of the response is a warning message
    saying `No route found for IPV6 destination`. We can avoid these less important
    messages by using the `logger` module. To do this, import and set the logging
    level to `ERROR` (which will only print the error messages) before importing Scapy.
    This can be achieved by adding the following lines at the top of the script. This
    step is applicable to all recipes that use the `scapy` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sending and receiving packets with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created some packets in the previous recipe. Now we can send
    and receive those packets with Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the methods to send and receive packets with `scapy` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `send()` function to send packets at layer 3\. In this case,
    Scapy will handle the routing and layer 2 within it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will send an ICMP packet
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a packet with custom layer 2, we have to use the `sendp()` method.
    Here we have to pass the interface to be used for sending the packet. We can provide
    it with the `iface` parameter. If this is not provided, it will use the default
    value from `conf.iface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a packet and receive a response, we have to use the `sr()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `sr1()` method to send a packet or group of packets, and to
    record only the first response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use `srloop()` to loop the process of sending stimulus packets,
    receive the response, and print them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Layering packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scapy, each packet is a collection of nested dictionaries, as Scapy uses
    Python dictionaries as the data structure for packets. Starting from the lowest
    layer, each layer will be a child dictionary of the parent layer. Also, each and
    every field inside the layer of a packet is a key value pair inside the dictionary
    for that layer. So, we can make changes in this field using the assignment operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the layering in Scapy, we can go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the details of a packet and its layered structure using the `show()`
    method. We can use the interactive Terminal for inspecting and determining more
    about each packet''s structure. Open up the Terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a packet and show its details, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it will print out the structure of the packet we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even if we don't provide the source addresses, Scapy automatically assigns the
    source address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the summary of a packet using the `summary()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get each layer of a packet through its list index or its name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Both will print the details of the TCP layer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can get each field inside the layers. We can get the destination
    IP address of a packet, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can test the existence of a specific layer with the `haslayer()`method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, can get a specific layer with the `getlayer()` method
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the Scapy `sniff()` function to sniff the network and the filter
    argument to get a specific type of packet from the sniffed packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing to pcap files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pcap files are used to save the captured packets for later use. We can read
    packets from a pcap file and write them to a pcap file using Scapy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can write a script to read and write pcap files with Scapy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import the pcap file to Scapy, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can iterate and work with the packets as we did for the created packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also manipulate the packets during the import itself. If we want to
    change the destination and source MAC address of the packets in the captured pcap
    file, we can do it while importing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a new function, `changePacketParameters(),` to iterate through
    each packet, and update its source and destination MAC addresses inside the Ethernet
    layer. Also, we will call that function inside the `sniff()` section as `prn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can export packets to a pcap file with the `wrpcap()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also filter the packets that we will write into a pcap file with Scapy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replay the packets captured in the pcap file with the `sendp()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can read and replay the packets with one line of code in Scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Sniffing packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy has a `sniff()` function that we can use for getting packets from the
    network. But Scapy's built-in `sniff()` function is a bit slow and may skip some
    packets. It is better to use `tcpdump` when the sniffing speed is important.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to write a sniffer with `scapy` module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `scapy-sniffer.py` and open it with your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, import the required modules for the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the variables required. Here we need to define the `interface`
    to sniff:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the `interface` to be used with the help of the `ifconfig` command
    in Linux and macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can write a function to handle the sniffed packets, which will be provided
    as the callback function for the sniffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here we get the source and destination IP of all the DNS packets, and extract
    the domain for those DNS packet
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the `sniff()` method to start sniffing and passing the packet
    to the callback function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will start sniffing for the packets from the interface specified in the
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start the script with the `sudo` permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can print the `payload` in the sniffed packet as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: ARP man-in-the-middle tool with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A man-in-the-middle attack means that the attacker sits between the source and
    destination to pass all the data through the attacking system. This will allow
    the attacker to view the victim's activities. We can write a small script in Python
    with the help of Scapy to run a man-in-the-middle attack.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For better understanding we can write a script, following the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `mitm-scapy.py` and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, import the required module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we import Scapy along with the `os`, `time`, and `sys` modules, which are
    required in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to define the variables for the script. We can get the variable
    details with the `raw_input` method in Python 2.x or `input()` in Python 3.x,
    rather than defining it in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have to get the MAC addresses of the source and destination to craft
    an ARP response, we will request both with an ARP request and parse the response
    to get the MAC addresses. Now we have to create a function to get the MAC addresses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will return the MAC address of the IP provided while calling this function
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will create a function to toggle the IP forwarding. This is different
    for Linux and macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For macOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to write another function to re-establish the connection between
    the victim and the source. This is to make sure that the interception is not identified
    by the victim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we first get the MAC addresses of both the source and the
    destination using the function we wrote: `getMAC()`. Then, we will send requests
    to the source as if was from the destination. Also, we will send requests to the
    destination as if it was from the source. Finally, we reset the IP forwarding
    with the function we wrote: `setIPForwarding()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will do the actual attack. For that we will write a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will send the packet to both the source and destination, indicating that
    our interface is the destination of the source and the source for the destination
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to set a callback function to parse the sniffed packets from
    the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will define the `main()` function to call the attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will create an infinite loop to set the attack and sniff the packets.
  prefs: []
  type: TYPE_NORMAL
