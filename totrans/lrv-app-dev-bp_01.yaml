- en: Chapter 1. Building a URL Shortener Website
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we will be using the Laravel PHP framework to build different
    types of web projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll see how to build a URL Shortener website with the basics
    of Laravel framework. The covered topics include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database and migrating our URL Shortener's table
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our form
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Link model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data to the database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting individual URL from the database and redirecting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a database and migrating our URL shortener's table
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Migrations are like version control for your application''s database. They
    permit a team (or yourself) to modify the database schema, and provide up-to-date
    information on the current schema state. To create and migrate your URL Shortener''s
    database, perform the following steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have to create a database, and define the connection information
    to Laravel. To do this, we open the `database.php` file under `app/config`, and
    then fill the required credentials. Laravel supports MySQL, SQLite, PostgreSQL,
    and SQLSRV (Microsoft SQL Server) by default. For this tutorial, we will be using
    MySQL.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will have to create a MySQL database. To do this, open your MySQL console
    (or phpMyAdmin), and write down the following query:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous command will generate a new MySQL database named `urls` for us.
    After having successfully generated the database, we will be defining the database
    credentials. To do this, open your `database.php` file under `app/config`. In
    that file, you will see multiple arrays being returned with database definitions.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `default` key defines what database driver to be used, and each database
    driver key holds individual credentials. We just need to fill the one that we
    will be using. In our case, I''ve made sure that the default key''s value is `mysql`.
    To set the connection credentials, we will be filling the value of the `mysql`
    key with our database name, username, and password. In our case, since we have
    a `database` named `urls`, with the `username` as `root` and without a password,
    our `mysql` connection settings in the `database.php` file will be as follows:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will be using the **Artisan CLI** to create migrations. Artisan is
    a command-line interface specially made for Laravel. It provides numerous helpful
    commands to help us in development. We''ll be using the following `migrate:make`
    command to create a migration on Artisan:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command has two parts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The first is `migrate:make create_links_table`. This part of the command creates
    a migration file which is named something like `2013_05_01_194506_create_links_table.php`.
    We'll examine the file further.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the command is `--table=links --create`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--table=links` option points to the database name.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--create` option is for creating the table on the database server to which
    we've given the `--table=links` option.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, unlike Laravel 3, when you run the previous command, it will
    create both the migrations table and our migration. You can access the migration
    file under `app/database/migrations`, having the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s inspect the sample migration file. There are two public functions which
    are declared as `up()` and `down()`. When you execute the following `migrate`
    command, the contents of the `up()` function will be executed:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will execute all of the migrations and create the `links` table
    in our case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you receive a `class not found` error when running the migration file, try
    running the `composer update` command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also roll back to the last migration, like it was never executed in
    the first place. We can do this by using the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In some cases, we may also want to roll back all migrations we have created.
    This can be done with the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While in the development stages, we may forget to add/remove some fields, or
    even forget to create some tables, and we may want to roll back everything and
    remigrate them all. This can be done using the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s add our fields. We''ve created two additional fields called `url`
    and `hash`. The `url` field will hold the actual URL, to which the URL present
    in the `hash` field will be redirected. The `hash` field will hold the shortened
    version of the URL that is present in the `url` field. The final content of the
    migration file is as shown in the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating our form
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's make our first form view.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Save the following code as `form.blade.php` under `app/views`. The file's extension
    is `blade.php` because we will be benefiting from Laravel 4's built-in template
    engine called **Blade**. There may be some methods you don't understand in the
    form yet, but don't worry. We will cover everything regarding this form in this
    chapter.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now save the following codes as `styles.css` under `public/assets/css`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code will produce you a form that looks like the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our form](graphics/2111OS_01_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have used a CSS file to tidy up the form a bit, but the actual
    part of the form is at the bottom of the `View` file, inside `div` with the ID
    of the container.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used the Laravel''s built-in `Form` class to generate a form, and we
    have used the `old()` method of the `Input` library. Now let''s dig the code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Form::open()`: It creates a `<form>` opening tag. Within the first provided
    parameter, you can define how the form is sent, and where it is going to be sent.
    It can be a controller''s action, a direct URL, or a named route.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Form::text()`: It creates an `<input>` tag with type as text. The first parameter
    is the name of the input, the second parameter is the value of the input, and
    within the array given in the third parameter, you can define assets and other
    attributes of the `<input>` tag.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input::old()`: It will return the old input from a form, after the form is
    returned with the inputs. The first parameter is the name of the old input submitted.
    In our case, if the form is returned after submission (for example, if the form
    validation fails), the text field will be filled with our old input and we can
    reuse it for later requests.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Form::close()`: It closes the `<form>` tag.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Link model
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To benefit from Laravel''s ORM class called `Eloquent`, we need to define a
    model. Save the following code as `Link.php` under `app/models`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Eloquent model is quite easy to understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The variable `$table` is used to define the table name for the model, but it's
    not compulsory. Even if we don't define this variable, it would use the plural
    form of the model name as a database table name. For example, if the model name
    was post, it would look for the post's table as default. This way, you can use
    any model names for the tables.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protected `$fillable` variable defines what columns can be (mass) created
    and updated. Laravel 4 blocks the mass-assignment of the values of all the columns
    with `Eloquent` by default. This way, for example, if you have a `users` table,
    and you are the only user/administrator, the mass-assignment protects your database
    from another user being added.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public `$timestamps` variable checks whether the model should try setting
    the timestamps `created_at` and `updated_at` by default, while creating and updating
    the query respectively. Since we don't need these features for our chapter, we
    will disable this by setting the value to `false`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now need to define this view to show whether we can navigate to our virtual
    host''s index page. You can do this either from the controllers defined in `routes.php`,
    or from `routes.php` directly. Since our application is small, defining them directly
    from `routes.php` should suffice. To define this, open the `routes.php` file under
    the `app` folder and add the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have a section starting with `Route::get('/', function()`, you
    should replace that section with the previous code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Laravel can listen `get`, `post`, `put`, and `delete` requests. Since our action
    is a `get` action (because we will be navigating through the browser without posting),
    our route type will be `get`, and because we want to show the view on the root
    page, our first parameter of the `Route::get()` method will be `/`, and we wrap
    a closure function as the second parameter to define what we want to do. In our
    case, we will be returning `form.blade.php` placed under `app/views` that we had
    generated before, so we just type `return View::make('form')`. This method returns
    the `form.blade.php` view from the `views` folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the view was in a subdirectory, it would be called `subfolder.form`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Saving data to the database
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to write a route that will have to listen to our `post` request.
    For this, we open our `routes.php` file under the `app` folder and add the following
    code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Validating the users' input
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `post` action function that we've coded now, we will be validating
    the user's input with the Laravel's built-in `Validation` class. This class helps
    us prevent invalid inputs from getting into our database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define a `$rules` array to set the rules for each field. In our case,
    we want the link to have a valid URL format. Then we can run the form validation
    using the `Validator::make()` method and assign it to the `$validation` variable.
    Let''s understand the parameters of the `Validator::make()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `Validator::make()` method takes an array of inputs
    and values to be validated. In our case, the whole form has only one field called
    link, so we've put the `Input::all()` method, which returns all the inputs from
    the form.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter takes the validation rules to be checked. The stored `$validation`
    variable holds some information for us. For example, we can check whether the
    validation has failed or passed (using `$validation->fails()` and `$validation->passes()`).
    These two methods return Boolean results, so we can easily check if the validation
    has passed or failed. Also, the `$validation` variable holds a method `messages()`,
    which contains the information of a failed validation. And we can catch them using
    `$validation->messages()`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the form validation fails, we redirect the user back to our index page (`return
    Redirect::to('/')`), which holds the URL shortener form, and we return some flash
    data back to the form. In Laravel, we do this by adding the `withVariableName`
    object to the redirected page. Using `with` is mandatory here, which will tell
    Laravel that we are returning something additional. We can do this for both redirecting
    and making views. If we are making views and showing some content to the end user,
    those `withVariableName` will be variables, and we can call them directly using
    `$VariableName`, but if we are redirecting to a page with the `withVariableName`
    object, `VariableName` will be a flash session data, and we can call it using
    the `Session` class (`Session::get('VariableName')`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In our example, to return the errors, we used a special method `withErrors($validation)`,
    instead of returning `$validation->messages()`. We could also return using that,
    but the `$errors` variable is always defined on views, so we can use our `$validation`
    variable as a parameter with `withErrors()` directly. The `withInput()` method
    is also a special method, which will return the results back to the form.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the user forgets one field in the form, and if the validation fails and shows
    the form again with error messages, using the `withInput()` method, the form can
    be filled with the old inputs again. To show these old inputs in Laravel, we use
    the `old()` method of the `Input` class. For example, `Input::old('link')` will
    return us the old input of the form field named `link`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Returning the messages to the view
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To return the error message back to the form, we can add the following HTML
    code into `form.blade.php`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can already guess, `Session::has('variableName')` returns a Boolean value
    to check whether there is a variable name for the session. Then, with the `first('formFieldName')`
    method of Laravel's `Validator` class, we are returning the first error message
    of a form field. In our case, we are showing the first error message of our `link`
    form field.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Diving further into controller and processing the form
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `else` part of the validation checking part that is executed when the form
    validation is completed successfully in our example, holds the further processing
    of the link. In this section, we will perform the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the link is already in our database.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the link is already in our database, returning the shortened link.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the link is not present in our database, creating a new random string (the
    hash that will be in our URL) for the link.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new record in our database with the provided values.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the shortened link back to the user.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's dig the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the first part of our code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we check if the URL is already present in our database using the `where()`
    method of **Fluent Query Builder** , and get the first result via the method `first()`,
    and assign it to the `$link` variable. You can use the Fluent query methods along
    with the Eloquent ORM easily. If this confuses you, don't worry, we will cover
    this further in the later chapters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the next part of our controller method''s code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we have the URL saved in our database, the `$link` variable will hold the
    object of our link's information taken from the database. So with a simple `if()`
    clause, we can check if there is a result. If there is a result returned, we can
    access it using `$link->columnname`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, if the query has a result, we redirect the inputs and the link
    back to the form. As we''ve used here, the `with()` method can also be used with
    two parameters instead of using a camel case—`withName(''value'')` is exactly
    the same as `with(''name'',''value'')`. So, we can return the hash code with a
    flash data named link `with(''link'',$link->hash)`. To show this, we can add the
    following code to our form:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Html` class helps us write HTML codes easily. The `link()` method requires
    the following two parameters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is `link`. If we provide a string directly (the hash string
    in our case), the class will identify it automatically and make an internal URL
    from our website.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the string that has the link.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional third parameter has to be an array, holding attributes (such as
    class, ID, and target) as a two-dimensional array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the next part of our code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If there is no result (the else clause of the variable), we are creating a six-character-long
    alphanumeric random string with the `Str` class's `random()` method and checking
    it each time to make sure that it is a unique string, using PHP's own do-while
    statement. For real world application, you can use an alternative method to shorten,
    for example, converting an entry in the ID column to base_62 and using it as a
    hash value. This way, the URL would be cleaner, and it's always a better practice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the next part of our code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once we have a unique hash, we can add the link and the hash values to the database
    with the `create()` method of the Laravel's Eloquent ORM. The only parameter should
    be a two-dimensional array, in which the keys of the array are holding the database
    column names, and the values of the array are holding the values to be inserted
    as a new row.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了唯一的哈希，我们可以使用Laravel的Eloquent ORM的`create()`方法将链接和哈希值添加到数据库中。唯一的参数应该是一个二维数组，其中数组的键保存数据库列名，数组的值保存要插入为新行的值。
- en: In our case, the `url` column has to have the `link` field's value that came
    from the form. We can catch these values that came from the `post` request using
    Laravel's `Input` class's `get()` method. In our case, we can catch the value
    of the `link` form field that came from the `post` request (which we would catch
    using the spaghetti code `$_POST['link']`) using `Input::get('link')`, and return
    the hash value to the view as we did earlier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`url`列必须具有来自表单的`link`字段的值。我们可以使用Laravel的`Input`类的`get()`方法捕获来自`post`请求的这些值。在我们的情况下，我们可以使用`Input::get('link')`捕获来自`post`请求的`link`表单字段的值（我们可以使用`$_POST['link']`的混乱代码捕获），并像之前一样将哈希值返回给视图。
- en: 'This is the final part of our code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们代码的最后部分：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, at the output, we're redirected to `oursite.dev/hashcode`. There is a link
    stored in the variable `$newHash`; we need to catch this hash code and query our
    database, and if there is a record, we need to redirect to the actual URL.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在输出中，我们被重定向到`oursite.dev/hashcode`。变量`$newHash`中存储了一个链接；我们需要捕获这个哈希码并查询我们的数据库，如果有记录，我们需要重定向到实际的URL。
- en: Getting individual URL from the database and redirecting
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中获取单个URL并重定向
- en: 'Now, in the final part of our first chapter, we need to get the `hash` part
    from the generated URL, and if there is a value, we need to redirect it to the
    URL which is stored in our database. To do this, add the following code at the
    end of your `routes.php` file under the `app` folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们第一章的最后部分，我们需要从生成的URL中获取`hash`部分，如果有值，我们需要将其重定向到存储在我们数据库中的URL。为此，请在`app`文件夹下的`routes.php`文件末尾添加以下代码：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the previous code, unlike other route definitions, we added curly brackets
    around the name `hash`, which tells Laravel that it''s a parameter; and with the
    `where()` method we defined how the name parameter will be. The first parameter
    is the name of the variable (which is `hash` in our case), and the second parameter
    is a regular expression that will filter the parameter. In our case, the regular
    expression filters an exact alphanumeric string that is six-characters long. This
    way, we can filter our URLs and secure them from start, and we won''t have to
    check if the `url` parameter has something we don''t want (for example, if alphabets
    are entered instead of numbers in the ID column). To get individual URL from the
    database and redirect, we perform the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，与其他路由定义不同，我们在名称`hash`周围添加了花括号，告诉Laravel它是一个参数；并且使用`where()`方法定义了名称参数的方式。第一个参数是变量的名称（在我们的情况下是`hash`），第二个参数是一个正则表达式，用于过滤参数。在我们的情况下，正则表达式过滤了一个精确的六个字符长的字母数字字符串。这样，我们可以过滤我们的URL并从一开始就保护它们，而且我们不必检查`url`参数是否有我们不想要的内容（例如，在ID列中输入字母而不是数字）。要从数据库中获取单个URL并重定向，我们执行以下步骤：
- en: In the `Route` class, we first make a search query, as we did in the earlier
    section, and check if we have a link with the given hash from a URL in our database,
    and set it to a variable called `$link`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Route`类中，我们首先进行搜索查询，就像在前面的部分中所做的那样，然后检查我们的数据库中是否有一个具有给定哈希的链接，并将其设置为名为`$link`的变量。
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If there is a result, we redirect the page to the `url` column of our database,
    which has the link to which the user should be redirected.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有结果，我们将页面重定向到我们数据库的`url`列，该列包含用户应重定向到的链接。
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there is no result, we redirect the user back to our index page using the
    `$message` variable, which holds the value `Invalid Link`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有结果，我们将使用`$message`变量将用户重定向回我们的索引页面，该变量保存了`Invalid Link`的值。
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To show the `Invalid Link` message in the form, add the following code in your
    `form.blade.php` file placed under `app/views`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在表单中显示`Invalid Link`消息，请在`app/views`下的`form.blade.php`文件中添加以下代码。
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered the basic usage of Laravel's routes, models,
    artisan commands, and database drivers by making a simple URL shortener website.
    Once you've followed this chapter, you can now create database tables with migrations,
    write simple forms with the Laravel Form Builder Class, validate these forms with
    the `Validation` class, and process these forms and insert new data to the table(s)
    with the Fluent Query Builder or Eloquent ORM. In the next chapter, we'll cover
    the advanced usage of these awesome features.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过制作一个简单的URL缩短网站，介绍了Laravel路由、模型、artisan命令和数据库驱动的基本用法。一旦您完成了本章，您就可以使用迁移创建数据库表，使用Laravel表单构建器类编写简单的表单，使用`Validation`类验证这些表单，并使用Fluent查询构建器或Eloquent
    ORM处理这些表单并将新数据插入表中。在下一章中，我们将介绍这些强大功能的高级用法。
