- en: Chapter 1. Building a URL Shortener Website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we will be using the Laravel PHP framework to build different
    types of web projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll see how to build a URL Shortener website with the basics
    of Laravel framework. The covered topics include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database and migrating our URL Shortener's table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Link model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting individual URL from the database and redirecting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a database and migrating our URL shortener's table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Migrations are like version control for your application''s database. They
    permit a team (or yourself) to modify the database schema, and provide up-to-date
    information on the current schema state. To create and migrate your URL Shortener''s
    database, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we have to create a database, and define the connection information
    to Laravel. To do this, we open the `database.php` file under `app/config`, and
    then fill the required credentials. Laravel supports MySQL, SQLite, PostgreSQL,
    and SQLSRV (Microsoft SQL Server) by default. For this tutorial, we will be using
    MySQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will have to create a MySQL database. To do this, open your MySQL console
    (or phpMyAdmin), and write down the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will generate a new MySQL database named `urls` for us.
    After having successfully generated the database, we will be defining the database
    credentials. To do this, open your `database.php` file under `app/config`. In
    that file, you will see multiple arrays being returned with database definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `default` key defines what database driver to be used, and each database
    driver key holds individual credentials. We just need to fill the one that we
    will be using. In our case, I''ve made sure that the default key''s value is `mysql`.
    To set the connection credentials, we will be filling the value of the `mysql`
    key with our database name, username, and password. In our case, since we have
    a `database` named `urls`, with the `username` as `root` and without a password,
    our `mysql` connection settings in the `database.php` file will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will be using the **Artisan CLI** to create migrations. Artisan is
    a command-line interface specially made for Laravel. It provides numerous helpful
    commands to help us in development. We''ll be using the following `migrate:make`
    command to create a migration on Artisan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The command has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is `migrate:make create_links_table`. This part of the command creates
    a migration file which is named something like `2013_05_01_194506_create_links_table.php`.
    We'll examine the file further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the command is `--table=links --create`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--table=links` option points to the database name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--create` option is for creating the table on the database server to which
    we've given the `--table=links` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, unlike Laravel 3, when you run the previous command, it will
    create both the migrations table and our migration. You can access the migration
    file under `app/database/migrations`, having the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect the sample migration file. There are two public functions which
    are declared as `up()` and `down()`. When you execute the following `migrate`
    command, the contents of the `up()` function will be executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will execute all of the migrations and create the `links` table
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you receive a `class not found` error when running the migration file, try
    running the `composer update` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also roll back to the last migration, like it was never executed in
    the first place. We can do this by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, we may also want to roll back all migrations we have created.
    This can be done with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While in the development stages, we may forget to add/remove some fields, or
    even forget to create some tables, and we may want to roll back everything and
    remigrate them all. This can be done using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add our fields. We''ve created two additional fields called `url`
    and `hash`. The `url` field will hold the actual URL, to which the URL present
    in the `hash` field will be redirected. The `hash` field will hold the shortened
    version of the URL that is present in the `url` field. The final content of the
    migration file is as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating our form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's make our first form view.
  prefs: []
  type: TYPE_NORMAL
- en: Save the following code as `form.blade.php` under `app/views`. The file's extension
    is `blade.php` because we will be benefiting from Laravel 4's built-in template
    engine called **Blade**. There may be some methods you don't understand in the
    form yet, but don't worry. We will cover everything regarding this form in this
    chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now save the following codes as `styles.css` under `public/assets/css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce you a form that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our form](graphics/2111OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have used a CSS file to tidy up the form a bit, but the actual
    part of the form is at the bottom of the `View` file, inside `div` with the ID
    of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used the Laravel''s built-in `Form` class to generate a form, and we
    have used the `old()` method of the `Input` library. Now let''s dig the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Form::open()`: It creates a `<form>` opening tag. Within the first provided
    parameter, you can define how the form is sent, and where it is going to be sent.
    It can be a controller''s action, a direct URL, or a named route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Form::text()`: It creates an `<input>` tag with type as text. The first parameter
    is the name of the input, the second parameter is the value of the input, and
    within the array given in the third parameter, you can define assets and other
    attributes of the `<input>` tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input::old()`: It will return the old input from a form, after the form is
    returned with the inputs. The first parameter is the name of the old input submitted.
    In our case, if the form is returned after submission (for example, if the form
    validation fails), the text field will be filled with our old input and we can
    reuse it for later requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Form::close()`: It closes the `<form>` tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Link model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To benefit from Laravel''s ORM class called `Eloquent`, we need to define a
    model. Save the following code as `Link.php` under `app/models`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Eloquent model is quite easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `$table` is used to define the table name for the model, but it's
    not compulsory. Even if we don't define this variable, it would use the plural
    form of the model name as a database table name. For example, if the model name
    was post, it would look for the post's table as default. This way, you can use
    any model names for the tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protected `$fillable` variable defines what columns can be (mass) created
    and updated. Laravel 4 blocks the mass-assignment of the values of all the columns
    with `Eloquent` by default. This way, for example, if you have a `users` table,
    and you are the only user/administrator, the mass-assignment protects your database
    from another user being added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public `$timestamps` variable checks whether the model should try setting
    the timestamps `created_at` and `updated_at` by default, while creating and updating
    the query respectively. Since we don't need these features for our chapter, we
    will disable this by setting the value to `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now need to define this view to show whether we can navigate to our virtual
    host''s index page. You can do this either from the controllers defined in `routes.php`,
    or from `routes.php` directly. Since our application is small, defining them directly
    from `routes.php` should suffice. To define this, open the `routes.php` file under
    the `app` folder and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have a section starting with `Route::get('/', function()`, you
    should replace that section with the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel can listen `get`, `post`, `put`, and `delete` requests. Since our action
    is a `get` action (because we will be navigating through the browser without posting),
    our route type will be `get`, and because we want to show the view on the root
    page, our first parameter of the `Route::get()` method will be `/`, and we wrap
    a closure function as the second parameter to define what we want to do. In our
    case, we will be returning `form.blade.php` placed under `app/views` that we had
    generated before, so we just type `return View::make('form')`. This method returns
    the `form.blade.php` view from the `views` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the view was in a subdirectory, it would be called `subfolder.form`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to write a route that will have to listen to our `post` request.
    For this, we open our `routes.php` file under the `app` folder and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Validating the users' input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `post` action function that we've coded now, we will be validating
    the user's input with the Laravel's built-in `Validation` class. This class helps
    us prevent invalid inputs from getting into our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define a `$rules` array to set the rules for each field. In our case,
    we want the link to have a valid URL format. Then we can run the form validation
    using the `Validator::make()` method and assign it to the `$validation` variable.
    Let''s understand the parameters of the `Validator::make()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `Validator::make()` method takes an array of inputs
    and values to be validated. In our case, the whole form has only one field called
    link, so we've put the `Input::all()` method, which returns all the inputs from
    the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter takes the validation rules to be checked. The stored `$validation`
    variable holds some information for us. For example, we can check whether the
    validation has failed or passed (using `$validation->fails()` and `$validation->passes()`).
    These two methods return Boolean results, so we can easily check if the validation
    has passed or failed. Also, the `$validation` variable holds a method `messages()`,
    which contains the information of a failed validation. And we can catch them using
    `$validation->messages()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the form validation fails, we redirect the user back to our index page (`return
    Redirect::to('/')`), which holds the URL shortener form, and we return some flash
    data back to the form. In Laravel, we do this by adding the `withVariableName`
    object to the redirected page. Using `with` is mandatory here, which will tell
    Laravel that we are returning something additional. We can do this for both redirecting
    and making views. If we are making views and showing some content to the end user,
    those `withVariableName` will be variables, and we can call them directly using
    `$VariableName`, but if we are redirecting to a page with the `withVariableName`
    object, `VariableName` will be a flash session data, and we can call it using
    the `Session` class (`Session::get('VariableName')`).
  prefs: []
  type: TYPE_NORMAL
- en: In our example, to return the errors, we used a special method `withErrors($validation)`,
    instead of returning `$validation->messages()`. We could also return using that,
    but the `$errors` variable is always defined on views, so we can use our `$validation`
    variable as a parameter with `withErrors()` directly. The `withInput()` method
    is also a special method, which will return the results back to the form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the user forgets one field in the form, and if the validation fails and shows
    the form again with error messages, using the `withInput()` method, the form can
    be filled with the old inputs again. To show these old inputs in Laravel, we use
    the `old()` method of the `Input` class. For example, `Input::old('link')` will
    return us the old input of the form field named `link`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the messages to the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To return the error message back to the form, we can add the following HTML
    code into `form.blade.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can already guess, `Session::has('variableName')` returns a Boolean value
    to check whether there is a variable name for the session. Then, with the `first('formFieldName')`
    method of Laravel's `Validator` class, we are returning the first error message
    of a form field. In our case, we are showing the first error message of our `link`
    form field.
  prefs: []
  type: TYPE_NORMAL
- en: Diving further into controller and processing the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `else` part of the validation checking part that is executed when the form
    validation is completed successfully in our example, holds the further processing
    of the link. In this section, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the link is already in our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the link is already in our database, returning the shortened link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the link is not present in our database, creating a new random string (the
    hash that will be in our URL) for the link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new record in our database with the provided values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the shortened link back to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's dig the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the first part of our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we check if the URL is already present in our database using the `where()`
    method of **Fluent Query Builder** , and get the first result via the method `first()`,
    and assign it to the `$link` variable. You can use the Fluent query methods along
    with the Eloquent ORM easily. If this confuses you, don't worry, we will cover
    this further in the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the next part of our controller method''s code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we have the URL saved in our database, the `$link` variable will hold the
    object of our link's information taken from the database. So with a simple `if()`
    clause, we can check if there is a result. If there is a result returned, we can
    access it using `$link->columnname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, if the query has a result, we redirect the inputs and the link
    back to the form. As we''ve used here, the `with()` method can also be used with
    two parameters instead of using a camel case—`withName(''value'')` is exactly
    the same as `with(''name'',''value'')`. So, we can return the hash code with a
    flash data named link `with(''link'',$link->hash)`. To show this, we can add the
    following code to our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Html` class helps us write HTML codes easily. The `link()` method requires
    the following two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is `link`. If we provide a string directly (the hash string
    in our case), the class will identify it automatically and make an internal URL
    from our website.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the string that has the link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional third parameter has to be an array, holding attributes (such as
    class, ID, and target) as a two-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the next part of our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If there is no result (the else clause of the variable), we are creating a six-character-long
    alphanumeric random string with the `Str` class's `random()` method and checking
    it each time to make sure that it is a unique string, using PHP's own do-while
    statement. For real world application, you can use an alternative method to shorten,
    for example, converting an entry in the ID column to base_62 and using it as a
    hash value. This way, the URL would be cleaner, and it's always a better practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the next part of our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once we have a unique hash, we can add the link and the hash values to the database
    with the `create()` method of the Laravel's Eloquent ORM. The only parameter should
    be a two-dimensional array, in which the keys of the array are holding the database
    column names, and the values of the array are holding the values to be inserted
    as a new row.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the `url` column has to have the `link` field's value that came
    from the form. We can catch these values that came from the `post` request using
    Laravel's `Input` class's `get()` method. In our case, we can catch the value
    of the `link` form field that came from the `post` request (which we would catch
    using the spaghetti code `$_POST['link']`) using `Input::get('link')`, and return
    the hash value to the view as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final part of our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, at the output, we're redirected to `oursite.dev/hashcode`. There is a link
    stored in the variable `$newHash`; we need to catch this hash code and query our
    database, and if there is a record, we need to redirect to the actual URL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting individual URL from the database and redirecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in the final part of our first chapter, we need to get the `hash` part
    from the generated URL, and if there is a value, we need to redirect it to the
    URL which is stored in our database. To do this, add the following code at the
    end of your `routes.php` file under the `app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, unlike other route definitions, we added curly brackets
    around the name `hash`, which tells Laravel that it''s a parameter; and with the
    `where()` method we defined how the name parameter will be. The first parameter
    is the name of the variable (which is `hash` in our case), and the second parameter
    is a regular expression that will filter the parameter. In our case, the regular
    expression filters an exact alphanumeric string that is six-characters long. This
    way, we can filter our URLs and secure them from start, and we won''t have to
    check if the `url` parameter has something we don''t want (for example, if alphabets
    are entered instead of numbers in the ID column). To get individual URL from the
    database and redirect, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Route` class, we first make a search query, as we did in the earlier
    section, and check if we have a link with the given hash from a URL in our database,
    and set it to a variable called `$link`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If there is a result, we redirect the page to the `url` column of our database,
    which has the link to which the user should be redirected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If there is no result, we redirect the user back to our index page using the
    `$message` variable, which holds the value `Invalid Link`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the `Invalid Link` message in the form, add the following code in your
    `form.blade.php` file placed under `app/views`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the basic usage of Laravel's routes, models,
    artisan commands, and database drivers by making a simple URL shortener website.
    Once you've followed this chapter, you can now create database tables with migrations,
    write simple forms with the Laravel Form Builder Class, validate these forms with
    the `Validation` class, and process these forms and insert new data to the table(s)
    with the Fluent Query Builder or Eloquent ORM. In the next chapter, we'll cover
    the advanced usage of these awesome features.
  prefs: []
  type: TYPE_NORMAL
