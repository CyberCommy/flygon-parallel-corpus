- en: Chapter 3. Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns are one of the three types of design pattern commonly
    associated with the Gang of Four; they are design patterns that concern object
    creation mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating objects or basic class creation on their own, without controlling
    this process, can result in design problems or simply add additional complexity
    to the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The software design process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we learn about Creational design patterns, let's talk a little about
    the architectural process.
  prefs: []
  type: TYPE_NORMAL
- en: Software design process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Software Engineering Body of Knowledge* is a book published by the *IEEE*
    often known as the **SWEBoK**, and it summarizes the generally accepted body of
    knowledge for the entire field of software engineering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, it is stated that the definition of software design is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The process of defining the architecture, components, interfaces, and other
    characteristics of a system or component" and "the result of [that] process".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Specifically, software design can be split into two levels of hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: Architectural design, describing how software is split into its composite components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed design, describing the specifics of each component in sufficient detail
    as to describe its component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component is a part of a software solution, with interfaces reaching off the
    component as both *required interfaces* (things the software requires to function)
    and *provided interfaces* (things the software provides to other components).
  prefs: []
  type: TYPE_NORMAL
- en: These two design processes (Architectural design and Detailed design) should
    result in a set of models and artifacts that record major decisions, with an explanation
    of why non-trivial decisions have been made. In the future, developers may then
    readily reference these documents in order to work out the rationale behind architectural
    decisions, making code more maintainable by ensuring decisions are thought through,
    and that thought process is passed down.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these processes, Architectural design, can be fairly creative and
    engaging for an entire group. The outcome of this process, however you choose
    to do it, should be a component diagram that interconnects components together
    by their interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This process usually can favor groups of general developers instead of tiger
    teams. *Tiger teams* are usually small groups of a specialist in a particular
    domain of product knowledge, who come together in a time-boxed environment to
    address a particular issue under the chairmanship of an architect. Often, especially
    where legacy is involved, such design efforts may require a wide body of knowledge
    to extract the necessary architectural constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This said, in order to prevent the process turning into the design by committee
    or mob rule there are some ground rules that you might want to follow: have an
    architect chair the meeting and work from the component level diagram without
    drilling any further. It often helps to mock up a component diagram before the
    meeting and to edit it as needed in the meeting itself, which helps ensure the
    team remains on track to correcting the diagram without drilling into the hows.'
  prefs: []
  type: TYPE_NORMAL
- en: In one environment I have been in, there was a very detailed engineer who was
    head of the engineering team; he insisted on doing architecture by immediately
    drilling into the detail of components, which would rapidly leave the process
    disintegrated and unorganized; he would be starting *meetings in meetings* on
    the fly. Building component diagrams in these architecture meetings proved vital
    in keeping order in the meetings and ensuring both operational matters and Detailed
    design matters were not engaged with too early. Operational matters of how and
    where something is hosted is not usually within the remit of software engineering unless
    it directly has to alter how software is created.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is Detailed design; this explains how a component is constructed.
    Design patterns used in construction, class diagrams and the necessary external
    resources can all be decided at this point. Some Detailed design work will be
    done at the construction level, regardless of how good the design is, software
    developers will need to make minor changes to the design to either add more detail
    or to flesh out some oversights in the architecture process. The process that
    is prior to this design must simply specify the component in sufficient detail
    to facilitate its construction and allow developers to not have to consider the
    architecture in too much detail. Developers should be developing code from artifacts
    that are closely related to the code (for example, Detailed designs) as opposed
    to coding from high-level requirements, designs, or plans.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, let's remember that unit tests can form part of the design (for
    example, when utilizing Test-Driven Development), with each unit test specifying
    a design element (classes, methods, and specific behavior). While it simply isn't
    realistic (though some will claim it is) to reverse engineer the code into the
    design artifacts; it is possible to represent *architecture as code*, if you will;
    unit tests are one such way of achieving this.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in this book, design patterns provide a crucial role in
    software design; they allow the design of more complicated bits of software without
    re-inventing the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Right; now to Creational design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a factory? Let's imagine you order a new car; the dealer sends your
    order off to the factory and the factory builds your car. Your car is sent to
    you in its assembled form and you don't need to care about how it was made.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a software factory produces objects for you. The factory takes your
    request, assembles the object using the constructor and gives them back to you
    to use. One of these types of Factory pattern is known as the **Simple Factory**.
    Let me show you how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we define an abstract class, which we want to extend with other classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class serves to allow us to have common methods and define whatever common
    functionality we want all the classes we build in our factory to have in common.
    We could also use interfaces instead of abstract classes for the implementation
    without defining any functionality whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Using this interface, we can build two notifiers, `SMS` and `Email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SMS` notifier is as follows in the `SMS.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s put out `Email` notifier in the `Email.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build our factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While we would ordinarily use Composer to do autoloading, in order to demonstrate
    how simple this method is, I will manually include the dependencies; so without
    further ado, here''s our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple Factory](graphics/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory Method differs from the ordinary Simple Factory on the basis that
    instead of us having one factory, we can have many.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why would you want to do this? Well, in order to understand this, we must
    look to the open/closed principle (OCP). Bertrand Meyer is usually associated
    with having originated the term *open/closed principle* in his book, *Object-oriented
    Software Construction*. Meyer stated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"software entities (classes, modules, functions, etc.) should be open for
    extension, but closed for modification"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where a software entity needs to be extended, this should be possible without
    modifying its source code. Those of you who are familiar with the **SOLID** (**single
    responsibility**, **open-closed**, **Liskov substitution**, **interfacesegregation**
    and **dependency inversion**) principles of object-oriented software may already
    have heard of this principle.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Method allows you to group certain classes together and deal with
    them by means of an individual factory for a group of classes. If you want to
    add another group, you can just add another factory.
  prefs: []
  type: TYPE_NORMAL
- en: So now, how do we do this? Well, essentially we are going to create an interface
    for each factory (or an abstract method for that matter); we then implement that
    interface into any other factories we want to build.
  prefs: []
  type: TYPE_NORMAL
- en: So let's clone our Simple Factory demo; what we're going to do is make our `NotifierFactory`
    become an interface. Then we can rebuild factories to have one factory for electronic
    notifications (e-mail or SMS) and we can then implement our interface to create,
    say, a postal courier notifier factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start off by creating the interface in the `NotifierFactory.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s build our `ElectronicNotifierFactory` that implements our `NotifierFactory`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now refactor our `index.php` to use the new factory we have made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This now gives the same output as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the benefit now is that we can now add a new type of notifier without
    ever needing to open the factory at all, so let''s add a new notifier for postal
    communications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can introduce the `CourierNotifierFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can now amend our `index.php` file to include this new format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.php` file now yields this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory Method](graphics/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In production, you would generally put your notifiers in a different namespace
    alongside having your Factories in a different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, if you've done any background reading before approaching this book, you
    will have heard the phrase *concrete class*. What does this mean? Well, simply
    put, it is the opposite of an abstract class; it is a class you can instantiate
    to make an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Abstract Factory consists of the following classes: an Abstract Factory,
    Concrete Factory, Abstract Product, Concrete Product, and our client.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Factory pattern, we produced implementations of a particular interface
    (for example, `notifier` was our interface and e-mail, SMS and post were our implementations).
    With an Abstract Factory pattern, we will create implementations of a factory
    interface, with every factory knowing how to create their products.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have two toy factories, one in San Francisco and one in London. They
    both know how to create both company's products for both locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, our `ToyFactory` interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this is done, we can build our San Francisco toy factory (`SFToyFactory`)
    to serve as our Concrete Factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add our British toy factory (`UKToyFactory`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you notice, we are creating various toys within the Toys namespace, so now
    we can put together our abstract methods for our toys. Let''s start with our `Toy`
    class. Every toy will eventually extend this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the two types of toy we declared in our `ToyFactory` interface at
    the start (maze and puzzle), we can declare their abstract methods, starting with
    our `Maze` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s do our `Puzzle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time for our concrete classes, so let's start with our implementations
    for San Francisco.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `SFMazeToy` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the code for the `SFPuzzleToy` class, a different implementation
    to the `Maze` toy'' class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can now finish this off with our implementations for the British factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by making one for the maze toy, `UKMazeToy.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s make a class for the puzzle toy too, `UKPuzzleToy.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now; let''s put this all together in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, if you run the given code, should look like the output shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract Factory pattern](graphics/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, suppose we want to add a new factory with a new set of products (for, say,
    New York), we simply add the toys `NYMazeToy` and the `NYPuzzleToy`, we could
    then create a new Factory called `NYToyFactory` (implementing the `ToyFactory`
    interface) and we would be done.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the downsides of this class emerge when you need to add new product classes;
    the Abstract Factory needs updating, which violates the interface segregation
    principle. So it doesn't strictly meet the SOLID principles if you are going to
    need to add new product classes.
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern can take some time to fully appreciate, so be sure to fiddle
    around with the source code and see what you can do with it.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slappy Joe's burgers is a high quality restaurant where burgers are priced after
    they are made using the exact weight of the meat that was used. Unfortunately,
    due to the level of creation time, it would be a massive drain on resources for
    them to make every single type of burger before they are ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having every type of burger ready for someone to order, when someone
    orders the burger, it is made (if it isn't already) and they are charged the price
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Burger.php` class is structured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the price of the burger is only calculated after it is instantiated,
    meaning the customer can't be charged until it is made. The other function in
    the class simply returns the price of the burger.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of instantiating from the `Burger` class directly, a lazy initialization
    class called `BurgerLazyLoader.php` is made, this class stores a list of instances
    of each burger that has been made; if a burger is requested that isn't made, it
    will make it. Alternatively, if a burger of a particular configuration already
    exists, that burger is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `LazyLoader` class which instantiates `Burger` objects as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The only other function added is the `getBurgerCount` function that returns
    a count of all the instances in the instances the `LazyLoader` has.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s wrap all of this together in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy initialization](graphics/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Given how the prices are random, you will notice the figures will be different,
    but the prices for the burger with cheese and fries remains the same the first
    and last time you call it. The instance is only created once; moreover, it is
    only created when it is needed, instead of being instantiated whenever it is wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Hypothetical burger shop aside, this Creational pattern can have some great
    uses when you need it, such as when you need to delay the construction of an object
    from a class. This is often used when the constructor is an expensive or time-consuming
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: If an object isn't already able to be used, one is created in a just-in-time
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we reviewed the Factory design patterns, we saw how they were useful for
    enabling polymorphism. The crucial differentiation between Factory patterns and
    the Builder pattern is that the Builder pattern solely has the aim of resolving
    one anti-pattern and does not seek to perform polymorphism. The anti-pattern in
    question is the Telescoping Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The Telescoping Constructor problem is essentially where the count of arguments
    a constructor contains grows to an extent where it becomes impractical to use
    or even impractical to know which order the arguments go in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have a `Pizza` class as follows, it essentially contains
    a constructor and a `show` function which details the size and toppings of the
    pizza. The class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how many parameters the constructor contains, it literally contains
    the size and then every single topping. We can do better than this. In fact, let''s
    aim to construct the pizza by adding all our parameters to a builder object that
    we can then use to create the pizza. This is what we''re aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t too hard to do; in fact you might even find it to be one of the
    easier design patterns we learn here. Let''s first start by making a builder for
    our pizza, let''s name this class `PizzaBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This class isn't too hard to understand, we have a constructor that sets the
    size, and for each additional topping we want to add we can then just call the
    relevant topping method with the parameter set to true or false accordingly. If
    the topping method isn't called, the topping in question isn't set as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a build method, which can be called to run any last minute
    logic to organize data before it's sent into the constructor of the `Pizza` class.
    This said, I often don't like to do this, as this can be considered sequential
    coupling if methods need to be in a particular order and this would intrinsically
    defeat one purpose of us making a builder to do tasks like this.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, every topping method also returns the object that they are
    creating, allowing the output of any function to directly be injected into whatever
    class we want to use it to construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s adapt our `Pizza` class to utilize this builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It's quite straightforward for a constructor; we just access the `public` properties
    in the builder as and when they're needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can add additional validation of the data provided from the builder
    in the constructor here, though you can also add validation when you're setting
    the methods in the builder, depending on the type of logic required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can put all this together in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we should get looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Builder pattern](graphics/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Builder design pattern is incredibly easy to adopt but can save a lot of
    headaches when constructing objects.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this method is the need for a separate Builder for every
    single class; this is the cost for such control over the object construction process.
  prefs: []
  type: TYPE_NORMAL
- en: Above this, the Builder design pattern allows you to vary the constructor variables
    and also provides for good encapsulation of the code that constructs an object
    itself. Like all design patterns, it's down to you to decide where it's most appropriate
    to use each one in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, key-value arrays were often used in substitution of Builder classes.
    Builder classes however, give you far more control over the construction process.
  prefs: []
  type: TYPE_NORMAL
- en: There's one other thing I should mention; here, we just referenced the methods
    using our `index.php` method; often, the methods we run there are placed in a
    class that can be referred to as the *Director* class.
  prefs: []
  type: TYPE_NORMAL
- en: Above this, you can also consider applying an interface to implement in your
    Builder if your Builder is going to have a lot of logic in.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Prototype design pattern allows us to effectively duplicate objects while
    minimizing the performance impacts of having to re-instantiate an object.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of prototypal languages if you've worked with JavaScript.
    In such languages, you work by cloning prototypal objects to create new objects;
    in turn, there is a reduced cost for creating new objects.
  prefs: []
  type: TYPE_NORMAL
- en: We have, so far, extensively discussed the use of the `__construct magic` method,
    but we haven't touched on the `__clone magic` method. The `__clone magic` method
    is what's run before an object is cloned (if possible); the method cannot be called
    directly and takes no parameters.
  prefs: []
  type: TYPE_NORMAL
- en: You might find it useful to use the `__clone` method when using this design
    pattern; that said, you might not need it depending on your use-case.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to remember that when we clone an object, the `__construct`
    function is not re-run. The object has already been constructed so PHP sees no
    reason to re-run it, so it's worth avoiding putting meaningful logic here when
    using this design pattern for this very reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by defining a basic `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s start building our `index.php` file, starting by including our `Student.php`
    class file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create an instance of this class, set the various variables, and
    then `var_dump` the contents of the object so we can debug the details inside
    the object to see how it''s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototype pattern](graphics/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, so good; we''ve essentially declared a basic class and set various
    properties. For our next challenge, let''s clone this script. We can do this by
    adding the following lines to our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this look like? Well, take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototype pattern](graphics/image_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So that seems straightforward enough; we've cloned an object and successfully
    changed the properties of that object. Our initial object, the prototype, has
    now been put into use by cloning it to build a new student.
  prefs: []
  type: TYPE_NORMAL
- en: 'And yes, we can do this again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: But we can also do better; by using anonymous functions, otherwise known as
    closures, we can actually add extra methods dynamically to this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define an anonymous function for our object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s echo out both a `var_dump` of the newly cloned object, but
    let''s also execute the `dance` function we''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that in fact, we've had to use an `__invoke` magic method to call
    the anonymous function. This method is called when a script tries to call an object
    as a function; it is vital when calling anonymous functions in classes variables.
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the fact that PHP class properties and methods are both in separate
    namespaces; in order to execute closures that are in class variables you either
    need to use `__invoke`; first, assign it to a class variable, use `call_user_func`,
    or use the `__call magic` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we just use the `__invoke` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the output of the script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prototype pattern](graphics/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that our function ran at the very bottom?
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed `index.php` file, therefore looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are a few good use cases for this; suppose you want to perform transactions.
    You can take an object, clone it, and then replace the original if all the queries
    were successful and commit that cloned object to the database in place of the
    original.
  prefs: []
  type: TYPE_NORMAL
- en: It is a very useful and lightweight way to clone an object where you know that
    cloned object needs the same or nearly the same, contents as its parent object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started learning some critical PHP design patterns related
    to the creation of objects. We learned about various different Factory design
    patterns and how they can make your code more inline with common standards. We
    also covered how the Builder design pattern can help you avoid excessive arguments
    in your constructors. We also learned about lazy instantiation and how it can
    help your code be more efficient. Finally, we learned about how we can duplicate
    objects from prototype objects using the Prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on with design patterns, in the next chapter we will talk about Structural
    design patterns.
  prefs: []
  type: TYPE_NORMAL
