- en: Chapter 5. Vuex – Managing State in Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned one of the most important concepts of Vue.js: data
    binding. You learned and applied a lot of ways of binding data to our application.
    You also learned how to use directives, how to listen to events, and how to create
    and invoke methods. In this chapter, you will see how to manage the data that
    represents a global application state. We will talk about Vuex, a special architecture
    for centralized states in Vue applications. You will learn how to create a global
    data store and how to retrieve and change it inside the components. We will define
    what data is local and what should be global in our applications, and we will
    use the Vuex store to work with a global state in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing it up, in this chapter, we are going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the difference between local and global application states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what Vuex is and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use data from the global store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about store getters, mutations, and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and use the Vuex store in the shopping list and Pomodoro applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent-child components' communication, events, and brain teaser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember our shopping list application? Do you remember our `ChangeTitleComponent`
    and how we ensured that typing in its input box would affect the title of the
    shopping list that belongs to the parent component? You remember that each component
    has its own scope, and the scope of the parent component cannot be affected by
    children components. Thus, in order to be able to propagate the changes from inside
    the children components to the parent components, we used events. Putting it very
    simply, you can call the `$emit` method from the child component with the name
    of the event being dispatched and listen to this event within the `v-on` directive
    on the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: If it is a native event, such as `input`, it's even more simple. Just bind the
    needed attribute to the child component as a `v-model` and then call the `$emit`
    method with the name of the event (for example, `input`) from the child component.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this is exactly what we have done with `ChangeTitleComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Open the code inside the [chapter5/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list)
    folder and check if I'm right. (You might also want to run `npm install` and `npm
    run dev` if you want to check the application's behavior in your browser.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We bound the title using the `v-model` directive to `ChangeTitleComponent`
    inside the `ShoppingListComponent` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we declare the value of the title model inside the `props` attribute
    of the `ChangeTitleComponent` and emit the `input` event on the `input` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Seems pretty straightforward, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to change the title in the input box, the title of our shopping list
    changes accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parent-child components'' communication, events, and brain teaser](../Images/image00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After establishing events-based communication between the parent and child components,
    we are able to change the title
  prefs: []
  type: TYPE_NORMAL
- en: 'Looks like we were actually able to achieve our purpose. However, if you open
    your devtools, you will see an ugly error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ouch! Vue is actually right, we are mutating the data that is contained inside
    the `ShoppingList` component's `props` attribute. This attribute comes from the
    main parent component, `App.vue`, which is, in turn, the parent of our `ShoppingListComponent`.
    And we already know that we cannot mutate the parent's data from the child component.
    If the title belonged directly to the `ShoppingListComponent`, we were all good,
    but in this case, we are definitely doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you are paying enough attention, you probably noticed that there's
    one more place that contains the same piece of data that doesn't change despite
    our effort. Look at the tab's title. It continues to display the word **`Groceries`**.
    But we want it to change as well!
  prefs: []
  type: TYPE_NORMAL
- en: 'Small side note: I''ve added a new component, `ShoppingListTitleComponent`.
    It represents the tab''s title. Do you remember computed properties? Note that
    this component contains one that just prepends  `#` to the ID imported through
    the `props` attribute to generate an anchor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The anchor that displays the tab's title contains an `href` binding directive
    that relies on this computed property.
  prefs: []
  type: TYPE_NORMAL
- en: So, back to the title changing. What can we do to change the title of this component
    when the title inside the `ChangeTitleComponent` changes? If we could propagate
    the event to the main `App.vue` component, we could actually solve both problems.
    Whenever the data in the parent component changes, it affects all the children
    components.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to somehow make the event flow from `ChangeTitleComponent` until
    the main `App` component. Sounds difficult, but actually, we just need to register
    our custom event in both `ChangeTitleComponent` and its parent and emit it until
    it reaches the `App` component. The `App` component should handle this event by
    applying the change to the corresponding title. In order for `App.vue` to know
    exactly which shopping list is being changed, its child `ShoppingListComponent`
    should also pass the ID of the shopping list that it represents. For this to happen,
    `App.vue` should pass the `id` property to the component, and the shopping list
    component should register it in its `props` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind the `id` property to `ShoppingListComponent` on its creation inside the
    `App` component's template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind property `title` instead of `v-model` to the `change-title-component` from
    within the `ShoppingList` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the custom event (let's call it `changeTitle`) to `input` inside the
    `ChangeTitleComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell `ShoppingListComponent` to listen to the custom `changeTitle` event coming
    from the `change-title-component` using the `v-on` directive and handle it by
    emitting another event (it can also be called `changeTitle`) that should be caught
    by the `App` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach listener to the `changeTitle` event to the `shopping-list-component`
    inside `App.vue` and handle it by actually changing the title of the corresponding
    shopping list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by modifying the `App.vue` file''s template and binding the shopping
    list''s ID to `shopping-list-component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now register the `id` attribute inside the `ShoppingListComponent` component''s
    `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the `title` data property instead of the `v-model` directive to the `change-title-component`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Emit a custom event instead of `input` from the `ChangeTitleComponent` and
    listen to this event in its parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `onChangeTitle` method in `ShoppingListComponent` that will emit
    its own `changeTitle` event. Listen to this event in the `App.vue` component using
    the `v-on` directive. Note that the `onChangeTitle` method of the shopping list
    component should send its ID in order for `App.vue` to know which shopping list''s
    title is being changed. So, the `onChangeTitle` method and its handling will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create a `changeTitle` method inside `App.vue` that will find
    a shopping list in the `shoppinglists` array by its ID and change its title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have used the `underscore` class's `findWhere` method ( [http://underscorejs.org/#findWhere](http://underscorejs.org/#findWhere)
    ) to make our task of finding the shopping list by its ID easier.
  prefs: []
  type: TYPE_NORMAL
- en: And ... we are done! Check the final code for this teaser in the [chapter5/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list2)
    folder. Check the page in the browser. Try to change the title in the input box.
    You will see that it changes everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: 'Admit that this was quite challenging. Try to repeat all the steps by yourself.
    In the meantime, let me be random and tell you two words: global and local. Think
    about it.'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need a global state store?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you are already familiar with global and local concepts. There
    are global variables that are accessible by each section of the application, but
    methods also have their own (local) scope and their scope is not accessible by
    other methods.
  prefs: []
  type: TYPE_NORMAL
- en: A component-based system also has its local and global states. Each component
    has its local data, but the application has a global application state that can
    be accessed by any component of the application. The challenge that we have met
    in the previous paragraph would be easily solved if we had some kind of a global
    variables store containing the titles of the shopping lists and each component
    could access and modify them. Fortunately for us, Vue's creator thought about
    us and created Vuex architecture. This architecture allows us to create a global
    application store—the place where the global application state can be stored and
    managed!
  prefs: []
  type: TYPE_NORMAL
- en: What is Vuex?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously mentioned, Vuex is an application architecture for centralized
    state management. It was inspired by Flux and Redux, but it is a little bit easier
    to understand and to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Vuex?](../Images/image00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Vuex architecture; the image is taken from the Vuex GitHub page at https://github.com/vuejs/vuex
  prefs: []
  type: TYPE_NORMAL
- en: Look in the mirror (do not forget to smile to yourself). You see a nice pretty
    human. However, there's a whole complex system inside it. What do you do when
    you feel cold? And how do you feel when it's hot? How does it feel to be hungry?
    And very hungry? And how does it feel to touch a fluffy cat? The human can be
    in various types of states (happy, hungry, smiley, angry, and so on). The human
    also has a lot of components, such as hands, arms, legs, stomach, face, and so
    on. Can you imagine how would it be if, let's say, a hand were able to directly
    influence your stomach, making you feel hungry, without your awareness?
  prefs: []
  type: TYPE_NORMAL
- en: The way we work is very similar to the centralized state management system.
    Our brain contains an initial state of things (happy, not hungry, satisfied, and
    so on). It also provides the mechanism that allows pulling the strings in it that
    can affect the state. For example, *make a smile*, *feel satisfied*, *clap your
    hands*, and so on. Our hands, stomach, mouth, and other components cannot directly
    affect the state. But they can tell our brain to dispatch certain changes, and
    these changes, in turn, will affect the state.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you are hungry, you eat. Your stomach at some certain point
    tells the brain that it is full. The action dispatches a mutation of the state
    of being hungry to be satisfied. Your component mouth is bound to this state and
    it makes it express the smile. Thus, the components are bound to the read-only
    brain state and can dispatch brain actions that will alter the state. The components
    are not aware of each other and cannot modify each other's state directly in any
    way. They also can also not affect directly the brain's initial state. They can
    only call the actions. Actions belong to the brain, and in their callbacks, the
    state can be modified. Thus, our brain is a single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single source of truth in information systems is a way of designing the architecture
    of the application in such a way that every data element is only stored once.
    This data is read-only to prevent the application's components from corrupting
    the state that is accessed by other components. The Vuex store is designed in
    such a way that it is not possible to change its state from any component.
  prefs: []
  type: TYPE_NORMAL
- en: How does the store work and what is so special about it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Vuex store contains essentially two things: **state** and **mutations**.
    State is an object that represents the initial state of the application data.
    Mutations is also an object containing action functions that affect the state.
    Vuex store is just a plain JavaScript file that exports these two objects and
    tells Vue to use Vuex (`Vue.use(Vuex)`). Then it can be imported into any other
    component. If you import it in the main `App.vue` file and register the store
    on the `Vue` application initialization, it is passed to the whole children chain
    and can be accessed through the `this.$store` variable. So, very roughly, in a
    very simplified way, we would create a store, import it in the main app, and use
    it in a component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The very logical question might arise: why create a Vuex store instead of just
    having a shared JavaScript file that imports some state? You can, of course, do
    that, but then you must make sure that none of the components can mutate the state
    directly. Being able to change the store attributes directly would, of course,
    be a lot easier, but then it might lead to errors and inconsistencies. Vuex provide
    a clean way of implicitly protecting the store''s state of direct access. And,
    it''s reactive. Putting all this in statements:'
  prefs: []
  type: TYPE_NORMAL
- en: The Vuex store is reactive. Once components retrieve a state from it, they will
    reactively update their views every time the state changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components are not able to directly mutate the store's state. Instead, they
    have to dispatch mutations declared by the store, which allows easy tracking of
    changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our Vuex store thus becomes a single source of truth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a simple greetings example to see Vuex in action.
  prefs: []
  type: TYPE_NORMAL
- en: Greetings with store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a very simple Vue application with two components: one of them
    will contain the greetings message and the other one will contain `input` that
    will allow us to change this message. Our store will contain the initial state
    that will represent the initial greeting and the mutation that will be able to
    change the message. Let''s start by creating a Vue application. We will use `vue-cli`
    and the `webpack-simple` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the dependencies and run the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The application is started! Open the browser in `localhost:8080`. Actually,
    the greeting is already there. Let''s now add the necessary components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShowGreetingsComponent` will just display the greetings message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChangeGreetingsComponent` will display the input field that will allow to
    change the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `src` folder, create a `components` subfolder. Start by adding `ShowGreetingsComponent.vue`
    to this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will look as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add `ChangeGreetingsComponent.vue` to this folder. It has to contain
    the input with the `v-model=''msg''` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `App.vue` file, import the components, and replace the markup
    with these two components. Do not forget to bind `msg` to both of them. So, your
    `App.vue` after the modifications will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the browser. You will see the input box with our greeting; however, typing
    in it will not change the message in the title. We were already expecting that
    because we know that components cannot directly affect each other''s state. Let''s
    now introduce the store! First of all, we must install `vuex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a folder named `vuex` in the `src` folder. Create a JavaScript file
    named `store.js`. This will be our state management entry. First of all, import
    both `Vue` and `Vuex` and tell `Vue` that we want to use `Vuex` in this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create two constants, `state` and `mutations`. `State` will contain the
    message `msg` while `mutations` will export the method that will allow us to modify `msg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now initialize the Vuex store with the already created `state` and `mutations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we are using ES6, the notation `{state: state, mutations: mutations}` can
    be replaced with, simply, `{state, mutations}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our whole store''s code will thus look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import the store in our `App.vue`. By doing this, we tell all the
    components that they can use the global store, and as a result, we can remove
    data from `App.vue`. Also, we do not need to bind data to the components anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go back to our components and reuse the data from the store. In
    order to be able to reuse reactive data from the store''s state, we should use
    computed properties. Vue is so smart that it will do all the work for us to reactively
    update these properties whenever the state changes. And no, we do not need to
    import the store inside the components. We have access to it just by using the
    `this.$store` variable. So, our `ShowGreetingsComponent` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the same logic to reuse the store''s `msg` in the `ChangeGreetingsComponent`.
    Now we just have to dispatch the mutation on each `keyup` event. For this to happen,
    we just need to create a method that will commit the corresponding store''s mutation
    and that we will call from the input''s `keyup` listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open the page. Try to change the title. Et voilà! It works!
  prefs: []
  type: TYPE_NORMAL
- en: '![Greetings with store](../Images/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Vuex store to call the mutations and change the store's state propagating
    it through the components
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to bind the `v-model` directive anymore because all the changes
    happen due to the calling store''s mutation method. Thus, the `msg` property can
    be bound as the value''s attribute to the input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Check the code for this section in the [chapter5/simple-store](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store)
    folder. In this example, we have used a very simplified version of the store.
    However, complex **Single-Page Applications** (**SPAs**) require a more complex
    and modular structure. We can and should extract the store's getters and actions
    that dispatch mutations to separated files. We can also group these files according
    to the corresponding data's responsibilities. In the next sections, we will see
    how we can achieve such a modular structure by using getters and actions.
  prefs: []
  type: TYPE_NORMAL
- en: Store state and getters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is, of course, good that we can reuse the `this.$store.state` keyword inside
    the components. But imagine the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: In a large-scale app where different components access the state of the store
    using `$this.store.state.somevalue`, we decide to change the name of `somevalue`.
    This means that we have to change the name of the variable inside each and every
    component that uses it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to use a *computed* value of state. For example, let's say we want to
    have a counter. Its initial state is "0". Each time we use it, we want to increment
    it. This means that each component has to contain a function that reuses the store's
    value and increments it, which means having repeated code in each component, which
    is not good at all!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorry for the not-so-good scenarios, guys! Fortunately, there is a nice way
    not to fall into any of them. Imagine the centralized getter that accesses the
    store's state and provides a getter function to each of the state's items. If
    needed, this getter can apply some computation to the state's item. And if we
    need to change the name of some of the attributes, we only change it in one place,
    in this getter. It's rather a good practice or a convention than an architectural
    mandatory system, but I strongly recommend to use it even if you have only a couple
    of state items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create such a getter for our simple greetings application. Just create
    a `getters.js` file inside the `vuex` folder and export a `getMessage` function
    that will return `state.msg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it should be imported by the store and exported in the new `Vuex` object,
    so the store knows what its getters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, in our components, we use getters instead of directly accessing the
    store''s state. Just replace your `computed` property in both the components with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Open the page; everything works like a charm!
  prefs: []
  type: TYPE_NORMAL
- en: 'Still the `this.$store.getters` notation contains so many letters to write.
    We, programmers are lazy, right? Vue is nice enough to provide us with an easy
    way to support our laziness. It provides a `mapGetters` helper that does exactly
    as its name suggests—provides all the store''s getters to our components. Just
    import it and use it in your `computed` properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''ve changed the property used inside the template to have the
    same name as the getter''s method name. However, it is also possible to map the
    corresponding getter method''s name to the property name that we want to use in
    our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, we were able to extract the getter for the `msg` property to the centralized
    store's getters file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you decide to add some computation to the `msg` property, you only need
    to do it in one place. Just in one place!
  prefs: []
  type: TYPE_NORMAL
- en: '![Store state and getters](../Images/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rick was always changing the code in all the components and just discovered
    that it is possible to only change it in one place
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to reuse the uppercased message in all the components,
    we can apply the `uppercase` function inside the getter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, each component that uses the getter to retrieve the state will
    have an uppercased message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Store state and getters](../Images/image00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The ShowTitleComponent uppercased message. The toUpperCase function is applied
    inside the getters
  prefs: []
  type: TYPE_NORMAL
- en: Note also how smoothly the message is being changed to uppercase inside the
    input box while you're typing in it! Check the final code for this section inside
    the [chapter5/simple-store2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store2)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we decide to change the name of the state''s attribute, we will only change
    it inside the getters function. For example, if we want to change the name of
    `msg` to `message`, we will do it inside our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we will also change it inside the corresponding getter *function*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's it! The rest of the application is left completely untouched. This is
    the power of such architecture. In some very complex applications, we can have
    more than one getters files that export state for different kind of the application's
    properties. **Modularity** is a power that drives the maintainability; use it!
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the previous example, it should be clear that mutations are no more than
    simple event handler functions that are defined by **name**. Mutation handler
    functions receive a `state` as a first argument. Other arguments can be used to
    pass different parameters to the handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A particularity of mutations is that they cannot be called directly. To be
    able to dispatch a mutation, we should call a method called `commit` with a name
    of the corresponding mutation and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to Vue 2.0, a method to dispatch mutation was called "dispatch". So you
    would call it as follows: `store.dispatch(''changeMessage'', ''newMessage'')`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create as many mutations as you wish. They can perform different operations
    on same-state items. You can go even further and declare mutation names as constants
    in a separated file. In this way, you can easily import them and use them instead
    of strings. So, for our example, we would create a file inside the `vuex` directory
    and call it `mutation_types.js`, and export all the constant names there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our store, we will import these constants and reuse them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the components that dispatch mutations, we will import the corresponding
    mutation type and dispatch it using the variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This kind of structure makes a lot of sense in big applications. Again, you
    can group your mutation types according to the functionality they provide to the
    application and import only those mutations in the components that are needed
    for the specific component. This is, again, about best practices, modularity,
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we dispatch a mutation, we basically perform an action. Saying that we
    *commit* a `CHANGE_MSG` mutation is the same as saying that we *perform an action*
    of changing the message. For the sake of beauty and total extraction, like we
    extract the store state's items into getters and mutations names constants to
    the `mutation_types` we can also extract the mutations to the actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus, action is no more than just a function that dispatches a mutation!
  prefs: []
  type: TYPE_NORMAL
- en: '`function changeMessage(msg) { store.commit(CHANGE_MSG, msg) }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple `actions` file for our change, message example. But
    before that, let''s create one more item for the store''s initial state, `counter`,
    and initialize it with a "0" value. So, our store will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add a counter getter to the getters file, so our `getters.js` file
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, let''s use the counter''s getter inside `ShowGreetingsComponent`
    to show the amount of times the message `msg` was changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create actions for both the mutations, for the counter and for the
    change message. Inside a `vuex` folder, create an `actions.js` file and export
    the `actions` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can and should use ES2015 arguments destructuring and make our code more
    elegant. Let''s also export all the actions in a single `export default` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now we have nice and beautiful actions. Let''s use them in our `ChangeGreetingsComponent`!
    To be able to use actions inside components, we should first import them to our
    store and then export in the new `Vuex` object. Then actions can be dispatched
    using the `this.$store.dispatch` method inside the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So what''s actually the difference? We continue to write `this.$store` code,
    the only difference is that instead of calling the `commit` method we call `dispatch`.
    Do you remember how we discovered `mapGetters` helper? Wasn''t it nice? Actually
    Vue also provides a `mapActions` helper that allows us to avoid writing the extensive
    `this.$store.dispatch` something method. Just import `mapActions` in the same
    way as we import `mapGetters` and use it inside the component''s methods property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that we changed the handler's function for the `keyup` event, so we don't
    have to map the events' names to the corresponding actions. However, just like
    in the case of `mapGetters`, we can also map custom events' names to the corresponding
    actions names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also change the `changeMessage` invocation because we don''t extract
    any event''s target value inside the actions now; thus, we should do it inside
    the invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s bind the `incrementCounter` action to the user''s input. Let''s,
    for example, call this action from our input template on the `keyup.enter` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you open the page, and try to change the title and hit the *Enter* button,
    you will see that the counter will be incremented each time you hit *Enter:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](../Images/image00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using actions to increment the counter on the page
  prefs: []
  type: TYPE_NORMAL
- en: So, you see how easy it is to modularize our application by using actions instead
    of directly accessing the store. You export actions in your Vuex store, import
    the `mapActions` in the components, and call them from the event handler directives
    in the templates.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember our "human" example in which we were comparing the parts of
    the human body to the components and the human brain to the store of the application
    state? Imagine that you are running. It is only *one* action but how many changes
    are being dispatched and how many components are being affected by those changes?
    When you run, your heart rate increases, you sweat, your arms move, and your face
    smiles because you realize how nice it is to run! When you eat, you also smile
    because it is good to eat. You also smile when you see a kitten. So, different
    actions can dispatch more than one change, and the same change can be dispatched
    by more than one action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same happens with our Vuex store, and its mutations and actions. Within
    the same action, more than one mutation can be dispatched. For instance, we could
    dispatch our mutation for changing a message and increasing the counter within
    the same action. Let''s create this action inside our `action.js` file. Let''s
    call it `handleMessageInputChanges` and make it receive one argument: `event`.
    It will dispatch the `CHANGE_MSG` mutation with `event.target.value`, and in case
    `event.keyCode` is `enter`, it will dispatch the `INCREMENT_COUNTER` mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s import this action inside our `ChangeGreetingsComponent` component''s
    `mapActions` object and let''s use it calling it with the `$event` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Open the page, and try to change the greetings message and increment the counter
    by hitting the *Enter* button. It works!
  prefs: []
  type: TYPE_NORMAL
- en: The final code for the simple-store example can be found in the [chapter5/simple-store3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/simple-store3)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using the Vuex store in our applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what Vuex is, how to create a store, dispatch mutations, and
    how to use getters and actions, we can install the store in our applications and
    use it to finalize their data flow and communication chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the applications to work on in the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pomodoro**: [chapter5/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shopping list**: [chapter5/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not forget to run `npm install` on both applications.
  prefs: []
  type: TYPE_NORMAL
- en: Start by installing `vuex` and define the necessary directory and file structure
    in both applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `vuex`, just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `vuex`, create a subfolder `vuex` in each of the application''s
    `src` folders. In this folder, create four files: `store.js`, `mutation_types.js`,
    `actions.js`, and `getters.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare the `store.js` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Import and use the store in the main `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We will now define which is the global and which is the local state in each
    of the applications, define what data and binding are missing, divide the data,
    and add all the missing stuff using what we've just learned.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Vuex store in the shopping list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I hope you still remember the challenge we were facing at the beginning of
    this chapter. We would like to establish communication between the components
    in such a way that it would be easy to change the title of the shopping lists
    from the `ChangeTitleComponent` and propagate it to both `ShoppingListTitle` and
    `ShoppingListComponent`. Let''s remove the hardcoded array of shopping lists from `App.vue`
    and copy it to the store''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define getters for the shopping lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, import `mapGetters` in `App.vue` and map the `shoppinglists` value to
    the `getLists` method so that the `<script>` tag inside the `App.vue` component
    will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The rest is left untouched!
  prefs: []
  type: TYPE_NORMAL
- en: Now let's define a mutation inside our store that will be responsible for changing
    the title. It is clear that it should be a function that receives a new title
    string as a parameter. However, there is some difficulty. We don't know which
    of the shopping lists title should be changed. If we could pass a list's ID from
    a component to this function, we could actually write a piece of code that would
    find a correct list by its ID. Did I just say *if we could*? Of course, we can!
    Actually, our `ShoppingListComponent` already receives the ID from its parent
    `App.vue`. Let's just pass this ID from `ShoppingListComponent` to `ChangeTitleComponent`.
    In this way, we will be able to invoke the necessary action from the component
    where the title is actually changed, without having to propagate the event through
    the parents' chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, just bind the ID to the `change-title-component` inside the `ShoppingListComponent` component''s
    template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to add the `id` attribute to the `ChangeTitleComponent` component''s
    `props` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now our `ChangeTitleComponent` has access to both `title` and `id` of
    the shopping list. Let's add the corresponding mutation to the store.
  prefs: []
  type: TYPE_NORMAL
- en: We can start by writing a function that finds a shopping list by its ID. For
    this, I will use the `underscore` class's `_.findWhere` method, just like we did
    in the `App.vue` component's `changeTitle` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `underscore` inside `mutations.js` and add the `findById` function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add the mutation and let''s call it, for example, `CHANGE_TITLE`.
    This mutation will receive the `data` object as a parameter containing `title`
    and `id`, and assign the value of the received title to the title of the found
    shopping list item. First of all, let''s declare a constant `CHANGE_TITLE` in
    `mutation_types.js` and reuse it instead of writing the mutation''s name as a
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost finished. Let''s now define a `changeTitle` action inside the
    `actions.js` file and reuse it in our `ChangeTitleComponent`. Open the `actions.js`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the final touch. Open `ChangeTitleComponent.vue`, import the `mapActions`
    helper, map the `onInput` method to the `changeTitle` action, and call it inside
    `template` with the object mapping title to `event.target.value` and ID to the `id`
    parameter. So, the code of `ChangeTitleComponent` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: You can now remove all the events-handling code from the `ShoppingListComponent`
    and the main `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the page and try to type in the input box! The title will change in all
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Vuex store in the shopping list application](../Images/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using store, mutations, and actions—all components update their state without
    the need of events handling mechanism
  prefs: []
  type: TYPE_NORMAL
- en: The final code for the shopping list application after applying the store's
    functions can be found in the [chapter5/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/shopping-list3)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuex store in the Pomodoro application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we got back to our Pomodoro! When was the last time you took a 5-minute
    break? Let's build our Pomodoro application with the Vuex architecture and then
    take a rest look at kittens. Let's start with the base in the [chapter5/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro)
    folder, where you already included the basic structure of the Vuex store (if not,
    go to the start of the *Installing and using Vuex store in our applications* section).
  prefs: []
  type: TYPE_NORMAL
- en: Bringing life to start, pause, and stop buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by analyzing what can actually be done with our Pomodoro timer.
    Look at the page. We have only three buttons: start, pause, and stop. This means
    that our application can be in one of these three states. Let''s define and export
    them in our `store.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Initially, all these states are set to `false`, which makes sense because the
    application is not started, it's not paused and, of course, it is not stopped!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now define getters for these states. Open the `getters.js` file and
    add the getter functions for all three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'What should happen to our control buttons for each of the defined states:'
  prefs: []
  type: TYPE_NORMAL
- en: The start button should become disabled when the application is started. However,
    it should be enabled again when the application is paused so that we can use this
    button to resume the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pause button can only be enabled when the application is started (because
    we cannot pause something that has not been started yet). However, it should be
    disabled if the application is paused (because we cannot pause something that
    is already paused).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stop button can only be enabled when the application is started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's translate this into code by adding the `disabled` class to our control
    buttons conditionally, depending on the application states.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we apply the `disabled` class, Bootstrap will take care of the buttons'
    behavior for us by not only applying special styling but also deactivating interactive
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to use the already defined getters, we must import `mapGetters`
    into the `<script>` tag of the component. After that, we must tell the component
    that we want to use them by exporting them within the `computed` property object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now these getters can be used inside the template. So, we will apply the `disabled`
    class to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The start button when the application is started and not paused (`isStarted
    && !isPaused`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pause button when the application is not started or paused (`!isStarted
    || isPaused`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stop button when the application is not started (`!isStarted`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our template will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You see now that the pause and stop buttons look different! If you mouse hover
    your mouse over them, the cursor is not changed, which means that they are really
    disabled! Let''s just create a style for the icons that are inside the disabled
    buttons to highlight the disabled state even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now that we have beautiful disabled buttons, let's bring a bit of life
    into them!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about what should actually happen to the application states when
    we start, pause, or stop the application:'
  prefs: []
  type: TYPE_NORMAL
- en: When we start the application, the state `started` should become `true` and
    both `paused` and `stopped` states should for sure become `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we pause the application, the state `paused` is `true`, state `stopped`
    is `false`, and state `started` is `true` because a paused application continues
    to be started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we stop the application, the state `stopped` becomes `true` and both the `paused`
    and `started` states become `false`. Let's translate all this behavior into mutation_types,
    mutations, and actions!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `mutation_types.js` and add three mutation types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define mutations! Open the `mutations.js` file and add three mutations
    for each of the mutation types. So, we have decided that when we:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start the application**: The state `started` is `true`, and states `paused`
    and `stopped` are `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pause the application**: The state `started` is `true`, the state `paused`
    is `true`, and `stopped` are `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop the application**: The state `stopped` is `true`, and states `started`
    and `paused` are `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s put it into the code. Import `mutation_types` to `mutations.js`
    and write all three necessary mutations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define our actions! Go to the `actions.js` file, import mutation
    types, and export three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The final touch to bring our buttons to life is to import these actions into
    `ControlsComponent` and call them on the `click` event on each button. Let''s
    do it. Do you still remember how to call the action on some event applied to the
    HTML element? If we are talking about the `click` event, it is just the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in our `ControlsComponent.vue`, we import the `mapActions` object, map
    it to the component''s `methods` property, and apply it to the corresponding button''s
    clicks. That''s all! The `<script>` tag of `ControlsComponent` will thus look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now call these functions inside the event handler directives within the template
    so that the `<template>` tag of the `ControlsComponent` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Try to click the buttons. They do exactly what we need them to do. Nice work!
    Check it out in the [chapter5/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro2)
    folder. However, we are not done yet. We still have to make our Pomodoro timer
    into an actual timer and not just some page that allows you to click some buttons
    and watch them changing their states from disabled to enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Binding Pomodoro minutes and seconds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we were able to define three different states of the
    Pomodoro application: `started`, `paused`, and `stopped`. However, let''s not
    forget about what the Pomodoro application should be used for. It must countdown
    some given time for work and then switch to the break count down timer, and then
    come back to work, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to realize that there is one more very important Pomodoro application''s
    state: the binary state that toggles between *working* and *resting* periods of
    time. This state cannot be toggled by buttons; it should somehow be managed by
    our application''s internal logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining two state properties: one for the counter that will
    be decreased with the time and the other one to distinguish between the working
    and not-working states. Let''s assume that when we start our Pomodoro, we start
    our working day, so the working state should be set to true and the countdown
    counter should be set to the amount of time that we define for our working Pomodoro
    period. For the sake of modularity and maintainability, let''s define the amount
    of time for work and for rest in an external file. Let''s call it, for example,
    `config.js`. Create the `config.js` file in the project''s root directory and
    add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: By these initializations I mean that our Pomodoro should count down *20* minutes
    for the working Pomodoro interval and *5* minutes for breaks. Of course, you are
    free to define your own values that are most suitable for you. Let's now export
    `config.js` in our store and reuse the `WORKING_TIME` value to initialize our
    counter. Let's also create a property that toggles between work/break and call
    it `isWorking`. Let's initialize it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our new state will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: So, we have these two nice new properties. Before starting to create methods,
    actions, mutations, and other things that decrease the counter and toggle the
    `isWorking` property, let's think of the visual elements that rely on these properties.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have so many elements, so it's easy to define.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isWorking` state is affecting the title: we should display **`Work!`**
    when it''s time to work and **`Rest!`** when it''s time to have a rest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `isWorking` state is also affecting the kittens component visibility: it
    should be displayed only when `isWorking` is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `counter` property affects `minute` and `second`: each time it decreases,
    the `second` should also decrease its value, and every 60 decreases, the `minute`
    should also decrease its value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define getters functions for the `isWorking` state and for the `minute`
    and the `second`. After defining these getters, we can reuse them in our components
    instead of using the hardcoded values. Let''s start by defining a getter for the
    `isWorking` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s reuse this getter in the components that were using hardcoded `isworking`
    defined in the `App.vue` component. Open `App.vue`, remove all the references
    to the `isworking` hardcoded variable, import the `mapGetters` object, and map
    the `isworking` property to the `isWorking` method inside the `computed` property
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the same steps in `StateTitleComponent`. Import `mapGetters` and replace
    `props` with mapped `computed` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The rest is left untouched in both the components! Inside the templates, the
    `isworking` property is used. This property continues to exist; it's just imported
    from the reactive Vuex store and not from the hardcoded data!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must define getters for minutes and seconds. This part is trickier because
    in these getters, we have to apply some computation to the counter state''s property.
    This is not difficult at all. Our counter represents a total number of seconds.
    This means that we can easily extract minutes by dividing the counter by 60 and
    rounding to the lowest integer (`Math.floor`). The seconds can be extracted by
    taking the remainder of the division by 60\. Thus, we can write our getters for
    minutes and seconds in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Let''s now reuse these getters in the `CountdownComponent`. Import
    `mapGetters` and map its corresponding methods to the `min` and `sec` properties
    inside the `computed` property. Do not forget to remove the hardcoded data. Our
    `script` tag of the `CountdownComponent.vue` will thus look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest is left completely untouched! The template was referencing the `min`
    and `sec` properties, and they continue to exist. The code as it was until now
    can be found in the [chapter5/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro3)
    folder. Look at the page; now the displayed minutes and seconds correspond to
    the amount of working time we''ve defined in our configuration file! If you change
    it, it will change as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding Pomodoro minutes and seconds](../Images/image00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Changing the configuration for the amount of working time will immediately affect
    the Pomodoro application view
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Pomodoro timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, now everything is ready to actually start to count down our working time
    so we can finally have some rest! Let's define two auxiliary functions, `togglePomodoro`
    and `tick`.
  prefs: []
  type: TYPE_NORMAL
- en: The first one will just toggle the `isWorking` property. It will also redefine
    the state's counter. When the state `isWorking`, the counter should correspond
    to the working time, and when the state is not working, the counter should correspond
    to the resting time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tick` function will just decrease the counter and check if it has reached
    "0" value, and in this case, will toggle the Pomodoro state. The rest is already
    being taken care of. So, the `togglePomodoro` function will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, and do not forget to import `WORKING_TIME` and `RESTING_TIME` from our
    config! Also, do not forget to import `underscore` since we are using it for the `_.isBoolean`
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `tick` function will just decrease the counter and check if it has
    reached the "0" value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Fine! It's still not enough. We need to set the interval that would call the
    `tick` function for each second. Where should it be set? Well, it is more than
    clear that it should be done when we start our Pomodoro, in the `START` mutation!
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we set the interval in the `START` mutation and it calls the `tick`
    function each second, how will it be stopped or paused on hitting the pause or
    stop button? That''s why the `setInterval` and `clearInterval` JavaScript functions
    exist and that''s why we have a store where we can save the initial state for
    the `interval` value! Let''s start by defining `interval` as `null` in the store''s
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our `START` mutation, let''s add the following code that initializes
    the interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We just set an interval that will call the `tick` function each second. In turn,
    the `tick` function will decrease the counter. The values that rely on the counter's
    value—minute and second—will change and reactively propagate these changes to
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the start button now, you will set the countdown in action!
    Yay! It''s almost done. We just need to add the `clearInterval` function on the
    `pause` and `stop` mutation methods. Apart from this, on the `stop` method, let''s
    call the `togglePomodoro` function with `true`, which will reset the Pomodoro
    timer to the working state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Changing the kitten
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I hope you worked a lot and your resting time has finally come! If not and
    if you can''t wait for it, just change the `WORKING_TIME` value in the `config.js`
    file for something considerably small and wait for it. I think I finally deserve
    some rest, so I''ve been staring at this nice image for some minutes already:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the kitten](../Images/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I am staring at the image, the cat is staring at me
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't you like the displayed image to change sometimes? Of course, you would!
    In order to achieve this, we must just append something to the image source so
    that it changes with time and delivers a non-cached image to us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the best practices to deliver non-cached things is to append the *timestamp*
    to the requested URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, for example, have another property in our store, let''s say, `timestamp`,
    which would be updated with each counter decrease and its value would be appended
    to the image-source URL. Let''s do it! Let''s start by defining a `timestamp`
    property in our store''s state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Tell the `tick` function to update this value on each tick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the getter for this value in `getters.js` and use it inside the `KittensComponent`
    by accessing the `this.$store.getters.getTimestamp` method inside the `computed`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s a little bit too fast, right? Let''s define a time to show each kitten.
    It''s not difficult at all. For example, if we decide to show each kitten for
    3 seconds, before changing the state of the timestamp inside the `tick` function,
    we just have to check if the counter value is divisible by 3\. Let''s also make
    the amount of seconds to show the kitten configurable. Add the following to `config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now import it to the `mutations.js` file and use it in the `tick` function
    to check if it''s time to change the timestamp''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We are done! You can check the final code for this section in the [chapter5/pomodoro4](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter5/pomodoro4)
    folder. Yes, I've set the working time to 6 seconds so that you can have a break
    and enjoy some really nice kittens from [thecatapi.com](http://thecatapi.com)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before reading the summary of this chapter and starting the next one, take
    a break! Just like this wonderful species:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the kitten](../Images/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wonderful thing having its break. Be like him. Take a break.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how to use the events handling and triggering mechanism
    to propagate the components' data changes to their parents.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, you used the power of Vuex architecture to be able to establish
    the data flow between the components. You saw how the store is created, and its
    main parts, mutations, and states. You learned how to structure the application
    that uses the store so that it becomes modular and maintainable. You also learned
    how to create the store's getters and how to define actions that dispatch the
    store state's mutations. We applied all the learned mechanisms to our applications
    and saw the data flow in action.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are able to use any data exchanging mechanism in Vue applications,
    starting from simple local data binding inside the components and going further
    to global state management. At this point, we know all the bases to operate data
    inside our Vue application. We're almost done!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deep into the plugins system for Vue applications.
    You will learn how to use existing plugins and create your own plugin to enrich
    your applications with custom behavior.
  prefs: []
  type: TYPE_NORMAL
