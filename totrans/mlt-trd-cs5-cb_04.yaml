- en: Chapter 4. Using Task Parallel Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into a new asynchronous programming paradigm,
    Task Parallel Library. You will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing basic operations with a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining tasks together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the APM pattern to tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the EAP pattern to tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a cancellation option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions in tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweaking tasks execution with TaskScheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned what a thread is, how to use threads, and
    why we need a thread pool. Using a thread pool allows us to save operating system
    resources at the cost of reducing a parallelism degree. We can think of thread
    pool as an **abstraction layer** that hides details of thread usage from a programmer,
    allowing us to concentrate on a program's logic rather than on threading issues.
  prefs: []
  type: TYPE_NORMAL
- en: However, using a thread pool is complicated as well. There is no easy way to
    get a result from a thread pool worker thread. We need to implement our own way
    to get a result back, and in case of exception, we have to propagate it to the
    original thread properly. Besides this, there is no easy way to create a set of
    dependent asynchronous actions, where one action runs after another finishes its
    work.
  prefs: []
  type: TYPE_NORMAL
- en: There were several attempts to work around those issues, which resulted in the
    creation of Asynchronous Programming Model and Event-based Asynchronous Pattern,
    mentioned in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"), *Using a
    Thread Pool*. These patterns made getting results easier, and did a good work
    with propagating exceptions, but combining asynchronous actions together still
    required a lot of work and resulted in a large amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve all these problems, a new API for asynchronous operations was introduced
    in .Net Framework 4.0\. It is called **Task Parallel Library** (**TPL**). It was
    changed slightly in .Net Framework 4.5, and to make it clear, we will work with
    the latest version of TPL by using the 4.5 Version of .Net Framework in our projects.
    TPL can be considered as one more abstraction layer over a thread pool, hiding
    the lower-level code that will work with the thread pool from a programmer, and
    supplying a more convenient and fine-grained API.
  prefs: []
  type: TYPE_NORMAL
- en: The core concept of TPL is a task. A task represents an asynchronous operation,
    which can be run in a variety of ways, using a separate thread or not. We will
    look through all possibilities in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, a programmer is not aware how exactly the task is executing. TPL
    raises the level of abstraction by hiding the task implementation details from
    the user. Unfortunately, in some cases this could lead to mysterious errors, such
    as hanging the application while trying to get a result from the task. This chapter
    will help to understand mechanics under the hood of TPL, and how to avoid using
    it in improper ways.
  prefs: []
  type: TYPE_NORMAL
- en: A task can be combined with other tasks in different variations. For example,
    we are able to start several tasks simultaneously, wait for all of them to complete,
    and then run a task that will perform some calculations over all the previous
    tasks' results. Convenient APIs for task combination is one of the key advantages
    of TPL compared to the previous patterns.
  prefs: []
  type: TYPE_NORMAL
- en: There are also several ways to deal with exceptions resulting from tasks. Since
    a task may consist of several another tasks, and they in turn have their child
    tasks as well, there is a concept of `AggregateException`. This type of exception
    is holding all exceptions from underlying tasks inside, allowing handling them
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: And, last but not least, C# 5.0 has built-in support for TPL, allowing us to
    work with tasks in a very smooth and comfortable way using the new `await` and
    `async` keywords. We will discuss this topic in [Chapter 5](ch05.html "Chapter 5. Using
    C# 5.0"), *Using C# 5.0*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn to use TPL to execute asynchronous operations.
    We will learn what a task is, cover different ways to create tasks, and how to
    combine tasks together. We will also discuss how to convert legacy APM and EAP
    patterns to use tasks, how to handle exceptions properly, how to cancel tasks,
    and how to work with several tasks executing simultaneously. In addition, we will
    find out how to deal with tasks in Windows GUI applications properly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows a basic concept of what a task is. You will learn how to create
    and execute tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need **Visual Studio 2012**. There are
    no other prerequisites. The source code for this recipe could be found at `BookSamples\Chapter4\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create and execute a task, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This time, please make sure that you are using .Net Framework 4.5\. From now
    on, we will be using this version for every project.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7644OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates two tasks with its constructor. We pass the
    lambda expression as the `Action` delegate; this allows us to provide a string
    parameter to `TaskMethod`. Then, we run these tasks by using the `Start` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that until we call the `Start` method on those tasks, they will
    not start executing. It is very easy to forget to actually start the task.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we run two more tasks using the `Task.Run` and `Task.Factory.StartNew`
    methods. The difference is that both the created tasks immediately start working,
    so we do not need to call the `Start` method on the tasks explicitly. All of the
    tasks, number `Task 1` to `Task 4`, are placed on thread pool worker threads and
    run in an unspecified order. If you run the program several times, you will find
    that the tasks' execution order is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: The `Task.Run` method is just a shortcut to `Task.Factory.StartNew`, but the
    latter method has additional options. In general, use the former method unless
    you need to do something special, as in case of `Task 5`. We mark this task as
    long running, and as a result, this task will be run on a separate thread not
    using a thread pool. However, this behavior could change, depending on the current
    **task scheduler** that runs the task. You will learn what a task scheduler is
    in the last recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic operations with a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to get the result value from a task. We will go
    through several scenarios to understand the difference between running a task
    on a thread pool or on a main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found at `BookSamples\Chapter4\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform basic operations with a task, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first, we run `TaskMethod` without wrapping it into a task. As a result,
    it is executing synchronously, providing us with the information about the main
    thread. Obviously, it is not a thread-pool thread.
  prefs: []
  type: TYPE_NORMAL
- en: Then we run `Task 1`, starting it with the `Start` method and waiting for the
    result. This task will be placed on a thread pool, and the main thread waits and
    is blocked until the task returns.
  prefs: []
  type: TYPE_NORMAL
- en: We do the same with `Task 2`, except that we run it using the `RunSynchronously()`
    method. This task will run on the main thread, and we get exactly the same output
    as in the very first case when we just called `TaskMethod` synchronously. This
    is a very useful optimization, allowing us to avoid thread pool usage for very
    short-lived operations.
  prefs: []
  type: TYPE_NORMAL
- en: We run `Task 3` in the same way we did with `Task 1`, but instead of blocking
    the main thread, we just spin, printing out the task status until the task is
    completed. This shows several task statuses, which are `Created`, `Running`, and
    `RanToCompletion` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Combining tasks together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to set up tasks that are dependent on each other.
    We will learn how to create a task that will run after the parent task completes.
    In addition, we will discover a possibility to save thread usage for very short-lived
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For combining tasks together, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the main program starts, we create two tasks, and for the first task we
    set up a **continuation** (a block of code that runs after the antecedent task
    is complete). Then we start both the tasks and wait for 4 seconds, which is enough
    for both tasks to complete. Then we run another continuation to the second task
    and try to execute it synchronously by specifying a `TaskContinuationOptions.ExecuteSynchronously`
    option. This is a useful technique when the continuation is very short-lived,
    and it will be faster to run it on the main thread than to put it on a thread
    pool. We are able to achieve this because the second task is completed by that
    moment. If we comment out the 4 seconds `Thread.Sleep` method, we will see that
    this code will be put on a thread pool because we do not have the result from
    the antecedent task yet.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define a continuation for the previous continuation, but in a slightly
    different manner, using the new `GetAwaiter` and `OnCompleted` methods. These
    methods are intended to be used along with C# 5.0 language asynchronous mechanics.
    We will cover this topic later in [Chapter 5](ch05.html "Chapter 5. Using C# 5.0"),
    *Using C# 5.0*.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the demo is about the parent-child task relationships. We create
    a new task, and while running this task, we run a so-called child task by providing
    a `TaskCreationOptions.AttachedToParent` option.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The child task must be created while running a parent task to attach to the
    parent properly!
  prefs: []
  type: TYPE_NORMAL
- en: This means that the parent task *will not complete* until all child tasks finish
    its work. We are also able to run continuations on a child tasks providing a `TaskContinuationOptions.AttachedToParent`
    option. This continuation will affect the parent task as well, and it will not
    complete until the very last child task ends.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the APM pattern to tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to convert an old-fashioned APM API to a task.
    There are examples of different situations that could happen in the process of
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For converting the APM pattern to tasks, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we define two kinds of delegates; one of them is using the `out` parameter
    and therefore is incompatible with the standard TPL API for converting the APM
    pattern to tasks. Then we have three examples of such a conversion.
  prefs: []
  type: TYPE_NORMAL
- en: The key point for converting APM to TPL is a `Task<T>.Factory.FromAsync` method,
    where `T` is the asynchronous operation result type. There are several overloads
    of this method; in the first case, we pass `IAsyncResult` and `Func<IAsyncResult,
    string>`, which is a method that accepts `IAsyncResult` implementation and returns
    a string. Since the first delegate type provides `EndMethod` that is compatible
    with this signature, we have no problem converting this delegate asynchronous
    call to a task.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we do almost the same, but use a different `FromAsync`
    method overload, which does not allow specifying a callback that will be executed
    after the asynchronous delegate call completes. We are able to replace this with
    continuation, but if the callback is important, we can use the first example.
  prefs: []
  type: TYPE_NORMAL
- en: The last example shows a little trick. This time, `EndMethod` of the `IncompatibleAsynchronousTask`
    delegate uses the `out` parameter, and is not compatible with any `FromAsync`
    method overload. However, it is very easy to wrap the `EndMethod` call into a
    lambda expression that will be suitable for the task factory.
  prefs: []
  type: TYPE_NORMAL
- en: To see what is going on with the underlying task, we are printing its status
    while waiting for the asynchronous operation's result. We see that the first task's
    status is `WaitingForActivation`, which means that the task was not actually started
    yet by the TPL infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the EAP pattern to tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to translate event-based asynchronous operations
    to tasks. In this recipe, you will find a solid pattern that is suitable for every
    event-based asynchronous API in the .NET Framework class library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For converting the EAP pattern to tasks, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a very simple and elegant example of converting EAP patterns to tasks.
    The key point is to use the `TaskCompletionSource<T>` type, where `T` is an asynchronous
    operation result type.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to not forget to wrap the `tcs.SetResult` method call into
    the `try` **-** `catch` block to guarantee that the error information is always
    set to the task completion source object. It is also possible to use the `TrySetResult`
    method instead of `SetResult` to make sure that the result has been set successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a cancellation option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is about implementing the cancellation process for task-based asynchronous
    operations. We will learn how to use the cancellation token properly for tasks,
    and how to find out whether a task is cancelled before it was actually run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For implementing a cancellation option for task-based asynchronous operations,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another very simple example of how to implement the cancellation option
    for a TPL task, as you are already familiar with the cancellation token concept
    we discussed in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"), *Using
    a Thread Pool*.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's look closely at the `longTask` creation code. We'll pass a cancellation
    token to the underlying task once and then to the task constructor the second
    time. *Why do we need to supply this token twice?*
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that if we cancel the task before it was actually started, its
    TPL infrastructure is responsible for dealing with the cancellation, because our
    code will not execute at all. We know that the first task was canceled by getting
    its status. If we will try to call the `Start` method on this task, we will get
    `InvalidOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we deal with the cancellation process from our own code. This means that
    we are now fully responsible for the cancellation process, and after we canceled
    the task, its status is still `RanToCompletion`, because from TPL's perspective,
    the task finished its job normally. It is very important to distinguish these
    two situations and understand the responsibility difference in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions in tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes the very important topic of handling exceptions in asynchronous
    tasks. We will go through different aspects of what happens to exceptions thrown
    from tasks and how to get to their information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe7`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For handling exceptions in tasks, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program starts, we create a task and try to get the task results synchronously.
    The `Get` part of the `Result` property makes the current thread wait until the
    completion of the task and propagates the exception to the current thread. In
    this case, we easily catch the exception in catch block, but this exception is
    a wrapper exception called `AggregateException`. In this case, it holds only one
    exception inside, because only one task has thrown this exception, and it is possible
    to get the underlying exception by accessing the `InnerException` property.
  prefs: []
  type: TYPE_NORMAL
- en: The second example is mostly the same, but to access the task result we use
    the `GetAwaiter` and `GetResult` methods. In this case, we do not have wrapper
    exception because it is unwrapped by the TPL infrastructure. We have an original
    exception at once, which is quite comfortable if we have only one underlying task.
  prefs: []
  type: TYPE_NORMAL
- en: The last example shows the situation where we have two task-throwing exceptions.
    To handle exceptions, we use now a continuation, which is executed only in case
    the antecedent task finishes with exception. This behavior is achieved by providing
    a `TaskContinuationOptions.OnlyOnFaulted` option to a continuation. As a result,
    we have `AggregateException` being printed out, and we have two inner exceptions
    from the both tasks inside it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As tasks may be connected in a very different manner, the resulting `AggregateException`
    exception might contain other aggregate exceptions inside along with the usual
    exceptions. Those inner aggregate exceptions might themselves contain other aggregate
    exceptions within them.
  prefs: []
  type: TYPE_NORMAL
- en: To get rid of those wrappers, we should use the root aggregate exception's `Flatten`
    method. It will return a collection of all the inner exceptions of every child
    aggregate exception in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to handle many asynchronous tasks running simultaneously.
    We will learn how to be notified effectively when all tasks are complete or any
    of the running tasks have to finish their work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe8`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For running tasks in parallel, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program starts, we create two tasks, and then with the help of the
    `Task.WhenAll` method, we create a third task, which will complete after all the
    tasks are complete. The resulting task provides us with an answers array, where
    the first element holds the first task's result, the second element holds the
    second result, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create another list of tasks and wait for any of those tasks to complete
    with the `Task.WhenAny` method. After we have one finished task, we remove it
    from the list and continue to wait for the other tasks to complete until the list
    is empty. This method is useful to get the tasks' completion progress or to use
    timeout while running the tasks. For example, we wait for a number of tasks and
    one of those tasks is counting a timeout. If this task completes first, we just
    cancel those tasks that are not completed yet.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking tasks execution with TaskScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes another very important aspect of dealing with tasks, which
    is a proper way to work with UI from the asynchronous code. We will learn what
    a task scheduler is, why it is so important, how it can harm our application,
    and how to use it to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter4\Recipe9`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For tweaking tasks execution with `TaskScheduler`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **WPF Application** project. This
    time we will need a UI thread with a message loop, which is not available in console
    applications.![How to do it...](img/7644OT_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainWindow.xaml` file, add the following markup inside a grid element
    (that is, between the `<Grid>` and `</Grid>` tags):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MainWindow.xaml.cs` file, use the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `MainWindow` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we meet many new things. First, we created a WPF application instead of
    a console application. It is necessary because we need a user interface thread
    with a message loop to demonstrate the different options of running a task asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: There is a very important abstraction called `TaskScheduler`. This component
    is actually responsible for how the task will be executed. The default task scheduler
    puts tasks on a thread pool worker thread. This is the most common scenario and
    there's no surprise that it is the default option in TPL. We also know how to
    run a task synchronously and how to attach them to the parent tasks to run those
    tasks together. Now let us see what else we can do with tasks.
  prefs: []
  type: TYPE_NORMAL
- en: When the program starts, we create a window with three buttons. The first button
    invokes a synchronous task execution. The code is placed inside the `ButtonSync_Click`
    method. While the task runs, even we are not able to move the application window.
    The user interface is totally frozen while the user interface thread is busy running
    the task, and cannot respond to any message loop until the task is complete. This
    is quite a common bad practice for GUI Windows application, and we need to find
    a way to work around this issue.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that we try to access the UI controls from another thread.
    The graphical user interface controls have never been designed to be used from
    multiple threads, and to avoid possible errors, you are not allowed to access
    these components from a thread other than the one on which it was created. When
    we try to do that, we get an exception, and the exception message is printed on
    the main window in 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the first problem, we try to run the task asynchronously. This is
    what the second button does; the code for this is placed inside the `ButtonAsync_Click`
    method. If you run the task under debugger, you will see that it is placed on
    a thread pool, and in the end, we will get the same exception. However, the user
    interface remains responsive all the time while the task runs. This is a good
    thing, but we need to get rid of the exception.
  prefs: []
  type: TYPE_NORMAL
- en: And we already did that! To output the error message, a continuation was provided
    with the `TaskScheduler.FromCurrentSynchronizationContext` option. If this is
    not done, we would not see the error message because we would get the same exception
    that happened inside the task. This option instructs the TPL infrastructure to
    put a code inside the continuation on the UI thread and run it asynchronously
    with a help of the UI thread message loop. This resolves the problem with accessing
    UI controls from another thread, but still keeps our UI responsive.
  prefs: []
  type: TYPE_NORMAL
- en: To check if it is true, we press the last button that runs the code inside the
    `ButtonAsyncOK_Click` method. All that is different is that we provide the UI
    thread task scheduler to our task. After the task completes, you will see that
    it runs on the UI thread in an asynchronous manner. The UI remains responsive,
    and it is even possible to press another button despite the wait cursor being
    active.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some tricks for using the UI thread for running tasks. If
    we go back to the synchronous task code and uncomment the line with getting the
    result with the UI thread task scheduler provided, we will never get any result.
    This is a classical deadlock situation: we are dispatching an operation in the
    queue of the UI thread and the UI thread waits for this operation to complete,
    but as it waits, it cannot run the operation, which will never end (not even start).
    This will also happen if we call the `Wait` method on task. To avoid the deadlock,
    never use the synchronous operations on task scheduled to the UI thread; just
    use `ContinueWith`, or `async`/`await` from C# 5.0.'
  prefs: []
  type: TYPE_NORMAL
