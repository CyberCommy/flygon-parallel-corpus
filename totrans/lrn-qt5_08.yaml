- en: Web Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter takes us worldwide as we venture even further out from our application
    to the internet. Beginning with writing some helper classes to manage web requests
    for us, we will pull data from a live RSS feed and interpret it via some XML processing.
    With the parsed data at hand, we can then put our QML skills to use and display
    the items on a new view.  Clicking on one of the RSS items will launch a web browser
    window in order to view the related article in more detail. We will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Network access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSS View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The low-level networking protocol negotiation is all handled internally by
    Qt, and we can easily get connected to the outside world via the `QNetworkAccessManager`
    class. To be able to access this functionality, we need to add the `network` module
    to `cm-lib.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One of Qt's weaknesses is the lack of interfaces, making unit testing difficult
    in some cases. If we just use `QNetworkAccessManager` directly, we won’t be able
    to test our code without making real calls to the network, which is undesirable.
    However, a quick and easy solution to this problem is to hide the Qt implementation
    behind an interface of our own, and we will do that here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this chapter, all we need to be able to do with the network
    is check that we have connectivity and send a HTTP GET request. With this in mind,
    create a header file `i-network-access-manager.h` in a new folder `cm-lib/source/networking`
    and implement the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`QNetworkRequest` is another Qt class that represents a request to be sent
    over the network, and `QNetworkReply` represents a response received over the
    network. We will ideally hide these implementations behind interfaces too, but
    let’s make do with the network access interface for now. With that in place, go
    ahead and create a concrete implementation class `NetworkAccessManager` in the
    same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`network-access-manager.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`network-access-manager.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All we are doing is holding a private instance of `QNetworkAccessManager` and
    passing calls to our interface through to it. The interface can easily be extended
    to include additional functionality like HTTP POST requests with the same approach.
  prefs: []
  type: TYPE_NORMAL
- en: Web Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t worked with the HTTP protocol before, it boils down to a conversation
    between a client and a server consisting of requests and responses.  For example,
    we can make a request to [www.bbc.co.uk](http://www.bbc.co.uk) in our favorite
    web browser, and we will receive a response containing various news items and
    articles. In the `get()` method of our `NetworkAccessManager` wrapper, we reference
    a `QNetworkRequest` (our request to a server) and a `QNetworkReply` (the server''s
    response back to us). While we won’t directly hide `QNetworkRequest` and `QNetworkReply`
    behind their own independent interfaces, we will take the concept of a web request
    and corresponding response and create an interface and implementation for that
    interaction. Still in `cm-lib/source/networking`, create an interface header file
    `i-web-request.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The key piece of information for an HTTP request is the URL the request is to
    be sent to, represented by the `QUrl` Qt class. We provide an `url()` accessor and
    `setUrl()` mutator for the property. The other two methods are to check whether
    the `isBusy()` web request object is making a request or receiving a response
    and also to `execute()` or send the request to the network. Again, with the interface
    in place, let’s move on straight to the implementation with a new `WebRequest`
    class in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: '`web-request.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`web-request.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The implementation looks more complicated than it is purely because of the lengthy
    error code map. In the event of some sort of problem, Qt will report the error
    using an enumerator. The purpose of the map is simply to match the enumerator
    to a human readable error description that we can present to the user or write
    to the console or a log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the interface methods, we also have a handful of signals that
    we can use to tell any interested observers about events that have happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error()` will be emitted in the event of a problem and will pass the error
    description as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isBusyChanged()` is fired when a request starts or finishes and the request
    becomes either busy or idle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requestComplete()` is emitted when the response has been received and processed
    and will contain the HTTP status code and an array of bytes representing the response
    body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urlChanged()` will be fired when the URL is updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also have a couple of private slots that will be the delegates for processing
    a reply and handling any SSL errors. They are connected to signals on the `QNetworkReply`
    object when we execute a new request and disconnected again when we receive the
    reply.
  prefs: []
  type: TYPE_NORMAL
- en: The meat of the implementation is really two methods—`execute()` to send the
    request and `replyDelegate()` to process the response.
  prefs: []
  type: TYPE_NORMAL
- en: When executing, we first ensure that we are not already busy executing another
    request and then check with the network access manager that we have an available
    connection. Assuming that we do, we then set the busy flag and construct a `QNetworkRequest`
    using the currently set URL. We then pass the request onto our network access
    manager (injected as an interface, so we can change its behavior) and finally,
    we connect our delegate slots and wait for a response.
  prefs: []
  type: TYPE_NORMAL
- en: When we receive the reply, we unset the busy flag and disconnect our slots before
    reading the response details we are interested in, principally the HTTP status
    code and response body. We check that the reply completed successfully (note that
    a “negative” HTTP response code in the ranges 4xx or 5xx still count as successfully
    complete requests in this context) and emit the details for any interested parties
    to capture and process.
  prefs: []
  type: TYPE_NORMAL
- en: RSS View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s add a new view to our app where we can display some information from a
    web service using our new classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing new or complicated here, so I won’t show all the code, but
    there are a few steps to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RssView.qml` view in `cm-ui/views` and copy the QML from `SplashView`
    for now, replacing the "Splash View" text with "Rss View"
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the view to `views.qrc` in the `/views` prefix block and with an alias `RssView.qml`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `goRssView()` signal to `NavigationController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MasterView`, add the `onGoRssView` slot to the Connections element and use
    it to navigate to `RssView`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `NavigationBar`, add a new `NavigationButton` with `iconCharacter` `\uf09e`,
    description `RSS Feed`, and `hoverColour` as `#8acece`, and use the `onNavigationButtonClicked`
    slot to call `goRssView()` on the `NavigationController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With just a few simple steps, we’ve now got a brand new view wired up that
    we can access using the navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a39dd8f0-b57c-4e65-be77-0dbb773ed7fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we’ll add a context command bar to the view with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In `CommandController`, add a new private member list `rssViewContextCommands`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an accessor method `ui_rssViewContextCommands()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Q_PROPERTY` named `ui_rssViewContextCommands`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new slot `onRssRefreshExecuted()` that simply writes a debug message to
    the console; for now to indicate it has been called
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append a new command called `rssRefreshCommand` to `rssViewContextCommands`
    with the `0xf021` icon character and “Refresh” label and connect it to the `onRssRefreshExecuted()`
    slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `RssView`, add a `CommandBar` component with the `commandList` wired up to
    `ui_rssViewContextCommands` on the command controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All the hard work from earlier chapters is really paying dividends now; our
    new view has got its own command bar and a fully functional refresh button. When
    you click on it, it should write out the debug message you added to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae3e2a0c-6631-4e7f-a51d-bea4afd64603.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to create instances of our `NetworkAccessManager` and `WebRequest`
    classes. As usual, we will add these to `MasterController` and inject a dependency
    to `CommandController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MasterController`, add two new private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to include the relevant headers. Instantiate these new members in
    the `Implementation` constructor, ensuring that they are created before `commandController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the URL for a BBC RSS feed relevant to the UK; feel free to
    swap this for another feed of your choice simply by replacing the hyperlink text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, pass `rssWebRequest` as a new parameter to the `commandController` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit `CommandController` to take this new parameter as a pointer to the
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass this pointer through the `Implementation` constructor and store it in
    a private member variable as we do for all the other dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update the `onRssRefreshExecuted()` slot to execute the web request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The command controller now reacts to the user pressing the refresh button and
    executes the web request. However, we don’t currently do anything when we receive
    the response. Let’s add a delegate to `MasterController` in the public slots section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, after we instantiate `rssWebRequest` in `Implementation`, we can wire
    up the `requestComplete` signal to our new delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application, navigate to the RSS View, and click on Refresh.
    After a brief delay, while the request is executed, you will see all sorts of
    nonsense printed to the Application Output console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You’ve got an RSS feed! Now, what is it?
  prefs: []
  type: TYPE_NORMAL
- en: RSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rich Site Summary **(**RSS**) is a format for delivering regularly changing
    web content and is essentially an entire website, news broadcast, blog, or similar
    condensed down to bullet points. Each item consists of bare-bones information
    like the date and a descriptive title and is supplied with a hyperlink to the
    website page that contains the full article.'
  prefs: []
  type: TYPE_NORMAL
- en: The data is extended from XML and must adhere to defined standards as described
    at [http://www.rssboard.org/rss-specification](http://www.rssboard.org/rss-specification).
  prefs: []
  type: TYPE_NORMAL
- en: 'Boiling it down to the basics for the purposes of this example, the XML looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Inside the root `<rss>` node, we have a `<channel>` node, which in turn contains
    an `<image>` node and a collection of one or more `<item>` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll model these nodes as classes, but first we need to pull in the XML module
    and write a small helper class to do some parsing for us. In `cm-lib.pro` and
    `cm-ui.pro`, add the `xml` module to the modules in the `QT` variable; consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, create a new `XmlHelper` class in a new folder `cm-lib/source/utilities`.
  prefs: []
  type: TYPE_NORMAL
- en: '`xml-helper.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`xml-helper.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I won’t go into too much detail about what this class does as it isn''t the
    focus of the chapter, but essentially, if we receive an XML node that contains
    HTML markup (which is quite common in RSS), the XML parser gets a bit confused
    and breaks up the HTML into XML nodes too, which isn’t what we want. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the XML parser will see `<a>` as XML and break up the content
    into three child nodes similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This makes it difficult to display the contents of xmlNode to the user on the
    UI. Instead, we use XmlHelper to parse the contents manually and construct a single
    string, which is much easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the RSS classes. In a new `cm-lib/source/rss folder`,
    create new `RssChannel`, `RssImage`, and `RssItem` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`rss-image.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`rss-image.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This class is just a regular plain data model with the exception that it will
    be constructed from an XML `<image>` node represented by Qt’s `QDomNode` class.
    We use the `firstChildElement()` method to locate the `<url>`, `<title>`, and
    `<link>` mandatory child nodes and then access the value of each node via the
    `text()` method. The `<width>` and `<height>` nodes are optional and if they are
    not present, we use the default image size of 88 x 31 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '`rss-item.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`rss-item.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This class is much the same as the last. This time we put our XMLHelper class
    to use when parsing the `<description>` node as that has a good chance of containing
    HTML tags. Also note that Qt also helpfully contains the `Qt::RFC2822Date` format
    specifier when converting a string to a `QDateTime` object using the static `QDateTime::fromString()`
    method. This is the format used in the RSS specification and saves us from having
    to manually parse the dates ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: '`rss-channel.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`rss-channel.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This class is broadly the same as the previous classes, but because this is
    the root object of our XML tree, we also have a static `fromXml()` method. The
    goal here is to take the byte array from the RSS web request response containing
    the RSS feed XML and have the method create an RSS Channel, Image, and Items hierarchy
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the XML byte array into the Qt `QDomDocument` class, much like we have
    done previously with JSON and the `QJsonDocument` class. We find the `<channel>`
    tag using the `elementsByTagName()` method and then construct a new `RssChannel`
    object using that tag as the `QDomNode` parameter of the constructor. The `RssChannel`
    populates its own properties, thanks to the `update()` method. We then locate
    the `<image>` and `<item>` child nodes and create new `RssImage` and `RssItem`
    instances that are added to the root `RssChannel` object. Again, the classes are
    capable of populating their own properties from the supplied `QDomNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we forget, let’s also register the classes in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add an `RssChannel` to our `MasterController` for the UI to bind
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: In `MasterController`, add a new `rssChannel` private member variable of the `RssChannel*` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `rssChannel()` accessor method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `rssChannelChanged()` signal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Q_PROPERTY` named `ui_rssChannel` using the accessor for `READ` and signal
    for `NOTIFY`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rather than creating one construction when we don’t have any RSS data to feed
    it, we’ll do it in the RSS reply delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We perform some housekeeping that checks whether we already have an old channel
    object in memory and if we do, it safely deletes it using the `deleteLater()`
    method of `QObject`. We then go ahead and construct a new channel using the XML
    data from the web request.
  prefs: []
  type: TYPE_NORMAL
- en: Always use `deleteLater()` on `QObject` derived classes rather than the standard
    C++ `delete` keyword as the destruction will be synchronized with the event loop
    and you will minimize the risk of unexpected exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will display the RSS items in the response in a similar way to how we managed
    the search results, with a `ListView` and associated delegate. Add `RssItemDelegate.qml`
    to `cm-ui/components` and perform the usual steps of editing the `components.qrc`
    and `qmldir` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To support this component, we will need to add a few more Style properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now utilize this delegate in `RssView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run, navigate to the RSS View, and click on the Refresh button to
    make the web request and display the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7db92f1b-d929-4cf3-87ab-5160b63abe11.png)'
  prefs: []
  type: TYPE_IMG
- en: Hover over the items to see the cursor effects and click on an item to open
    it in your default web browser. Qt handles this action for us in the `Qt.openUrlExternally()`
    method, to which we pass the RSS Item `link` property.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extended our reach outside of our application and began
    interacting with external APIs using HTTP requests over the internet. We abstracted
    the Qt functionality using our own interfaces to improve decoupling and make our
    components more test friendly. We took a quick look at RSS and its structure and
    how to process XML node trees using Qt’s XML module. Finally, we reinforced the
    great UI work we’ve been doing and added an interactive view to display an RSS
    feed and launch the default web browser for a given URL.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](8fbb3a0b-96a5-4497-a8a4-a2f7008df0df.xhtml), *Wrapping Up*, we
    will take a look at the steps required to package our application for deployment
    to other computers.
  prefs: []
  type: TYPE_NORMAL
