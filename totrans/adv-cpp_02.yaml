- en: 2A. No Ducks Allowed – Types and Deduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement your own classes that behave like built-in types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement classes that control which functions the compiler creates (Rule of
    Zero/Rule of Five)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop functions using auto variables, like you always have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement classes and functions by making use of strong typing to write safer
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will give you a good grounding in the C++ type system and allow
    you to write your own types that work in that system.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ is a strongly typed, statically typed language. The compiler uses type information
    related to the variables that are used and the context in which they are used
    to detect and prevent certain classes of programming errors. This means that every
    object has a type and that type does not change, ever. In contrast, dynamically
    typed languages such as Python and PHP defer this type checking until runtime
    (also known as late binding), and the type of a variable may change during the
    execution of the application. These languages use the duck test instead of the
    variables type – that is, "if it walks and talks like a duck, then it must be
    a duck." Statically typed languages such as C++ rely on the type to determine
    whether a variable can be used for a given purpose, while dynamically typed languages
    rely on the presence of certain methods and properties to determine its suitability.
  prefs: []
  type: TYPE_NORMAL
- en: C++ was originally described as "C with classes". What does this mean? Basically,
    C provided a set of built-in fundamental types – int, float, char, and so on –
    along with pointers and arrays of these items. You aggregate these into data structures
    of related items using a struct. C++ extends this to classes so that you can define
    your own types completely with the operators that can be used to manipulate them,
    thereby making them first-class citizens in the language. Since its humble beginnings,
    C++ has evolved to be way more than just "C with classes", as it can now express
    the object-oriented paradigm (encapsulation, polymorphism, abstraction, and inheritance),
    the functional paradigm, and generic programming (templates).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will focus on what it means for C++ to support the object-oriented
    paradigm. As your experience as a developer grows and you are exposed to languages
    such as Clojure, Haskell, Lisp, and other functional languages, they will help
    you to write robust C++ code. Dynamically typed languages such as Python, PHP,
    and Ruby have already influenced the way we write C++ code. With the arrival of
    C++17 came the introduction of the `std::variant` class – a class that holds whatever
    type that we choose (at compile time) and acts a lot like variables in dynamic
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create C++ projects that are portable
    and maintainable using CMake. We learned how to incorporate unit tests in our
    projects to help write correct code and how to debug problems when they arise.
    We learned how the toolchain takes our code and runs it through a pipeline of
    programs to produce the executable files. We finished with some rules of thumb
    that help us to create readable, understandable, and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go on a whirlwind tour of the C++ type system, declaring
    and using our own types as we go.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a strongly and, statically typed language, C++ provides several fundamental
    types and the ability to define their own types with as much or as little functionality
    as needed to solve the problem at hand. This section will start by introducing
    the fundamental types, initializing them, declaring a variable, and associating
    a type with it. We will then explore how to declare and define a new type.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Fundamental Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ includes several *fundamental types*, or *built-in types*. The C++ standard
    defines the minimum size in memory for each type and their relative sizes. The
    compiler recognizes these fundamental types and has built-in rules that define
    what operations can and cannot be performed on them. There are also rules for
    implicit conversions between types; for example, conversion from an int type to
    a float type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See the **Fundamental Types** section at [https://en.cppreference.com/w/cpp/language/types](https://en.cppreference.com/w/cpp/language/types)
    for a brief description of all the built-in types.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ literals are used to tell the compiler the values that you wish to associate
    with a variable either when you declare it or when you assign to it. Each of the
    built-in types in the previous section has a form of literal associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: See the **Literals** section at [https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)
    for a brief description of the literals for each type.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Types – Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As C++ is a statically typed language, it is necessary to specify the type
    of a variable when it is declared. When you declare a function, it is necessary
    to specify the return type and the types of arguments that are being passed to
    it. There are two choices for specifying the type to a variable when you declare
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicitly**: You, as the programmer, are dictating exactly what the type
    is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicitly** (using auto): You are telling the compiler to look at the value
    that was used to initialize the variable and determine its type. This is known
    as (auto) **type deduction**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general form of declaration for a scalar variable is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`type-specifier` indicates what type (fundamental or user-defined) you wish
    to associate with the `var` variable. All three forms result in the compiler allocating
    some storage to hold the value in, and all future references to `var` will refer
    to that location. `init-value` is used to initialize the storage location. Default
    initialization does nothing for built-in types and will call the constructor of
    a user-defined type according to the function overloading resolution to initialize
    the storage.'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler must know how much memory to allocate and provides an operator
    to determine how large a type or variable is – `sizeof`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our declarations, the compiler will set aside space in the computer''s
    memory to store the data item that the variable refers to. Consider the following
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If these are declared within the scope of a function, then the compiler allocates
    the memory for them from what is known as the stack. The memory layout for this
    may look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.1: Memory layout of variables](img/C14583_02A_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.1: Memory layout of variables'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The compiler will allocate the memory in the order we declare the variables.
    The unused memory occurs because the compiler allocates the memory so that the
    fundamental types are generally accessed atomically and are aligned to the appropriate
    memory boundaries for efficiency. Note that `title` is of the `const char *` type,
    which is a `const`. The **"Sir Robin of Loxley"** string will be stored in a different
    part of memory that is initialized when the program is loaded. We will discuss
    program memory later.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slight modification of the scalar declaration syntax gives us the syntax
    for declaring arrays of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be done for multi-dimensional arrays like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that `count`, `countX`, and other items in the preceding declarations must
    be evaluated to a constant during compile time, otherwise this will result in
    an error. Additionally, the number of items in the comma-separated initializer
    list must be less than or equal to `count` or, again, there will be a compilation
    error. In the next section, we'll apply the concepts we've learned so far in an
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before solving any practical in this chapter, download this book's GitHub repository
    ([https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus))
    and import the folder of Lesson 2A in Eclipse so that you can view the codes for
    each exercise and activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Declaring Variables and Exploring Sizes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise will set up all the exercises for this chapter and then get you
    familiar with declaring and initializing variables that are of a built-in type.
    You will also be introduced to the `auto declaration`, `arrays`, and `sizeof`.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse (used in *Chapter 1*, *Anatomy of Portable C++ Software*) and if
    the Launcher window appears, click on Launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **File**, select **Project…** under **New** **►**, and go to Select C++
    Project (not the C/C++ Project).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next >**, clear the **Use default location** checkbox, and enter **Lesson2A**
    as the **Project name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Empty Project** for the **Project Type**. Then, click on **Browse…**
    and navigate to the folder containing the Lesson2A examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Open** to select the folder and close the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next >**, **Next >**, and then **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To help you with the exercises, we will configure the workspace to automatically
    save the files before builds. Go to **Window** and select **Preferences**. Under
    **General**, open **Workspace** and select **Build**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Save automatically before build** box and then click **Apply and
    Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just like *Chapter* *1*, *Anatomy of Portable C++ Software*, this is a CMake-based
    project, so we need to change the current builder. Click on **Lesson2A** in the
    **Project Explorer** and then on **Properties** under the **Project** menu. Select
    Tool Chain Editor under C/C++ Build from the left pane and set Current builder
    to Cmake Build (portable).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Apply and Close**. Then, choose the **Project** | **Build All** menu
    item to build all the exercises. By default, the console at the bottom of the
    screen will display the **CMake Console [Lesson2A]**:![Figure 2A.2: CMake console
    output](img/C14583_02A_02.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.2: CMake console output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the top-right corner of the console, click on the **Display Selected Console**
    button and then select **CDT Global Build Console** from the list:![Figure 2A.3:
    Selecting a different console](img/C14583_02A_03.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.3: Selecting a different console'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This will show the outcome of the build – it should show 0 errors and 3 warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.4: Build process console output](img/C14583_02A_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.4: Build process console output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the build was successful, we want to run Exercise1\. At the top of the window,
    click on the drop-down list where it says **No Launch Configurations**:![Figure
    2A.5: Launch Configuration menu](img/C14583_02A_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.5: Launch Configuration menu'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click on **New Launch Configuration…**. Leave the defaults as is and click **Next
    >**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change **Name** to **Exercise1** and then click **Search Project**:![Figure
    2A.6: Exercise1 Launch Configuration ](img/C14583_02A_06.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.6: Exercise1 Launch Configuration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the list of programs displayed in the Binaries window, click on **Exercise1**
    and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Finish**. This will result in exercise1 being displayed in the Launch
    Configuration drop-down box:![Figure 2A.7: Change to Launch Configuration](img/C14583_02A_07.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.7: Change to Launch Configuration'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To run **Exercise1**, click on the **Run** button. Exercise1 will execute and
    display its output in the console:![Figure 2A.8: Output from exercise1](img/C14583_02A_08.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.8: Output from exercise1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The program does nothing of worth – it just outputs the sizes of various types
    on your system. But this shows that the program is valid and can be compiled.
    Note that the numbers for your system may be different (especially the sizeof(title)
    value).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Project Explorer**, expand **Lesson2A**, then **Exercise01**, and
    double-click on **Exercise1.cpp** to open the file for this exercise in the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note about the preceding program is that the first statement of
    the main function is actually an executable statement and not a declaration. C++
    allows you to declare a variable just about anywhere. Its predecessor, C, originally
    required that all variables must be declared before any executable statements.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Declare a variable as close as possible to where it will be used and initialize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, uncomment the line marked as `step 24` by removing the delimiters
    (`//`) at the beginning of the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button again. This will cause the program to be built
    again. This time, the build will fail with an error:![Figure 2A.9: Errors in Workspace
    dialog](img/C14583_02A_09.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.9: Errors in Workspace dialog'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Click on **Cancel** to close the dialog. If **CDT Build Console [Lesson2A]**
    is not displayed, then select it as the active console:![Figure 2A.10: Duplicate
    declaration error](img/C14583_02A_10.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.10: Duplicate declaration error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This time, the build fails because we have tried to redefine the type of the
    variable, that is, pi. The compiler gives helpful information about where we need
    to look to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 25` by removing the delimiters (//) at the beginning
    of the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button again. When the Errors in Workspace dialog appears,
    click **Cancel**:![Figure 2A.11: Auto declaration error – no initialization](img/C14583_02A_11.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.11: Auto declaration error – no initialization'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again, the build fails, but this time, we did not give the compiler enough information
    to deduce the type of speed – auto typed variables MUST be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 26` by removing the comment starting delimiter (//) at
    the beginning of the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 27` by removing the delimiters (//) at the beginning
    of the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `int`, to title, which is a `const char*`. A very useful thing
    to note here is that `title` was declared with the `auto` type. The error message
    that was generated by the compiler tells us that title was deduced to be of the
    `const char*` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Restore the comment delimiter to the start of the line. In the editor, uncomment
    the line marked as `step 28` by removing the delimiters (//) at the beginning
    of the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `sh_int` with (`short` type. A short occupies two bytes of memory
    and is considered a signed quantity of 16 bits. This means that the range of values
    that can be stored in a short is `-2^(16-1)` to `2^(16-1)-1`, or **-32768** to
    **32767**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value from `short`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the value from `short`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore the comment delimiter to the start of the line. In the editor, make
    any change you can think of to explore variable declaration using any of the fundamental
    types and their associated literals and then click on the **Run** button as often
    as necessary. Examine the output in the Build Console for any error messages because
    it might help you find the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we learned how to set up the Eclipse development, implement
    variable declaration, and troubleshoot problems with declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Types – Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can declare a variable to be of a certain type, we need to do something
    with those variables. In C++, we do things by calling a function. A function is
    a sequence of statements that deliver an outcome. That outcome could be a mathematical
    calculation (for example, an exponent) that is then sent to a file or written
    to a Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Functions allow us to break our solution into sequences of statements that are
    easier to manage and understand. As we write these packaged statements, we can
    reuse them where it makes sense. If we need it to operate differently based on
    the context, then we pass in an argument. If it returns a result, then the function
    needs a return type.
  prefs: []
  type: TYPE_NORMAL
- en: As C++ is a strongly typed language, we need to specify the types related to
    the functions that we implement – the type of value returned by the function (including
    no return) and the type of argument(s) that are passed to it, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical hello world program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Two functions have been declared in the preceding example – `hello_world()`
    and `main()`. The `main()` function is the entry point to every C++ program ever
    written and it returns an `int` value that is passed into the host system. It
    is known as the exit code.
  prefs: []
  type: TYPE_NORMAL
- en: Everything from the declaration of the return type up to the opening brace ({)
    is known as the **function prototype**. It defines three things, namely the return
    type, the name of the function, and the number and types of an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first function, the return type is `void` – that is, it returns no
    value; it has a name of `hello_world` and takes no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.15: Declaration of a function that takes no arguments and returns
    nothing](img/C14583_02A_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.15: Declaration of a function that takes no arguments and returns
    nothing'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second function returns an `int` value, has the name of `main`, and takes
    two arguments. These arguments are `argc` and `argv` and have the `int` and *pointer
    to a pointer of* `char` types, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.16: Declaration of a function that takes two arguments and returns
    an int](img/C14583_02A_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.16: Declaration of a function that takes two arguments and returns
    an int'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Everything after the function prototype is known as the **function body**. The
    function body contains variable declarations and the statements to execute.
  prefs: []
  type: TYPE_NORMAL
- en: A function must be declared before it is used – that is, the compiler needs
    to know its arguments and its return type. If the function is defined in the file
    that it is to be used in after the call to it, then you can solve this problem
    by providing a forward declaration of the function before it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A forward declaration is made by placing the function prototype that was terminated
    by a semicolon in the file before it is called. For `hello_world()`, this would
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the main function, this would be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A function prototype does not need the names of the arguments, only the types.
    However, to help the users of the function, it is a good idea to keep them.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, the definition of the function can be in one file and needs to be called
    from a different file. So, how does the second file know the prototype of the
    function it wishes to call? This is achieved by placing the forward declarations
    into a separate file known as a header file and including it in the second file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Declaring Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will test what the compiler needs to know when it encounters
    a function call and implements a forward declaration to resolve an unknown function.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2A** project in Eclipse, and then, in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise02** and double-click on **Exercise2.cpp**
    to open the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure **Exercise2** to run with the name **Exercise2**. When that is complete,
    it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. Exercise 2 will run and produce the following
    output:![Figure 2A.17: Output from the exercise2 program](img/C14583_02A_17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.17: Output from the exercise2 program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Go into the editor and change the code by moving the `gcd` function so that
    it''s after `main`. It should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `gcd()` function. It has no knowledge of the function at the point
    it needs to call it, even though it is defined in the same file but after the
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, place the forward declaration before the definition of the main
    function. Also add a semicolon (;) at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button again. This time, the program compiles and the original
    output is restored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we learned how to forward declare functions and troubleshoot
    compiler errors that occur when a function is not declared before it is used.
  prefs: []
  type: TYPE_NORMAL
- en: In the early versions of C compilers, this was acceptable. The program would
    assume that the function existed and returned an int. The functions' arguments
    could be inferred from the call. However, this is not true in the case of modern
    C++ as you must declare a function, class, variable, and so on before using it.
    In the next section, we'll learn about pointer types.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of its origins in the C language, that is, writing optimally efficient
    systems and having direct access to hardware, C++ allows you to declare a variable
    as a pointer type. It is of the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as before, except for two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of the special declarator asterisk (`*`) to indicate that the variable named
    pvar points to a location or address in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is initialized using the special operator ampersand (`&`), which in this
    context tells the compiler to return the address of the `var` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As C is a high-level language, but with low-level access, pointers allow users
    to access memory directly, which is helpful when we wish to provide input/output
    to hardware and thus control it. Another use of pointers is to allow functions
    to be provided with access to common data items and remove the need to copy large
    amounts of data when calling functions as it defaults to passing by value. To
    access the value that''s being pointed to by the pointer, the special operator
    asterisk (`*`) is used to **dereference** the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows how the compiler allocates the memory. `pvalue`
    requires memory to store the pointer, while `five` needs memory to store the integer
    value of 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.19: Memory layout for pointer variables](img/C14583_02A_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.19: Memory layout for pointer variables'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When accessing a user-defined type via a pointer, there is a second special
    operator (->) that is also used for dereferencing member variables and functions.
    In modern C++, these pointers are referred to as **raw pointers** and the way
    in which they are used has changed significantly. Working with pointers in C and
    C++ has always proved challenging for programmers, and their incorrect use is
    the source of many problems, the most common being resource leaks. A resource
    leak is a scenario where a program has grabbed a resource (a memory, a file handle,
    or other system resource) for its use and fails to let it go when it's finished
    with it. These resource leaks can lead to performance issues, program failures,
    and even system crashes. The use of raw pointers in modern C++ to manage the ownership
    of a resource is now deprecated since smart pointers arrived in C++11\. Smart
    pointers (implemented as classes in the STL) now do the housekeeping required
    to be a good citizen in your host system. More about this will be covered in *Chapter
    3*, *The Distance Between Can and Should – Objects, Pointers, and Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, when `pvalue` is declared, the compiler allocates memory
    to store only the address of the memory it will be referring to. Like other variables,
    you should always ensure that a pointer is initialized before it is used as dereferencing
    an uninitialized pointer results in an undefined behavior. Exactly how much memory
    is allocated to store a pointer is dependent upon the system that the compiler
    is designed for and how many bits the processor supports. But all pointers will
    be of the same size, regardless of what type they point to.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pointer can also be passed to a function. This allows the function to access
    the data being pointed to and possibly modify it. Consider the following implementation
    of swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This shows how to declare pointers as arguments to a function, how to get the
    value from the pointer by using the dereferencing operator `*`, as well as how
    to set a value through the dereference operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example allocates memory from the host system using the new operator
    and releases it back to the host system using the delete operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the first line creates an array of 20 characters using
    the array allocation form of the new operator. It makes a call to the host system
    to allocate 20 * sizeof(char) bytes of memory for our use. Exactly how much memory
    is allocated is up to the host system, but it is guaranteed to be at least 20
    * sizeof(char) bytes. If it fails to allocate the required memory, then one of
    two things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: It will throw an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will return `nullptr`. This is a special literal that was introduced in C++11\.
    Earlier, C++ used 0 or NULL to indicate a non-valid pointer. C++11 made this a
    strongly typed value as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On most systems, the first outcome will be the result, and you will need to
    deal with the exception. The second outcome is possible from two scenarios – calling
    the nothrow variant of new, that is, `new(std::nothrow) int [250]`, or on embedded
    systems where the overhead of exception processing is not sufficiently deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, note that the call to delete uses the array form of the delete operator,
    that is, with square brackets, []. It is important to ensure that the same form
    is used with the new and delete operators. When new is used on a user-defined
    type (which will be discussed in the next section), it does more than just allocate
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the call to new allocates sufficient memory to store
    MyClass and, if successful, it then proceeds to call the constructor to initialize
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the call to new allocates sufficient memory to store
    12 copies of MyClass and, if successful, it then proceeds to call the constructor
    12 times to initialize the data for each object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `object` and `objects`, which were declared in the preceding snippets
    of code, have the `objects` should be a pointer to an array of MyClass, but it
    is actually a pointer to an instance of MyClass. `objects` points to the first
    instance in the array of MyClass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following excerpt of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the process() function, `objects` is of the "array of 12 MyClass items"
    type, but when it is passed to `printMyClasses()`, it is converted (by the compiler)
    into the "a pointer to MyClass" type. This is by design (inherited from C) and
    is known as `printMyClasses()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This would still suffer from array decay as the compiler changes the argument
    object to MyClass*; it does not keep the dimension information in this case. Array
    decay is the reason that we need to pass number to the `printMyClasses()` function:
    so that we know how many items are in the array. C++ provides two mechanisms for
    dealing with array decay:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of iterators to pass a range into the method. STL containers (see the *C++
    Pre-Packaged Templates* section in *Chapter 2B*, *No Ducks Allowed – Templates
    and Deduction*) offer the `begin()` and `end()` methods so that we can obtain
    iterators that allow algorithms to traverse an array or part thereof.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For C++20, the ISO standard committee is considering the inclusion of a concept
    known as Ranges that will allow both the begin and end iterators to be captured
    in one object.
  prefs: []
  type: TYPE_NORMAL
- en: Use of templates (see the *Non-Type Template Arguments* section in *Chapter
    2B, No Ducks Allowed – Templates and Deduction*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 3: Declaring and Using Pointers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement functions that take pointers and arrays
    as arguments and compare their behavior while considering array decay. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2A** project in Eclipse, and then in the Project Explorer,
    expand **Lesson2A**, then **Exercise03**, and double-click on **Exercise3.cpp**
    to open the file for this exercise into the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise3** to run with the name **Exercise3**.
    When that is complete, it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. Exercise 3 will run and produce the following
    output:![Figure 2A.20: Exercise 3 output](img/C14583_02A_20.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.20: Exercise 3 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the editor, insert a blank line somewhere and click on the **Run** button.
    (By changing the file, it will force the build system to recompile **Exercise3.cpp**.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we now look at the `print_array_size2()` is of the `int*` type and is borne
    out by the warning stating that sizeof `will return size of ''int*''`:![Figure
    2A.22: Exercise 3 partial output](img/C14583_02A_22.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.22: Exercise 3 partial output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `sizeof(ary)/sizeof(arg[0])` calculation should return the number of elements
    in an array. The first `elements in (ary) = 10` is generated from the main function
    and ary was declared as `ary[10]`, so it is correct. The `elements in (ary) =
    2` under the ---print_array_size2--- banner shows the problem with array decay
    and why the compiler generated a warning. Why the value of 2? On a test PC, a
    pointer occupies 8 bytes (64 bits), while an int only occupies 4 bytes, so we
    get 8/4 = 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, locate the line in main() where ary is declared and change it
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `int ary[15]` would cause an error or at least a warning since
    the argument prototypes do not match. As we stated previously, the compiler treats
    the argument as `int* ary`, so the function may as well have been declared as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the editor, change the name of `print_array_size2` to `print_array_size`
    all through the file. Click on the `int* ary` and `int ary[10]`. This is the confirmation
    that, when used as an argument to a function, `int ary[10]` generates the same
    as if `int*` ary was declared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore the file to its original state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, locate the line with `Step 11` in a comment and remove
    the comment at the beginning of the line. Click on the `title` to be `const char*`
    and p of type `char*`. The const-ness is important. The p pointer allows us to
    change the value of whatever it points at.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button. This time, it builds and runs properly. It is OK
    to assign a non-const pointer to a const pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we learned that arrays need to treated carefully when passing
    them into functions as critical information (the size of the array) will be lost
    in the call.
  prefs: []
  type: TYPE_NORMAL
- en: Creating User Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The great thing about C++ is that you can create your own types using **struct**,
    **class**, **enum**, or **union** and the compiler will treat it as a fundamental
    type throughout the code. In this section, we will explore creating our own type
    and the methods that we need to write to manipulate it, as well as some methods
    that the compiler will create for us.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest user-defined type is the enumeration. Enumerations got an overhaul
    in C++11 to make them even more type-safe, so we have to consider two different
    declaration syntaxes. Before we look at how to declare them, let''s figure out
    why we need them. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is typical of many C library functions where a status code is returned
    and you need the main page to know what they mean. In the preceding code, `-1`,
    `-2`, `-3`, and `0` are known as **magic numbers**. You need to read the code
    to understand what each number means. Now, consider the following version of the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses an enumeration class to communicate the result and attach the meaning
    to the name of the values. A user of the function can now use the enumerations
    as the code is easier to understand and use. So, the magic numbers (related to
    the status) have been replaced with an enumerated value that has a descriptive
    title. Let''s learn about the declaration of `FileCheckStatus` by referring to
    the following pieces of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use the values from the magic numbers, then we would declare
    them like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, by turning the order around, we can set the first value and
    the compiler will do the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the scoping directive, `FileCheckStatus::`, is missing from the code,
    but it will still compile and work. This raises the issue of scope, which we will
    discuss in detail later in the *Visibility, Lifetime, and Access* section of *Chapter
    2B*, *No Ducks Allowed – Templates and Deduction*. For now, know that every type
    and variable has a scope and the problem with old-style enumerations is that their
    enumerators are added into the same scope as the enumeration. Let''s say we have
    two enumerations defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a problem in which the `Pass` enumerator is defined twice and has
    two different values. Old-style enumerations also allow us to write a valid compiler
    but apparently nonsensical code, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As we are trying to develop code that is clear in intent and easy to understand,
    comparing a result to an option has no meaning. The problem is that the compiler
    would implicitly convert the value into an integer and thus be able to compare
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 introduced a new concept that is referred to as an **enum class** or
    **scoped enumeration**. The scoped enumeration definition of the preceding code
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the preceding code will no longer compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name implies, **scoped enumeration** places the enumerators inside the
    scope of the enumeration name. In addition, a scoped enumeration will no longer
    be implicitly converted into an integer (hence the if statement will fail to compile).
    You can still convert the enumerator into an integer, but you will need to cast
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 4: Enumerations – Old and New School'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement a program that uses enumerations to represent
    predefined values and determine the consequential changes required when they are
    changed to a scoped enum. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise04**, and double-click on **Exercise4.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise4** to run with the name **Exercise4**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is complete, it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. Exercise 4 will run and produce the following
    output:![Figure 2A.25: Exercise 4 output](img/C14583_02A_25.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.25: Exercise 4 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Examine the code in the editor. Currently, we can compare apples and oranges.
    At the definition of `printOrange()`, change the argument to be `Orange`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. When the Errors in Workspace dialog appears, click
    **Cancel**:![Figure 2A.26: Cannot convert error](img/C14583_02A_26.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.26: Cannot convert error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By changing the argument type, we forced the compiler to enforce the type of
    the value that was passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `printOrange()` function twice by passing the `orange` `enum` variable
    in the initial call and the `apple` variable in the second call, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the compiler is implicitly converting the orange and apple into
    an `int` so that it can call the function. Also, note the warning about comparing
    `Apple` and `Orange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the `printOrange()` function by taking an int argument and changing
    the definition of the `orange` `enum` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. When the Errors in Workspace dialog appears, click
    **Cancel**:![Figure 2A.27: Multiple errors for scoped enum changes](img/C14583_02A_27.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.27: Multiple errors for scoped enum changes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Locate the first error listed for this build:![Figure 2A.28: First scoped enum
    error ](img/C14583_02A_28.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.28: First scoped enum error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first thing to note about scoped enums is that when you reference the enumerators,
    they must have a scope specifier. Therefore, in the editor, go and change this
    line to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `Orange` type. Because this involves a template-based class (which
    we'll talk about later), the error messages become very long-winded. Take a minute
    to look at all the messages that appear from this error to the next (red lines).
    It shows you what the compiler was trying to do to be able to compile that line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the indicated line to read the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `Orange::` scope specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is left as an exercise for you to get the file to compile again with `orange`
    as a scope enumeration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we found that scope enums improve the strong type checking
    of C++ and if we wish to use them as an integral value, then we need to cast them,
    unlike non-scope enums, which are implicitly converted.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Compiler Errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As seen from the preceding exercise, the compiler can generate a very large
    amount of error and warning messages from one error. This is why it is recommended
    to find the first error and fix it first. Development in IDEs or using build systems
    that color-code errors can make this easier.
  prefs: []
  type: TYPE_NORMAL
- en: Structures and Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumerations are the first of the user-defined types, but they do not really
    extend the language so that we can express the solutions to our problems at the
    appropriate level of abstraction. Structs and classes, however, allow us to capture
    and group the data and then associate methods to manipulate that data in a consistent
    and meaningful manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the multiplication of two matrices, *A (m x n)* and *B (n x
    p)*, which results in matrix *C (m x p)*, then the equation for the ith row and
    jth column of C is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_02A_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.31: Equation of ith row and jth column'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we had to write it every time we wished to multiply two matrices, we would
    end up with many nested for loops. But if we could abstract a matrix into a class,
    then we could express it as simple as we express the multiplication of two integers
    or two floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is the beauty of object-oriented design – data encapsulation and the abstraction
    of concepts are explained at such a level that we can easily understand what the
    program is trying to achieve without getting buried in the details. Once we have
    established that the matrix multiplication is correctly implemented, then we are
    free to focus on solving our problem at a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion that follows refers to classes, but it applies equally to structs
    and, mostly, to unions. We will outline the differences between classes, structs,
    and unions after we learn how to define and use a class.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show you how to define and use a class, we will work on developing the `Fraction`
    class to implement rational numbers. When defined, we can use `Fraction` like
    any other built-in type (add, subtract, multiply, divide) without worrying about
    the details – this is abstraction. We can now just think and reason about a fraction
    at a higher level, that is, an abstract level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Fraction` class will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Contain two integer member variables, `m_numerator` and `m_denominator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide methods to copy itself, assign to it, multiply, divide, add, and subtract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a method to write to an output stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To attain the preceding objective, we have the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.32: Definitions of operations](img/C14583_02A_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.32: Definitions of operations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition, the operations that we perform will need to normalize the fraction
    by reducing it to the lowest terms. To do this, the numerator and the denominator
    are both divided by their greatest common divisor (GCD).
  prefs: []
  type: TYPE_NORMAL
- en: Constructors, Initialization, and Destructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class definition, as expressed in C++ code, is the pattern that''s used for
    creating objects in memory and manipulating objects through their methods. The
    first thing that we need to do is tell the compiler that we wish to declare a
    new type – a class. To declare the `Fraction` class, we start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We place this in a header file, **Fraction.h**, as we wish to reuse this class
    specification in other areas of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is introduce the data to be stored in the class,
    which in this case are `m_numerator` and `m_denominator`. These are both of the
    int type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now declared the data to be stored and given them names that anyone
    familiar with mathematics would understand regarding what each member variable
    stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_02A_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.33: Formula of fraction'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As this is a class, by default, any item that''s declared is assumed to be
    `private`. This means that no external entity can access these variables. It is
    this feature of hiding (making data private, and for that matter, some methods)
    that enables encapsulation in C++. C++ has three class access modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public**: This means that the member (variable or function) is accessible
    from anywhere outside of the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private**: This means that the member (variable or function) cannot be accessed
    from outside the class. In fact, it cannot even be viewed. Private variables and
    functions can only be accessed from within the class or by a friend method or
    class. The private members (variables and functions) are used by the public functions
    to achieve the desired functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected**: This is a cross between private and public. From outside the
    class, the variable or function is private. However, for any class that is derived
    from the class that declares the protected members, they are treated as public.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point in our definition of the class, this is not very useful. Let''s
    change the declaration to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we can access the internal variables. The `Fraction number;`
    variable declaration will cause the compiler to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate enough memory to hold both the data items (depending on the types,
    this may or may not involve padding, that is, the inclusion or addition of unused
    memory to align members for the most efficient access). The `sizeof` operator
    can tell us how much memory is allocated for our class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize the data items by calling the **default constructor**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps are the same that the compiler does for built-in types, that is,
    step 2 does nothing, leading to uninitialized variables. But what is this default
    constructor? And what does it do?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the default constructor is a special member function. It is one of
    the many possible constructors, three of which are deemed special member functions.
    Constructors can be declared with zero, one, or more arguments, just like any
    other function, but they do NOT specify a return type. Constructors serve the
    special purpose of initializing all the member variables to place the object into
    a well-defined state. If the member variables are themselves a class, then it
    may not be necessary to specify how to initialize the variable. It the member
    variable is of a built-in type, then we will need to provide the initial values
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: Class Special Member Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we define a new type (struct or class), the compiler will create up to
    six (6) special member functions for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Fraction::Fraction()`): This is called when no arguments are provided (such
    as in the preceding section). This can be achieved by either having no argument
    list for the constructor or by defining a default value for all the arguments,
    such as `Fraction(int numerator=0, denominator=1)`. The compiler provides an `implicit`
    `inline` default constructor that performs the default initialization of member
    variables – for built-in types, this means do nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fraction::~Fraction()`): This is a special member function that is called
    when the object''s lifetime ends. Its purpose is to release any resources that
    were allocated and kept by the object during its lifetime. The compiler provides
    a `public` `inline` member function that calls the destructors of the member variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fraction::Fraction(const Fraction&)`): This is another constructor where the
    first parameter is a form of `Fraction&` and there are no other arguments, or
    the remainder of the arguments have default values. The form of the first argument
    is one of `Fraction&`, `const Fraction&`, `volatile Fraction&`, or `const volatile
    Fraction&`. We will deal with `const` later but not with `volatile` in this book.
    The compiler provides a `non-explicit` `public` `inline` member function, usually
    with the form of `Fraction::Fraction(const Fraction&)`, that copies each of the
    member variables in the order of initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fraction& Fraction::operator=(Fraction&)`): This is a member function with
    the name `operator=` and the first argument is either a value or any of the reference
    types of the class, in this case, `Fraction`, `Fraction&`, `const Fraction&`,
    `volatile Fraction&`, or `const volatile Fraction&`. The compiler provides a `public`
    `inline` member function, usually with the form of `Fraction::Fraction(const Fraction&)`,
    that copies each of the member variables in the order of initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fraction::Fraction(Fraction&&)`): This is a new type of constructor that was
    introduced in C++11 where the first parameter is a form of `Fraction&&` and there
    are no other arguments, or the remainder of the arguments have default values.
    The form of the first argument is one of `Fraction&&`, `const Fraction&&`, `volatile
    Fraction&&`, or `const volatile Fraction&&`. The compiler provides a `non-explicit`
    `public` `inline` member function, usually with the form of `Fraction::Fraction(Fraction&&)`,
    that moves each of the member variables in the order of initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fraction& Fraction::operator=(Fraction&&)`): This is a new type of assignment
    operator that was introduced in C++11 and is a member function with the name `operator=`,
    and the first argument is any of the forms that are allowed for the move constructor.
    The compiler provides a `public` `inline` member function, usually with the form
    of `Fraction::Fraction(Fraction&&)`, that copies each of the member variables
    in the order of initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for the default constructor, these functions deal with managing the resources
    owned by this class – that is, how to copy/move them and how to dispose of them.
    On the other hand, the default constructor is more like any other constructor
    that takes values – it only initializes the resources.
  prefs: []
  type: TYPE_NORMAL
- en: We can declare any of these special functions, force them to be defaulted (that
    is, have the compiler generate the default version), or force them to not be created.
    There are also rules about when these are automatically generated in the presence
    of the other special functions. The first four functions are relatively straightforward
    conceptually, but the two "move" special member functions take some additional
    explanation. We will deal with what is known as move semantics in detail in *Chapter
    3*, *The Distance Between Can and Should – Objects, Pointers, and Inheritance*,
    but for now it is essentially what it indicates – it moves something from one
    object to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Versus Explicit Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preceding description talks about the compiler generating implicit or non-explicit
    constructors. If a constructor exists that can be called with one argument, for
    example, a Copy Constructor, or a Move Constructor, by default, the compiler is
    allowed to invoke it if necessary so that it can convert it from one type to another
    type, allowing an expression, function call, or assignment to be encoded. This
    is not always a desired behavior, and we may wish to prevent the implicit conversion
    and ensure that if the user of our class really wants that conversion, then they
    have to write it out in the program. To achieve this, we prefix the declaration
    of the constructor with the `explicit` keyword, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The explicit keyword can be applied to other operators as well, where the compiler
    may use it for type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Class Special Member Functions – Compiler Generation Rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firstly, the `Default Constructor` will not be generated if we declare any other
    form of constructor – default, copy, move, or user-defined. None of the other
    special member functions affect its generation.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, a `Destructor` will not be generated if a destructor is declared.
    None of the other special member functions affect its generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generation of the other four special functions is dependent on the presence
    of the declaration of the destructor or one of the other special functions, as
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_02A_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.34: Special Member Function Generation Rules'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defaulting and Deleting Special Member Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to C++11, if we wanted to prevent the use of a copy constructor or copy
    assignment member function, then we had to declare the function as private and
    not provide a definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, we ensured that if anyone tried to access the copy constructor
    or copy assignment from outside the class, then the compiler would generate an
    error stating that the function is not accessible. This still declares the functions,
    and they are accessible from within the class. It is an effective means, but not
    perfect, to remove these special member functions from use.
  prefs: []
  type: TYPE_NORMAL
- en: But we can do better since C++11 introduced two new declaration forms that allow
    us to override the default behavior of the compiler, as defined in the preceding
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we can force the compiler to not generate the method by declaring
    it with the `= delete` suffix, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can omit the name of the parameter if it is not used. This is true for any
    function or member function. In fact, depending on the warning level that's been
    set for the compiler, it may even generate a warning that the argument is not
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can force the compiler to generate its default implementation
    of a special member function by using the `= default` suffix, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If this is only the declaration of the function, then we can also omit the name
    of the argument. Although, good practice dictates that we should name the argument
    to indicate its use. That way, the users of our classes do not need to look at
    the implementation of calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Declaring a special member function using the default suffix is deemed to be
    a user-defined member function for the purpose of the aforementioned rules.
  prefs: []
  type: TYPE_NORMAL
- en: Rule of Three/Five and Rule of Zero
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed previously, with the exception of the default constructor, the
    special member functions deal with the semantics of managing the resources owned
    by this class – that is, how to copy/move them and how to dispose of them. This
    leads to two "rules" within the C++ community about dealing with the special functions.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C++11, there was the **Rule of Three**, which dealt with the copy constructor,
    copy assignment operator, and the destructor. It basically states that we need
    to implement one of these methods since the management of the encapsulated resource
    is non-trivial.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of the move constructor and move assignment operator in
    C++11, this rule was expanded to the **Rule of Five**. No changes were made to
    the essence of the rule. Simply, the number of special member functions increased
    to five. Remembering the rules for compiler generation, there is an additional
    reason for ensuring all five special methods are implemented (or forced via =
    default), and that is, if the compiler does not have access to a move-semantic
    function, it will attempt to use a copy-semantic function, and this may not be
    what is desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For more details, see the C.ctor: Constructors, assignments, and destructors
    section of the C++ Core Guidelines, which can be found here: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines).'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors – Initializing the Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main task of a constructor is to put the object into a stable state so that
    any operations performed on or by the object through its member functions result
    in a consistent defined behavior. While the previous statement is true of the
    copy and move constructors, they achieve this by different semantics (copying
    or moving from another object).
  prefs: []
  type: TYPE_NORMAL
- en: There are four different mechanisms available for us to control the initial
    state of an object. C++ has a lot of rules for which initialization is used in
    such a case. We will not go into the details of the C++ standard's default initialization,
    zero initialization, value initialization, constant initialization, and so on.
    Just know that the best approach is to be explicit about the initialization of
    your variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **first** and least preferred initialization mechanism is to assign values
    to the member variables in the body of the constructor, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It is clear what values are used to initialize the variables. Strictly speaking,
    this is not the initialization of the class – according to the standard, initialization
    is complete when the body of the constructor is called. This is simple to maintain,
    particularly in this class. For larger classes that have multiple constructors
    and many member variables, it can be a maintenance problem. If you change one
    constructor, you will need to change them all. It also has the problem that if
    the member variable is of a reference type (which we'll talk about later), then
    it cannot be done in the body of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The default constructor uses the `this` pointer. Every member function, including
    constructors and destructors, are called with one implicit argument (even though
    it is never declared) – the `this` pointer. `this` points to the current instance
    of the object. The `->` operator is another dereference operator and is shorthand
    in this case, that is, `*(this).m_numerator`. The use of `this->` is optional
    and can be omitted. Other languages, such as Python, require the implicit pointer/reference
    to be declared and used (the convention in Python is to call *self*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **second** mechanism is the use of a member initialization list, which
    has a caveat in its use. For our Fraction class, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The sections of code after the colon, :, and before the opening brace, {, in
    (`m_numerator(0), m_denominator(1)` and `m_numerator(numerator), m_denominator(denominator)`
    are the member initialization lists. We can initialize a reference type in the
    member initialization list.
  prefs: []
  type: TYPE_NORMAL
- en: Member Initialization List Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regardless of the order in which you place the members in the member initialization
    list, the compiler will initialize the members in the order that they are declared
    in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **third** and **recommended** initialization is the default member initialization
    that was introduced in C++11\. We define default initial values when the variable
    is declared either using assignment or the brace initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the constructor does not define the initial value of the member variable,
    then this default value will be used to initialize the variable. This has the
    advantage of ensuring that all the constructors produce the same initialization
    unless they have been explicitly modified in the definition of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 also introduced a fourth style of initialization, known as constructor
    delegation. It is a modification of the Member Initialization List where, instead
    of listing the member variables and their initial values, another constructor
    is called. The following example is contrived, and you would not write a class
    this way, but it shows the syntax for the constructor delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You call the single argument constructor from the constructor with two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Declaring and Initializing Fractions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement class member initialization using the different
    techniques available to us, including constructor delegation. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise05**, and double-click on **Exercise5.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise5** to run with the name Exercise5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is complete, it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Run** button. **Exercise 5** will run and produce something similar
    to the following output:![](img/C14583_02A_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.35: Exercise 5 typical output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The values that were reported for the fraction come from not initializing the
    member variables in any way. If you run it again, you will most likely get a different
    fraction.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Run** button a few times. You will see that the fraction changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change the constructor to read as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button and observe the output:![](img/C14583_02A_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.36: Modified Exercise 5 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This time, the fraction value is defined by the values we specified in the member
    initialization list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, add the following two `constructors`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, change the declaration of `fraction` to include initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button and observe the output:![](img/C14583_02A_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.37: Example of constructor delegation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this exercise, we implemented member variable initialization using the member
    initialization list and constructor delegation. *We will return to fractions in
    Exercise 7, Adding Operators to the Fraction Class.*
  prefs: []
  type: TYPE_NORMAL
- en: Values Versus References and Const
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have only dealt with value types, that is, the variable holds the
    value of the object. A pointer holds a value (which is the address of the object)
    that we are interested in (or nullptr). But this can lead to inefficiencies and
    problems with managing resources. We will talk about addressing the inefficiencies
    here but deal with the resource management problem in *Chapter 3*, *The Distance
    Between Can and Should – Objects, Pointers, and Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following problem..We have a 10×10 matrix of double types that
    we wish to write an inversion function for. The class is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to take `sizeof(Matrix10x10)`, we would get `sizeof(double)` x 10
    x 10 = 800 bytes. Now, if we were to implement an inversion matrix function for
    this, its signature might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, this means that the compiler would need to pass the value held by
    `mat` to the `invert()` function and copy the 800 bytes onto the stack. The function
    then does whatever it needs to do to invert the matrix (an L-U decomposition,
    calculation of the determinant – whatever approach the implementer chooses) and
    then copy the 800-byte result back to the `inv` variable. Passing large values
    on the stack is never a good idea, for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack is a finite resource that's given to our program by the host operating
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying large values around the system is inefficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach is known as pass-by-value. That is, the value of an item we wish
    to process is copied to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C (and C++), this limitation is addressed by the use of pointers. The preceding
    code may become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just pass the address of the src and target for the inverse result
    as two pointers (which is a small number of bytes). Unfortunately, this results
    in code inside the function that has to use the dereference operator (`*`) every
    time we use `src` or `inv`, making the code more difficult to read. In addition,
    the use of pointers has led to many problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ introduced a better approach – the variable alias or reference. A reference
    type is declared with the ampersand (`&`) operator. So, we can declare the invert
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that calling the method requires no special operator to pass the reference.
    From the compiler's viewpoint, a reference is still a pointer with one limitation
    – it cannot hold a nullptr. From the programmer's viewpoint, a reference allows
    us to reason about our code without having to worry about having the right dereference
    operator in the right place. This is known as **pass-by-reference**.
  prefs: []
  type: TYPE_NORMAL
- en: We saw references being passed to the copy constructor and the copy assignment
    method. The types of references, when used for their move equivalents, are known
    as **rvalue reference operators** and will be explained in *Chapter 3*, *The Distance
    Between Can and Should – Objects, Pointers, and Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of `pass-by-value` was that we cannot inadvertently modify the
    value of the variable that''s passed into a method. Now, if we pass-by-reference,
    we can no longer guarantee that the method we are calling will not modify the
    original variable. To address this, we can change the signature of the invert
    method to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The const keyword tells the compiler that, when it is processing the definition
    of the `invert()` function, it is illegal to assign a new value to any part of
    the value referenced by `src`. If the method does attempt to modify src, the compiler
    will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: In the Specifying Types – Variables section, we found that the declaration of
    `auto title` resulted in `title` being of the `const char *` type. Now, we can
    explain the `const` part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `title` variable is **a pointer to a char that is constant**. In other
    words, we cannot change the value of the data stored in the memory that we are
    pointing to. Therefore, we cannot do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the compiler will generate an error related to changing a constant
    value. We can, however, change the value stored in the pointer. We are allowed
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now been introduced to references for use as argument types to functions,
    but they can also be used as member variables instead of pointers. There are differences
    between references and pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: A reference must refer to an actual object (no equivalent of nullptr). A reference
    cannot be changed once it has been initialized (this has the consequence that
    a reference must either be default member initialized or appear in the member
    initialization list).The object must exist for as long as the reference to it
    exists (if the object can be destroyed before the reference is destroyed, then
    there is the potential for undefined behavior if an attempt is made to access
    the object).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Declaring and Using Reference Types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will declare and use reference types to make the code
    efficient and easier to read. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise06**, and double-click on **Exercise6.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure **Exercise6** to run with the name Exercise6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is complete, it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `rvalue` variable allows us to manipulate (read from and write
    to) the data stored in the `value` variable. We have a reference, `rvalue`, to
    the `value` variable. We can also see that the values stored in the `a` and `b`
    variables were exchanged by the `swap()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the editor, change the function definition of swap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button. When the Errors in Workspace dialog appears, click
    **Cancel**. The first error that''s reported by the compiler is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2A.39: Read-only error on assignment](img/C14583_02A_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.39: Read-only error on assignment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By changing the arguments from `int& lhs` to `const int& lhs`, we've told the
    compiler that the arguments should not be changed inside this function. And because
    we assign to lhs in the function, the compiler generates the error about lhs being
    read-only and terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Standard Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use fractions like a built-in class, we need them to work with the standard
    mathematical operators (`+, -, *, /`) and their assignment counterparts (`+=,
    -=, *=, /=`). If you are unfamiliar with assignment operators, then consider the
    following two expressions – they produce the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for declaring these two operators for Fraction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Because the `operator+=` method modifies the contents of the left-hand variable
    (adds a to b and then stores it again in a), it is recommended that it is implemented
    as a member variable. In this case, as we have not created a new value, we can
    just return a reference to the existing lhs.
  prefs: []
  type: TYPE_NORMAL
- en: The operator+ method, on the other hand, should not modify lhs nor rhs and return
    a new object. The implementer is free to implement it as a member function or
    as a free function. Both are shown in the preceding code, but only one should
    exist. The interesting thing to note about the member function's implementation
    is the const keyword at the end of the declaration. This tells the compiler that
    when this member function is called, it will not modify the internal state of
    the object. While both approaches are valid, if possible, `operator+` should be
    implemented as a normal function, outside of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach can be used for the other operators `– (subtract)`, `* (multiply)`,
    and `/ (divide)`. The preceding methods implement the semantics for the standard
    mathematical operators and make our type act like the built-in types.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Output Stream Operator (<<)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ abstracts Input/Output (I/O) into the stream class hierarchy in the standard
    library (which we will talk about in *Chapter 2B*, *No Ducks Allowed – Templates
    and Deduction*). In *Exercise 5*, *Declaring and Initializing Fractions*, we saw
    that we could insert the fraction into an output stream as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, for our Fraction class, we have written out the numerator and denominator
    values by accessing the data values from outside using the `getNumerator()` and
    `getDenominator()` methods, but there is a better way to do this. As part of making
    our classes first-class citizens in C++, where it makes sense, we should overload
    the I/O operators. In this chapter, we will only look at the output operator,
    <<, also known as the insertion operator. That way, we can replace the previous
    code with a much cleaner version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can overload the operator as either a friend function or a normal function
    (if the class provides getter functions of the data that we need to insert). For
    our purpose, we define it as a normal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Structuring Our Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we delve into the exercise where we implement the operators and turn
    our Fraction into a full-blown type in the C++ world, we need to have a brief
    discussion about where we put the bits and pieces of our class – the declaration
    and the definition. The declaration is the blueprint for our class that indicates
    what data storage it requires and the methods that it will implement. The definition
    is the actual implementation details of each of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: In languages such as Java and C#, the declaration and the definition are one
    and the same and they must exist in one file (Java) or across multiple files (C#
    partial classes). In C++, depending on the class and how much you wish to expose
    to other classes, the declaration MUST appear in a header file (which can be `#included`
    in other files for use) and the definition can appear in one of three places –
    inline in the definition, `inline` in the same file as the definition, or in a
    separate implementation file.
  prefs: []
  type: TYPE_NORMAL
- en: The header file is usually named with the .hpp extension, while the implementation
    file is typically one of `*.cpp` or `*.cxx`. The implementation file is also known
    as a **translation unit**. By defining a function as inline, we allow the compiler
    to optimize the code in a way that the function may not even exist in the final
    program – it has substituted the steps we put into the function into the locations
    that we call the function from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Adding Operators to the Fraction Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we aim to implement operators in our Fraction class using
    unit tests to develop the functionality. This makes our Fraction class a real
    type. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lesson2A** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2A**, then **Exercise07**, and double-click on **Exercise7.cpp**
    to open the file for this exercise in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Launch Configuration** drop-down menu and select **New Launch
    Configuration…**. Configure Exercise7 to run with the name Exercise7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that is complete, it will be the currently selected Launch Configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to configure a unit test. In Eclipse, click on the menu item called
    **Run** | **Run Configurations…**, right-click **C/C++ Unit** on the left-hand
    side, and select **New Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the name from `Lesson2A Debug` to `Exercise7 Tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **C/C++ Application**, select the **Search Project** option and choose
    **tests** in the new dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go to the **C/C++ Testing** tab and select **Google Tests Runner** in
    the dropdown. Click on **Apply** at the bottom of the dialog and click on the
    **Run** option for the test, which we have to run for the first time:![Figure
    2A.40: Failing tests – multiplication](img/C14583_02A_40.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.40: Failing tests – multiplication'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open the `operator*=` function. Update it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Run** button to rerun the tests. This time, all the tests pass:![Figure
    2A.41: Passing tests](img/C14583_02A_41.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.41: Passing tests'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In your IDE, open the `operator*=()`, while the other tested `operator*()`.
    How did fixing `operator*=()` fix `operator*()`? If you open Fraction.hpp in the
    editor, you will find that the `operator*()` function was implemented for you
    by making a call to `operator*=()`, that is, it is marked inline and is a normal
    function and not a member function. In general, this is the approach to take when
    overloading these operators – the one that modifies the object that is calling
    it is a member function, whereas the one that has to generate a new value is a
    normal function that calls the member function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file so that it reads like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `AddFractions` and `AddFractions2`:![Figure 2A.42: Additional
    tests to fail](img/C14583_02A_42.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2A.42: Additional tests to fail'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Locate the `operator+=` function in the **Function.cpp** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the necessary changes to the function and click on the `operator*=()` was
    implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `SubtractFractions` and `SubtractFractions2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `operator-=` function in the Function.cpp file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the necessary changes to the function and click on the **Run** button to
    rerun the tests until the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Run** button to rerun the tests – this time, we have added two
    more tests that fail – **DivideFractions** and **DivideFractions2**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `operator/=` function in the **Function.cpp** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the necessary changes to the function and click on the **Run** button to
    rerun the tests until the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Fraction.hpp** in the editor and change the line near the top of the
    file to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Click on the `InsertOperator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `operator<<` function in the Function.hpp file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the necessary changes to the function and click on the **Run** button to
    rerun the tests until the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Launch Configuration**, select **Exercise7** and click on the **Run**
    button. This will produce the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2A.43: Functional Fraction class](img/C14583_02A_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.43: Functional Fraction class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This completes our implementation of the `Fraction` class for now. We will return
    to it again when we consider exceptions in *Chapter 3*, *The Distance Between
    Can and Should – Objects, Pointers, and Inheritance*, so that we can deal with
    illegal values in our fractions (denominators of 0).
  prefs: []
  type: TYPE_NORMAL
- en: Function Overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ supports a feature known as function overloading, which is where two or
    more functions have the same name, but their argument list is different. The number
    of arguments can be the same, but at least one of the argument types has to be
    different. Alternatively, they may have a different number of arguments. So, the
    function prototype for the multiple functions are different. However, two functions
    cannot have the same function name, the same argument types, and a different return
    type. The following is an example of overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the multiple constructors on `Fraction` and the overloaded arithmetic
    operators are all examples of overloaded functions that the compiler has to refer
    to when it meets one of these functions. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When the compiler meets the line `print(42)`, it needs to work out which of
    the previously defined functions to call, so it performs the following process
    (grossly simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.44: Function overload resolution (simplified)](img/C14583_02A_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.44: Function overload resolution (simplified)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The C++ standard defines rules for how the compiler determines the best candidate
    function based on how it has to manipulate (that is, convert) the arguments to
    get a match. If no conversions are required, then that function is the best match.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, Structs, and Unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you define a class and do not specify an access modifier (public, protected,
    private), all the members will be private by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When you define a struct and do not specify an access modifier (public, protected,
    private), all the members will be public by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one other difference, which we will look at after we explain inheritance
    and polymorphism. A union is a different type of data construct from a struct
    and a class but is the same. A union is a special type of struct declaration where
    all the members occupy the same memory and only one member is valid at a given
    time. An example of a `union` declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: When you define a union and do not specify an access modifier (public, protected,
    private), all the members will be public by default.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with a union is that there is no intrinsic way to know which
    of the values is valid at any given time. This is resolved by defining what is
    known as a *tagged union* – that is, a struct that holds the union and an enum
    that identifies whether it is the valid value. There are also other restrictions
    on what can and cannot be included in a union (for example, only one member can
    have a default member initializer). We will not be exploring unions in depth in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Graphics Processing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a modern computing environment, matrices are used everywhere to solve various
    problems – to solve simultaneous equations, to analyze electricity power grids
    or electric circuits, to perform manipulations on objects for graphics rendering,
    and to deliver implementations of machine learning. In the world of graphics,
    whether two-dimensional (2D) or three-dimensional (3D), all the operations that
    you would want to perform on your objects can be done with the help of matrix
    multiplication. Your team has been tasked with developing a representation of
    points, transformation matrices, and the operations that you might want to perform
    on them. Follow these steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson2A/Activity01** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class called **Point3d** that can be constructed by default to be the
    origin, or using an initializer list of three or four values (data is stored directly
    in the class).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class called **Matrix3d** that can be constructed by default to an
    identity matrix, or using a nested initializer list to provide all the values
    (data is stored directly in the class).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On `operator()` so that it takes the (`index`) argument in order to return the
    value at `x(0)`, `y(1)`, `z(2)`, and `w(3)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On `operator()` to take (`row, col`) arguments so that it returns the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the unit tests to verify all of the aforementioned features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `operator*=(const Matrix3d&)` and `operator==(const Matrix3d&)` to the **Matrix3d**
    class, as well as the unit tests for them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add free functions for multiplying two **Matrix3d** objects and a **Matrix3d**
    object by a **Point3d** object with unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add standalone methods for creating a matrix to translate, scale, and rotate
    (around the x, y, z axes) and their unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After implementing the preceding steps, the expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_02A_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.45: Successfully running the activity program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the purpose of this activity, we will not be worrying about the possibility
    of out of range on indices. We will talk about this in *Chapter 3*, *The Distance
    Between Can and Should – Objects, Pointers, and Inheritance*. An identity matrix
    is a square matrix (4 x 4, in our case) where all the values on the diagonal are
    set to one (1) and all the other values are zero (0).
  prefs: []
  type: TYPE_NORMAL
- en: When working with 3D graphics, we use an augmented matrix for the points (vertices)
    and for the transformations so that all the transformations (translation, scaling,
    rotation) can be achieved by using multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `n × m` matrix is an array of n rows of m numbers. For example, a `2 x 3`
    matrix could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.46: Matrix of 2x3](img/C14583_02A_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.46: Matrix of 2x3'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A vertex in three dimensions can be represented as a `three-tuple (x,y,z)`.
    However, we augment it with another ordinate, `w (=1 for a vertex, =0 for a direction)`,
    making it a `four-tuple (x, y, z, 1)`. Rather than using a tuple, we place it
    in a `4 x 1` matrix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.47: 4x1 Matrix](img/C14583_02A_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.47: 4x1 Matrix'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we multiply the `4 x 1` matrix (point) by a `4 x 4` matrix (transformation),
    we can manipulate the point. If `Ti` represents a transformation, then we can
    multiply the transformations together to achieve some manipulation of the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.48: Multiplying transformations](img/C14583_02A_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.48: Multiplying transformations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To multiply a transformation matrix, `A x P = B`, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.49: Multiplying transformation matrix](img/C14583_02A_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.49: Multiplying transformation matrix'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can also express it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.50: Expression of multiplying transformations](img/C14583_02A_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.50: Expression of multiplying transformations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Likewise, the same can be done for two `4 x 4` matrices, multiplied together,
    `AxB=C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.51 Expression of 4x4 matrix multiplication:](img/C14583_02A_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.51 Expression of 4x4 matrix multiplication:'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The matrices for the transformations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2A.52: List of matrices for transformation](img/C14583_02A_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.52: List of matrices for transformation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 635.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about types in C++. Firstly, we touched on the built-in
    types and then learned how to create our own types that behave like the built-in
    types. We learned how to declare and initialize variables, got a glimpse of what
    the compiler generates from the source, where it puts variables, how the linker
    puts it together, and then what that looks like in the computer's memory. We learned
    some of the C++ tribal wisdom around the Rule of Zero and the Rule of Five. These
    form the building blocks of C++. In the next chapter, we will look at creating
    functions and classes with C++ templates and explore further type deduction as
    it applies to templates.
  prefs: []
  type: TYPE_NORMAL
