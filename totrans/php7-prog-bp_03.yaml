- en: Chapter 3.  Building a Social Newsletter Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to a reliable dictionary, a newsletter is a bulletin issued periodically
    to the members of a society, business, or organization.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be building an e-mail newsletter, that allows members
    to subscribe and unsubscribe, receive updates on certain categories, and also
    allows a marketer to check how many people visited a certain link.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be building an authentication system for our users to log in and log out
    of the newsletter management system, which is a social login system for subscribed
    members to easily check their subscriptions, and simple dashboards for subscribers
    and administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement a new authentication system in order to allow
    administrators of the newsletter to be authenticated. Since PHP5, PHP has improved
    and added a feature that object-oriented developers have used to separate namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining a namespace named `Newsletter` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, our `Newsletter` namespace will have an `Authentication` class.
    When other classes or PHP scripts need to use `Newsletter`''s `Authentication`
    class, they can simple declare it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside our `Newsletter` class, let's create a simple check for the user using  **bcrypt**,
    which is a popular and secure way of creating and storing hashed passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since PHP 5.5, bcrypt is built into the `password_hash()` PHP function. PHP's
    `password_hash()` function allows a password to become a hash. In reverse, when
    you need to verify that hash matches the original password, you can use the `password_verify()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class will be fairly simple-it will have one function used to verify if
    an e-mail address, and the hashed password that was entered is the same as the
    one in the database. We have to create a simple class that has only one method,
    `verify()`, which accepts the e-mail and the password of the user. We will use
    `bcrypt` to verify that the hashed password is the same as the one in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We, however, need to get the `DB` class to be able to do a simple query with
    our database. For this simple one-off project, we can simply use the concept of
    dependency injection in our `Authentication` class.
  prefs: []
  type: TYPE_NORMAL
- en: We should create a fairly trivial IOC container class, which allows us to instantiate
    the database along with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call it `DbContainer`, which allows us to connect a class, such as `Authentication`,
    to the `DB` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, if you use this function right away, an error will state that the file
    could not find and will load the `DB` class.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we used the `use` system of requiring classes. In order for this
    to work, we need to create an autoloader function to load our `DB` class without
    having to use `require` statements.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, there is the `spl_autoload_register` function we can create, which will
    take care of requiring the files needed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the example implementation based on the example that can be found
    in the PHP manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, we would now need to create a `src` directory and use
    this separator `\\` convention in separating the folder structure within your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Using this example means we'll need to put the database class file `DB.class.php`
    inside the `src` folder and rename the filename to just `DB.php`.
  prefs: []
  type: TYPE_NORMAL
- en: This was done so that when you specify that you want to use `DB` class in another
    PHP script, PHP will simply perform a `require src/DB.php` behind the scenes automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our example `DbContainer`, we'll need to somehow pass all our
    configuration information (that is, name of the database, username, and password
    to the MySQL database) inside the `DbContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s simply create a file `dbconfig.php` that has the database details and
    returns it as an object, and require it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `DbContainer` class, let''s create a `loadConfig()` function that reads
    from the `dbconfig.php` file and instantiates a database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create a `connect()` method, which will enable us to simply
    connect to a MySQL database and only return the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We made our function flexible by not hard-coding the filename into our function.
    When calling `loadConfig()`, we need to put the path to the `config` file to load.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the `$this` keyword so that any time we need to refer to other functions
    within the `DB` class, we just have to call `$DB->nameOfMethod(someParams)` after
    the autoloader loads and instantiates the `DB` class automatically when you call
    `$DB = new \DB()`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we now have the flexibility to easily change the `config` file's
    path in case we move the `config` file to other paths, for example, to a folder
    that is not directly accessible through the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can easily use this function and generate a database instance in a
    separate class, for example, in our `Newsletter` class, we can now make a reference
    to an instance of the `DB` class connection and instantiate it within the `Newsletter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done with this, we should simply create a Bootstrap file that
    loads the `spl_autoload_register` function and the connection to the database
    using the `dbContainer` all together. Let''s name the file `bootstrap.php`, and
    it should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to connect to the database with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After we've all connected to the database, we need to rewrite our authorization
    query to use the new initialized classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple `select_where` method in our `DB` class and then call
    it from the `Authorization` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Authorization` class now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a social login for members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For us to have more people subscribing easily, we will implement a way for Facebook
    users to simply log in and subscribe to our newsletter without having to type
    their e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: Login via Facebook works through  **Oauth**. The first step is to generate app
    authentication tokens by going to [https://developers.facebook.com/](https://developers.facebook.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see your list of apps or click on the apps to create. You should
    see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a social login for members](graphics/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should create an app first and be able to obtain your app ID and app secret
    by visiting the app creation page, similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a social login for members](graphics/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When creating the new app, Facebook now includes a way for you to test that
    app ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a social login for members](graphics/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is for you to test that the app ID actually works. It is optional and you
    may skip that step and just plug in the values for your app ID and app secret
    into the code shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create the `fbconfig.php` file, which will contain a way for us to
    use the Facebook SDK library to enable the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fbconfig.php` script will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we basically start a session with `session_start()` and set up the domain
    of our website by saving it into a variable. We then autoload the FB SDK, which
    will require the files and classes needed by Facebook to access its API for logging
    in.
  prefs: []
  type: TYPE_NORMAL
- en: We then set up several dependencies on other Facebook SDK classes by using the
    `use` keyword. We set up the `facebookSession` class with our app ID and app secret
    and then attempt to get a session started by calling the `getSessionfromRedirect()`method.
  prefs: []
  type: TYPE_NORMAL
- en: If there are any errors that get caught from trying to start the session, we
    simply let the user know that we could not log him in, but if everything proceeds
    successfully, we start a graph object with the e-mail of the user.
  prefs: []
  type: TYPE_NORMAL
- en: For our demonstration purposes, we save a username that is actually the e-mail
    address of the user once we get the e-mail by using the Facebook graph.
  prefs: []
  type: TYPE_NORMAL
- en: We will authenticate everyone by checking their e-mail addresses anyway, and
    to make it easier for a user to login, let's just store their e-mail as the username.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to finish up our site with `index.php` that shows the user what's
    inside our site. We get there after the login from Facebook page redirects the
    user to the `index.php` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll keep it simple for now and display the full name from the Facebook profile
    of the user who logged in. We''ll add a logout link to give the user an option
    to logout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After logging in, we just have to display the dashboard for the user. We will
    discuss how to create a basic dashboard for the user in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Member dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, when the member has logged in our app, they can now subscribe to newsletters
    using the member subscription page. Let''s first build out the databases that
    will be used to store member details and their subscriptions. The `member_details`
    table will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firstname` and `lastname`: The real name of the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: To be able to e-mail the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canNotify`: Boolean (true or false), if they accept being e-mailed notifications
    about other offers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's something that's interesting about the boolean type in MySQL. When you
    create a field that uses boolean (true or false), MySQL actually just aliases
    it to `TINYINT(1)`. Boolean is basically 0 for false and 1 for true. For more
    info, refer to [http://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html](http://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `member_details` table will handle this and it will be created using the
    following SQL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When logging in, our members will be stored in the `users` table. Let''s create
    that with the following SQL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, build the view that shows our members all the different subscriptions
    we have. We do this by checking the table `subscriptions`. The `subscriptions`
    table schema is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '``id` Int(11)`: This is the primary key for the `subscriptions` table and is
    set with `AUTO_INCREMENT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newsletter_id Int(11)`: This is the `newsletter_id` that they are subscribed
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active BOOLEAN`: This indicates whether the user is currently subscribed (default
    1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using SQL, it will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will also have to create the `newsletters` table, which will hold all the
    newsletters, their template, and their content in JSON format. By using JSON as
    a storage format in our database, it should now make it simple to fetch data from
    the database and parse JSON into the proper values to insert into our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our newsletters will be stored in the database, we need to create the
    proper SQL schema for it. This is how it will be designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id INT(11)`: To index our newsletters in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newsletter_name (Text)`: The title of our newsletter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newsletter_count INT(11)`: To record the edition of our particular newsletter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Status (String)`: To record the status of our newsletter, if it''s been published,
    unpublished, or pending publication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slug (String)`: To be able to view the newsletter with the browser on our
    social newsletter''s website'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Template (Text)`: To store the HTML template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content (Text)`: To store the data that will go into our HTML template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Published_at (Date)`: To record the date of publication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Created_at (Date)`: To record the time that the newsletter was first created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Updated_at (Date)`: To record when the last time that someone updated the
    newsletter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SQL for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When user unsubscribes, this will help indicate that they were previously subscribed
    to this newsletter. This is why we'll store an `active` field so that when they
    unsubscribe, instead of deleting the record, we just set this to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The `marketer_id` is going to be used in the future admin portion where we mention
    the person who will be in charge of the management of the newsletter subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newsletters may also have many publications, which will be the actual newsletters
    that get sent to each subscription. The following SQL code is to create publications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s build the methods in our `Newsletter` class to select logged-in
    members subscriptions for displaying into our dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we simply created a function that would get the subscriptions
    for a given member ID. First, we create the `"SELECT * FROM subscriptions, newsletters
    WHERE subscriptions.member_id =''". $member_id."` query. After this, we loop through
    the query results using the `fetch_assoc()` method of the MySQLi result object.
    Now that we''ve stored it in the `$data` variable, we return the variable, and
    in the following code, we display the data in a table by invoking the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Marketers dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our marketers, who administer each newsletter that they own, will be able log
    in to our system and be able to see how many members are subscribed and their
    e-mail addresses.
  prefs: []
  type: TYPE_NORMAL
- en: It is going to be an admin system that enables a marketer to update a member's
    record, view recent subscriptions, and allow a marketer to send custom e-mails
    to any member of their newsletter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll have a table called `marketers`, which will have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: To store the index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marketer''s name: To store the name of the marketer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marketer''s e-mail: To store the e-mail address of the marketer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Marketer''s password: To store the marketer''s login password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our SQL for creating the preceding fields is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In another table, we'll define the many-to-many relationship of marketers and
    their newsletters that they manage.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need an `id` to be the index, the ID of the marketer who owns the newsletter,
    and the newsletter's ID, which is owned by the marketer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL to create this table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s build a query for fetching the admins of a newsletter that they
    own. This is going to be a simple class where we will reference all our database
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Administration system for managing marketers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need a way for the marketers to log in and be authenticated with a password.
    We need a way for an admin to create the account and register a marketer and their
    newsletter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build that part first.
  prefs: []
  type: TYPE_NORMAL
- en: In our admin view, we'll need to set a default and ask for an authenticated
    password for every action that is performed. This is something we don't need to
    store in the database since there will be only one administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `config`/`admin.php` file, we will define the username and the password
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then just include the file in our login page, `login.php`.We will simply
    check for it. The code for the login page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have to set our website URL correctly, depending on where we''re
    developing it. In the preceding example, the page will redirect to [http://ourwebsite.com/admin/welcome_dashboard.php](http://ourwebsite.com/admin/welcome_dashboard.php)
    after logging in. We can create variables to store the domain and the URL fragment
    to redirect to so that this can be dynamic; see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once logged in, we'll need to build a simple CRUD (Create, Read, Update, Delete)
    system to manage the marketers who will be administering their newsletters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to be able to get the list of marketers and the newsletters
    they manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to add a way to edit, create, and delete marketers. Let's create
    a `dashboard`/`table_header.php` to include at the top of our script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what the `table_header.php` code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create a `for()` loop to loop through each of the marketer. Let''s
    create a way to select through all the marketers in our database. First, let''s
    call our function to get data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s use a `foreach()` loop to loop through all the marketers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then we end the code with a closing element for the table with `</table>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `delete_marketer.php` script and the `edit_marketer.php`
    scripts. The following will be the delete script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the edit script composed of a form that will update the data once submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Custom template for our newsletter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every marketer needs to lay out their newsletter. In our case, we can allow
    them to create a simple sidebar newsletter and a simple top-down newsletter. To
    build a simple sidebar, we can create an HTML template that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we style the HTML e-mail using in-line tags simply because
    some e-mail clients do not render stylesheets referenced from outside our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: We can use **regex** to substitute the `{{MENU}}` and `{{CONTENT}}` patterns
    with the data to populate them.
  prefs: []
  type: TYPE_NORMAL
- en: Our database will store the content as JSON, and once we parse the JSON, we'll
    have the content and menu data to insert into their respective places.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our database, we need to add the `newsletter_templates` table. Here is how
    we will create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With the template in place, we need a way for marketers to update the template.
  prefs: []
  type: TYPE_NORMAL
- en: From the dashboard, we display a list of templates for the newsletter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We also populated the `textarea` by adding values to it. Note that in the preceding
    code, we needed to clean the HTML code for the template using `htmlentities` first.
    This is because our HTML might be interpreted as part of the web page and cause
    problems when rendered by a browser.
  prefs: []
  type: TYPE_NORMAL
- en: We now have everything in place in order for our newsletter to send an actual
    newsletter. To do the sending, we'll need to create a script that will loop through
    all the members in a newsletter and then simply use the PHP mail function to send
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PHP mail function, we just have to loop through all the newsletter
    members in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what that script looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to complete the `replace_menu` and `replace_contents` functions. Let''s
    simply build the text replace function that will replace the content we have already
    fetched in the preceding code. The data comes from the newsletter table in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we modified our table to have a menu in the newsletter. This menu
    must be created by the user and with HTML markup. It will basically be an HTML
    list of links. The proper markup for the menu should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Link tracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our link tracking system, we will need to allow a marketer to embed links,
    which actually pass through our system for us to keep track of the number of clicks
    on the link.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do is actually create a service that will automatically shorten
    the links we enter to a random hash. The URL will look like `http://example.com/link/xyz123`,
    and the hash  `xyz123` will be stored in our database. When a user accesses the
    link, we'll match the link.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the links table and create a function that will help us generate
    the shortened links. At the bare minimum, we need to be able to store the title
    of the link, the actual link, the shortened link, as well as who created the link
    so that we can put it on the marketer's dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL for the links table looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the following function, which will generate a random hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to store the number of hits or clicks to the link. We will use
    another table that will link `link_id` to the number of hits, and we''ll just
    update that table every time someone has used a shortened link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t need to index the preceding SQL table because we won''t really need
    to do fast searches on it. Every time we generate a new URL, we should populate
    the table already with the `num` hits defaulting to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function in the `createShortLink` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `insert_id` is the ID of the last inserted record of MySQL. It's a function
    that returns the new ID generated every time a new row is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate the link hit class that contains two functions, one to initialize
    the database and another that will update the `link_hits` table every time a user
    clicks on a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For our marketers to view the links, we will need to display their links on
    a `links` page in our portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the function for checking the links and their hits that is attributed
    to the admin user who is logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we just got the logged-in user's ID by checking the variable
    `$_SESSION['user_id']`. Then we performed an SQL query by executing the string
    variable `$SQL`. After this, we loop through the results and show the results
    into an HTML table. Note that we exit the PHP code when we display a permanent
    HTML markup such as start of the table and the headers and the ending of the `</table>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: PHP performs slightly better without using echo statements, and this is the
    beauty of PHP scripting, you are really allowed to go into the PHP sections and
    then into the HTML sections in your code. Your opinion may differ on the beauty
    of this idea, but we just want to show what PHP can do in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX socket chat for support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This system allows the subscribers to contact the administrator of a particular
    newsletter group. It will just contain a contact form. Also, we shall need to
    implement a way to send a notification to the administrator in real time.
  prefs: []
  type: TYPE_NORMAL
- en: We will basically add a socket connection to the administrator so that when
    ever someone sends an inquiry, it will flash a notification on the marketer's
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty simple with **socket.io** and a browser technology called WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to socket.io
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With socket.io, we don't need to create the code for checking the server periodically
    for an event. We'll just pass through the data the user entered by using AJAX
    and trigger the listeners to the sockets by emitting the events. It offers long
    polling and communication through WebSockets and is supported by modern web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebSockets extends the concept of having socket connections through a browser.
    To read more on WebSockets, please visit [http://www.html5rocks.com/en/tutorials/websockets/basics/](http://www.html5rocks.com/en/tutorials/websockets/basics/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample code on the socket.io site just includes the `socket.io.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our PHP webserver will be using something called  **Ratchet**, which has a website
    at [http://socketo.me](http://socketo.me). It basically allows us to use WebSockets
    for PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is their website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to socket.io](graphics/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ratchet is just a tool to allow PHP developers "*to create real time, bi-directional
    applications between clients over WebSockets*". By creating a bi-directional flow
    of data, it allows developers to create things such as real-time chat and other
    real-time applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by following their tutorial at [http://socketo.me/docs/hello-world](http://socketo.me/docs/hello-world).
  prefs: []
  type: TYPE_NORMAL
- en: 'With Ratchet, we have to install  **Composer** and add the following to our
    `composer.json` file in our project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you've had prior experience with Composer, basically what it does is use
    the `psr-0` standard in writing the path to a script that needs autoloading. Then
    we run `composer install` in the same directory. After having Ratchet set up,
    we need to set up the proper components for handling certain events.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a folder labeled `SupportChat` and put `Chat.php` inside.
    This is because using psr-0 in the preceding `composer.json` file, it expects
    a directory structure inside the `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a class with the stubbed functions that we need to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We need to declare the `$clients` variable to store the clients that will connect
    to our chat app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the interface for when the client opens a connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the `onMessage` and `onClose` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create an `onError` method for handling errors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to implement the client (browser) side of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `app.js` in your `htdocs` or `public` folder with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create the HTML for the preceding code to be used. We should name
    the file `app.js`. Now, let''s implement a simple input text for the user to enter
    their messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`App.js` is where the JavaScript code we wrote earlier should go. We also need
    to create a WebSocket server to handle the WebSocket on port `8088`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Our chat app is now ready for public use. However, we need to start our chat
    server, which will handle WebSockets by starting it with `php bin/server.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that on Windows, it will prompt about the network being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to socket.io](graphics/image_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simply click on **Allow access** and then click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we visit `http://localhost/client.html`, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to socket.io](graphics/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, we need to spiff up the contact form by adding the username and e-mail
    for support to get back to him via e-mail in case no one from support is available
    to reply to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our form now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Since we've added those details, we need to store them in our database. We can
    do this by having all the data forwarded to another PHP script to do the sending.
    In JavaScript, the code would add to the handler a way to send to the `sendsupportmessage.php`
    the values from the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how that JavaScript code, with jQuery, will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In the script that will receive the messages, `sendsupportmessage.php`, we''ll
    need to parse the information and create an e-mail to send to the support e-mail,
    `contact@yoursite.com`; see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The script just checks if the submitted values are not blank. By experience,
    using `!empty ()` instead of checking for a set value with the `isset()` function
    is better because an empty string (`''''`) may be evaluated by PHP to still be
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to display to the user, as we sent the message to the server using
    AJAX, and update the AJAX box. In the JavaScript code, we should change the `.done()`
    callback code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! Notice that we changed the alert box call and instead appended the
    message `Your message was sent` back into the message list. Our support form now
    sends who the message is from and our support team can receive the message in
    their e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter. To summarize, we built a simple admin system
    to manage our marketers. After this, we also created a way for members of the
    newsletter to log in which leads the user to a home page.
  prefs: []
  type: TYPE_NORMAL
- en: Then we reviewed how to send an e-mail with a simple template system, which
    allowed a user to add his/her own menu and the content to the layout. We were
    also able to add Facebook social login by using the Facebook PHP SDK and its authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter part of the chapter, we built a simple chat system that will send
    an e-mail immediately to the support e-mail address of our website. We checked
    out Ratchet, a PHP library to help us work with real-time messaging in PHP, and
    used AJAX to asynchronously send the data to another script that will do the e-mailing
    to the support e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: We've now created an impressive newsletter app that is more than the regular,
    with social login features and a support chat box, and allows other newsletter
    marketers to manage their content through a website.
  prefs: []
  type: TYPE_NORMAL
