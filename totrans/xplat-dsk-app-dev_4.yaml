- en: Creating a Chat System with Electron and React – Enhancement, Testing, and Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Electron和React创建聊天系统-增强、测试和交付
- en: We finished the last chapter with a static prototype. We learned about React,
    composed the components, but didn't provide them with any state. Now, we will
    start binding the state of the application window to the Header component. As
    the state concept clarified, we will move to the chat services. After getting
    a brief introduction to the WebSockets technology, we will implement both the
    server and client. We will bind the service events to the application state. Finally,
    we will have a fully working chat. We won't stop on it, but will take care of
    the technical debt. So, we will set up the Jest testing framework and unit-test
    both the stateless and stateful components. Afterward, we will package the application
    and publish releases though a basic HTTP server. We will extend the application
    to update when new releases are available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上一章以静态原型结束。我们了解了React，组合了组件，但没有为它们提供任何状态。现在，我们将开始将应用窗口的状态绑定到标题组件。随着状态概念的澄清，我们将转向聊天服务。在简要介绍了WebSockets技术之后，我们将实现服务器和客户端。我们将把服务事件绑定到应用状态。最后，我们将拥有一个完全可用的聊天功能。我们不会停在这里，而是会处理技术债务。因此，我们将设置Jest测试框架，并对无状态和有状态组件进行单元测试。之后，我们将打包应用程序，并通过基本的HTTP服务器发布版本。我们将扩展应用程序以在有新版本可用时进行更新。
- en: Revitalizing the title bar
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重振标题栏
- en: Until now, our title bar was not really useful. Thanks to the Photon framework,
    we can already use it as a handle to drag and drop the window across the viewport,
    yet we are missing windowing actions such as close, maximize, and restore window.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们的标题栏并不是真正有用的。多亏了Photon框架，我们已经可以将其用作拖放窗口的手柄，但我们还缺少窗口操作，比如关闭、最大化和还原窗口。
- en: 'Let''s implement them:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现它们：
- en: '`./app/js/Components/Header.jsx`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`./app/js/Components/Header.jsx`'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We do not go with methods, with properties keeping anonymous functions bound
    to the object scope. This trick is possible, thanks to `babel-plugin-transform-class-properties`,
    which we included in the manifest and Webpack configuration in [Chapter 3](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml),
    *Creating a Chat System with Electron and React – Planning, Design, and Development*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用方法，而是使用将匿名函数绑定到对象范围的属性。这个技巧是可能的，多亏了我们在[第3章](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml)中包含在清单和Webpack配置中的`babel-plugin-transform-class-properties`。
- en: 'We extended the component with handlers to close the window, to maximize, and
    then to restore to its original size. We already have a `close` button in JSX,
    so we just need to subscribe to the corresponding handler method for the `click`
    event using the `onClick` attribute:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了组件，添加了关闭窗口、最大化和还原到原始大小的处理程序。我们在JSX中已经有了`close`按钮，所以我们只需要订阅相应的处理程序方法来处理`click`事件，使用`onClick`属性：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `maximize` and `restore` buttons, though, are rendered in HTML conditionally,
    depending on the current window state. Since we will utilize the state, let''s
    define it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`maximize`和`restore`按钮是有条件地在HTML中渲染的，取决于当前窗口状态。因为我们将利用状态，让我们来定义它：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `isMaximized` state property takes in the corresponding flag from the current
    window instance. Now, we can extract this value from the state in JSX:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`isMaximized`状态属性接收当前窗口实例的相应标志。现在，我们可以从JSX中提取这个值的状态：'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, we render the `restore` button when it is true and `maximize` otherwise.
    We also subscribe the handlers for the `click` events on both the buttons, but
    what about changing the state after the window maximizes or restores?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当`restore`为true时，我们渲染`restore`按钮，否则渲染`maximize`按钮。我们还订阅了两个按钮的`click`事件的处理程序，但是窗口最大化或还原后如何改变状态呢？
- en: 'We can subscribe to the corresponding window events straight before the component
    is rendered to the DOM:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件呈现到DOM之前，我们可以订阅相应的窗口事件：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the window changes its state handler, `updateState` invokes and actualizes
    the component state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口改变其状态处理程序时，`updateState`会调用并更新组件状态。
- en: Utilizing WebSockets
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用WebSockets
- en: We have a static prototype, and now we will make it functional. Any chat requires
    communication between connected clients. Usually, clients do not connect directly
    but through a server. The server registers connections and forwards the messages.
    It's pretty clear how to send a message from the client to server, but can we
    do it in the opposite direction? In the olden days, we had to deal with long-polling
    techniques. That worked, but with the overhead of HTTP, it is not really suitable
    when we mean a low latency application. Luckily for us, Electron supports WebSockets.
    With that API, we can open a full-duplex, bi-directional TCP connection between
    the client and server. WebSockets provides higher speed and efficiency as compared
    to HTTP. The technology brings reduction of upto 500:1 in unnecessary HTTP traffic
    and 3:1 in latency ([http://bit.ly/2ptVzlk](http://bit.ly/2ptVzlk)). You can find
    out more about WebSockets in my book *JavaScript Unlocked* ([https://www.packtpub.com/web-development/javascript-unlocked](https://www.packtpub.com/web-development/javascript-unlocked)).
    Here, we will get acquainted with the technology briefly, with the help of a small
    demo. I suggest examining an echo server and a client. Whenever a client sends
    a text to the server, the server broadcasts it on all the connected clients. So,
    on every page with the client loaded, we receive the message in real time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we won''t write a protocol implementation for the server, but go
    with an existing NPM package--nodejs-websocket ([https://www.npmjs.com/package/nodejs-
    websocket](https://www.npmjs.com/package/nodejs-websocket)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the package API, we can quickly make our code to serve incoming messages
    from the client:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`./server.js`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we instantiate an object representing the WebSockets server (`server`).
    Within the callback of the `createServer` factory, we will receive connection
    objects. We subscribe to every connection for the `"text"` and `"error"` events.
    The first one happens when a data frame is sent from the client to the server.
    We simply forward it to every available connection. The second event is fired
    when something goes wrong, so we report the error. Finally, we start the server
    in the given port and host, for example, I set port `8001`. If this port is taken
    in your environment by any other program, just change the value of the `PORT`
    constant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compose the client of this simplified chat as a single page application.
    So create the following HTML:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the HTML, we placed a form with input control and output container. The intent
    is to send input value on form, submit it to the server, and display the server
    response in the output element.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript, we store a reference to the acting nodes and create an instance
    of the WebSockets client. We subscribe for the `error`, `open`, and `message`
    client events. The first two basically report on what is happening. The last one
    receives events from the server. In our case, the server sends text messages,
    so we can take them as `e.data`. We also need to handle the input from the client.
    Therefore, we subscribe for `submit` on the form element. We use the `send` method
    of the WebSockets client to dispatch the input value to the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the example, we can use the `http-server` module ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server))
    to launch a static HTTP server for our `index.html`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can add the following commands to `package.json`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we can run the server as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and then the client as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/b2410346-8edf-4dc5-bb31-5b3cc5f06751.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Implementing chat services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I believe that it''s more or less clear how WebSockets works now, and we can
    apply the API for our chat. However, in a real application, we need something
    more than to echo sent texts. Let''s put the intended event scenarios on paper:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The `Welcome` component handles user input and sends via the client to the `join`
    server event with the entered user name in the payload
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server receives the `join` event, adds a new user to the set, and broadcasts
    the `participants` event with the updated set
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client receives the `participants` event and passes the set to the `Participants`
    component, which updates the participant's list
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Conversation` component handles user input and sends the entered message
    via the client to the server as the `text` event with username, text, and timestamp
    in the payload
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server receives the `text` event and broadcasts it to all the chat participants
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we deal with event messages, we need a unified format for sending and receiving
    a single source of truth. So, we implement a message wrapper--`./app/js/Service/Message.js`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This module exposes two static methods. One transforms the given event name
    and payload into a JSON string, which can be sent through WebSockets; another
    translates the received string into a message object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we write the server--`./app/js/Service/Server.js`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The same as the echo server, this one subscribes to connection events to report
    what is going on and exposes the `broadcast` and `connect` methods. To make it
    handle incoming messages, we extend the `createServer` callback:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, when receiving a message, the server tries to call a handler method matching
    the event name. For example, when it receives `join` event, it calls `onjoin`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method accepts the event payload (the user name here) as the first parameter
    and the connection reference as the second. It registers the connection in `this.participant`
    map. So, we can now determine the associated user name and registration timestamp
    by a connection. The method then broadcasts the values of the map as an array
    (a set of usernames and timestamps).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we shall not forget to define `this.participants` as a map in the
    class constructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also add a handler method for the `text` event:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The method extracts the username associated with the given connection from the
    `this.participants`, extends the message payload with it, and broadcasts the derived
    message.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write the client--`./app/js/Service/Client.js`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The client implements the same trick with the handler methods as the server,
    but this time, we make the `connect` method return a Promise. Thus, we can adjust
    the execution flow if the client failed to connect the server. We have two handlers:
    `onparticipants` and `ontext`. Both of them simply bypass the received message
    to the application. Since the `Client` class extends `EventEmitter`, we can use
    `this.emit` to fire an event and any subscribed application module will be able
    to catch it. Besides, the client exposes two public methods: `join` and `message`.
    One (`join`) will be consumed by the `Welcome` component to register the provided
    username on the server, and the other (`message`) is called from the `Participants`
    component to communicate the submitted text to the server. Both the methods rely
    on the `send` private method, which actually dispatches messages.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron comprises of the Node.js runtime and therefore allows us to run the
    server. So, to make it simpler, we will include the server into the application.
    For that, we modify the server code again:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now it runs the supplied `client.connect` to establish a connection with our
    WebSockets server. If it's the very first instance of the application running,
    no server is yet available. Therefore, the client fails to connect and execution
    flow jumps into the catch callback. There, we start the server and reconnect the
    client.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Bringing functionality to the components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now when we have the server and client services, we can enable them in the
    application. The most suitable place is the `App` container--`./app/js/Containers/App.jsx`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Do you remember that we rendered either the `ChatPane` or `Welcome` component
    conditionally in the static prototype?:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Back then, we hardcoded `name`, yet it belongs to the component state. So,
    we can initialize the state in the class constructor like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Well, `name` is empty by default and we, therefore, show the `Welcome` component.
    We can type in a new name there. As it''s submitted, we need to somehow change
    the state in the parent component. We achieve it with a technique known as **Lifting
    state up**. We declare a handler for the `name` change event in the `App` container
    and pass it to the `Welcome` component with the props:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, we extract `name` from the state and use it in the expression. Initially,
    `name` is empty and therefore the `Welcome` component is rendered. We declare
    the `onNameChange` handler and pass it to the `Welcome` component with the props.
    The handler receives the submitted name, registers the new connection on the server
    (`this.client.join`), and changes the component state. So, the `ChatPane` component
    replaces `Welcome`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will edit the `Welcome` component--`./app/js/Components/Welcome.jsx`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whenever a component expects any props, it usually means that we have to apply
    the `defaultProps` and `propTypes` static methods. These belong to the `React.Component`
    API and are automatically called during component initialization. The first one
    sets a default value for the props and the second validates them. In HTML, we
    subscribe to the `onSubmit` handler for the form `submit` event. In the handler,
    we need to access an input value. With the `ref` JSX attribute, we added the instance
    as a reference to the input element. So, from the `onSubmit` handler, we can obtain
    the input value as `this.nameEl.value`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, now the user can register in the chat, and we need to show the chat UI--`./app/js/Components/ChatPane.jsx`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This one is a composite component that lays out the `Participants` and `Conversation`
    children components and forwards `client` to them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is meant to display the list of participants--`./app/js/Components/Participants.jsx`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we need some construction work. First, we define the state, which includes
    the participant list from the props. We also subscribe to the client `participants`
    event and update the state every time the server sends an updated list. When rendering
    the list, we also show participant registration time, such as joined 5 minutes
    ago. For that, we use a third-party component, `TimeAgo`, provided by the `react-timeago`
    NPM package.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, we are coming to the `Conversation` component--`./app/js/Components/Conversation.jsx`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: During the construction, we subscribe to the client `text` event and collect
    the received messages in the `this.messages` array. We use these messages to set
    the component state. In the `render` method, we extract the message list from
    the state and traverse it to render every item. The message view includes the
    sender's name, text, and time. The name we output as it is. We split the text
    in lines and wrap them with the paragraph element. To display time, we use the
    `normalizeTime` static method. This method transforms the `Date` object into a
    long string (date and time) when it's older than today, and into a short string
    (date) otherwise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a form for sending messages to the chat. The ideal method would
    be to put the form into a separate component, but for the sake of brevity, we
    will keep it next to the conversation view:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Pretty much as in the `Welcome` component, we make a local reference to the
    text area node and subscribe the `onSubmit` handler for the form `submit` event.
    To make it user-friendly, we set `onKeydown` to listen to a keyboard event on
    the text area. When *Enter* is pressed during typing, we submit the form. So,
    we have to now add new handlers to the component class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the form is submitted either by pressing the OK button or *Enter*, we pass
    the message to the server via the `message` method of the client and reset the
    form.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'I don''t know about you, but I have the itch to run the application and see
    it in action. We have two options here. We can just start multiple instances from
    the same machine, register each one with a different name, and start chatting:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/389cf4cd-b808-434f-a669-4649c4fef2f9.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Alternatively, we set a public IP in the `App` container to make the chat available
    across the network.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit-tests
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In real life, we cover application functionality with unit-tests. When it comes
    to React, the Jest testing framework is the first to pop up in one''s mind. The
    framework is developed by Facebook as well as React. Jest is not aimed at React
    only; you can test any JavaScript. Just to see how it works, we can set up a new
    project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Install Jest by running the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Edit the `scripts` section in `package.json`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Place the example unit for testing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`./unit.js`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is a simple pure function that double any given number. What we need to
    do now is to just place a JavaScript file of a name matching the `*.(spec|test).js`
    pattern--`./unit.spec.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you are familiar with Mocha or, better, Jasmine, you will have no problem
    reading this test suite. We describe an aspect (`describe()`), declare our expectations
    (`it()`), and assert that the result produced by the unit under test meets the
    requirements (`expect()`). Basically, the syntax doesn't differ from the one we
    used in [Chapter 2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml), *Creating a File
    Explorer with NW.js – Enhancement and Delivery*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'By running `npm test`, we get the following report:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6bd66e6-b7d5-4c3e-a007-73158c9efea9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'What makes Jest preferable in our case is that it''s really close to the React
    philosophy and incorporates specific features for testing a React application.
    For example, Jest comprises of the `toMatchSnapshot` assertion method. So, we
    can build a component in the virtual DOM, and make and save the snapshot of the
    element. Then, after refactoring, we run the tests. Jest takes actual snapshots
    of the modified components and compares them to the stored ones. That''s a common
    approach for regression tests. Before putting it into practice, we have to set
    up Jest for our environment. We specified our bundling configuration in `webpack.config.js`.
    Jest won''t consider this file. We have to compile the source for Jest separately,
    and we can do it with `babel-jest`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This plugin takes the code transformation instructions from the Babel runtime
    config--`./.babelrc`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we use preset env ([https://babeljs.io/docs/plugins/preset-env/](https://babeljs.io/docs/plugins/preset-env/)),
    which automatically determines and loads the plugins required by the target environment
    (Node.js 7). Do not forget to install the preset:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We also apply the `transform-class-properties` and `transform-class-properties`
    plugins to get access to rest, spread, and ES Class Fields and Static Properties
    syntax, respectively (we have already used these plugins for Webpack configuration
    in [Chapter 3](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml), *Creating a Chat System
    with Electron and React – Planning, Design, and Development*).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in the `normalizeTime` test example, we will modify the manifest--`./package.json`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This time, we also explicitly point Jest to our source directory, `app/js`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'As I explained earlier, we will produce snapshots of React components for further
    assertions. That can be achieved with the `react-test-renderer` package:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can write our first component regression test--`./app/js/Components/Footer.spec.jsx`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Yeah, it turned out that easy. We create an element with `renderer.create` and
    obtain static data representation by calling the `toJSON` method. When we first
    run the test (`npm test`), it creates the `__snapshots__` directory with the snapshot
    next to the test file. Every subsequent time, Jest compares the stored snapshots
    to the actual ones.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reset snapshots, just run ``npm test -- -u``.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing a stateful component is similar--`./app/js/Components/Participants.spec.jsx`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the `getInstance` method of the created element to access the component
    instance. Thus, we can call the methods of the instance that set the concrete
    state. Here, we pass the fixture list of participants directly to the `onClientParticipants`
    handler. The component renders the list, and we make a snapshot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Regression tests are good to check whether the component wasn''t broken during
    refactoring, but they do not guarantee that the component behaved as intended
    in the first place. React provides an API via the `react-dom/test-utils` module
    ([https://facebook.github.io/react/docs/test-utils.html](https://facebook.github.io/react/docs/test-utils.html)),
    which we can use to assert that the component really renders everything we expect
    from it. With third-party package enzyme, we can do even more ([http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)).
    To get an idea about it, we add a test in the `Footer` suite--`./app/js/Components/Footer.spec.jsx`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, we assume that the component renders an HTML footer element (`tree.find(
    "footer" )`). We also check whether the footer contains the project name from
    the manifest:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e9f94f-9b0f-42e5-8b81-ec9c543ff535.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Packaging and distribution
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we worked with File Explorer and NW.js, we used the `nwjs-builder` tool
    for packaging our application. The Electron has an even more sophisticated tool--electron-builder
    ([https://github.com/electron-userland/electron-builder](https://github.com/electron-userland/electron-builder)).
    Actually, it builds an application installer. The range of target package formats
    electron-builder supports is impressive. Then, why not try packaging our application?
    First, we install the tool:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We add a new script to the manifest--`./package.json`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also set an arbitrary ID for the application in field build:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We definitely want to provide the application with an icon, so we create the
    `build` subdirectory and place their `icon.icns` for macOS, `icon.ico` for Windows
    there. Icons for Linux will be extracted from `icon.icns`. Alternatively, you
    can place icons in `build/icons/` named after their sizes--`64x64.png`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we have not yet granted our application window with an icon. To fix
    it, we modify our main process script--`./app/main.js`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Everything seems ready, so we can run the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As the process completes, we can find the generated package in the default
    format in the newly created `dist` folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu: `chat-1.0.0-x86_64.AppImage`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` Windows: `chat Setup 1.0.0.exe`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` MacOS: `chat-1.0.0.dmg`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, we can aim for a specific target format:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the diverse package format may require additional metadata in the
    manifest ([https://github.com/electron-userland/electron-builder/wiki/Options](https://github.com/electron-userland/electron-builder/wiki/Options)).
    For instance, packaging in `.deb` requires both the `homepage` and `author` fields
    filled in.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and updates
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Built-in capacities for auto updates is one of Electron's most prominent advantages
    over NW.js. Electron's `autoUpdater` module ([http://bit.ly/1KKdNQs](http://bit.ly/1KKdNQs))
    utilizes the Squirrel framework ([https://github.com/Squirrel](https://github.com/Squirrel)),
    which makes *silent* possible. It works nicely in conjunction with the existing
    solution for multiplatform release servers; in particular, one can run it with
    Nuts ([https://github.com/GitbookIO/nuts](https://github.com/GitbookIO/nuts))
    using GitHub as a backend. We can also quickly set up a fully-featured node server
    based on `electron-release-server` ([https://github.com/ArekSredzki/electron-release-server](https://github.com/ArekSredzki/electron-release-server)),
    which includes release management UI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Electron-updater doesn't support Linux. The project maintainers recommend using
    the distribution's package manager to update the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we will walk through a simplified autoupdate approach
    that doesn't require a real release server, but only requires access to static
    releases via HTTP.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by installing the package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we add to the manifest''s `build` field--publish property:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we state that our `dist` folder will be available publicly on `127.0.0.1:8080`,
    and we go on with the `generic` provider. Alternatively, the provider can be set
    to Bintray ([https://bintray.com/](https://bintray.com/)) or GitHub.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We modify our main process script to take advantage of the `electron-updater`
    API--`./app/main.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Basically, we subscribe for the `autoUpdater` events and report them to the
    renderer script using the `send` function. When `update-downloaded` is fired,
    we send the `update- downloaded` event to the renderer. The renderer on this event
    supposedly reports to the user about a newly downloaded version and asks whether
    it would be convenient to restart the application. When confirmed, the renderer
    sends the `restart` event. From the main process, we subscribe to it using `ipcMain`
    ([http://bit.ly/2pChUNg](http://bit.ly/2pChUNg)). So, when `reset` is fired, `autoUpdater`
    restarts the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `electron-debug` won''t be available after packaging, so we have
    to remove it from the main process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we make a few changes to the renderer script--`./app/index.html`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In HTML, we add the `<i>` element with ID `statusbar`, which will print out
    reports from the main process. In JavaScript, we subscribe for main process events
    using `ipcRenderer` ([http://bit.ly/2p9xuwt](http://bit.ly/2p9xuwt)). On the `info`
    event, we change the content of the `statusbar` element with the event payload
    string. When `update-downloaded` occurs, we call `confirm` for the user opinion
    about a suggested restart. If the result is positive, we send the `restart` event
    to the main process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, we edit CSS to stick our `statusbar` element in the left-bottom
    corner of the viewport--`./app/assets/css/custom.css`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Everything is done; let''s rock it! So, we first rebuild the project and release
    it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We make the release available through HTTP using `http-server` ([https://www.npmjs.com/package/http-
    server](https://www.npmjs.com/package/http-server)):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We run the release to install the application. The application starts up as
    usual because no new releases are available yet, so we release a new version:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the footer component, we display the application name and version taken by
    the `require` function from the manifest. Webpack retrieves it at compilation
    time. So, if `package.json` is modified after the application is built, the changes
    do not reflect in the footer; we need to rebuild the project.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can take the name and version dynamically from the `app` ([http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj))
    object of Electron and forward it as an IPC event to the renderer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will start our previously installed release and this time, we will
    observe the `autoUpdater` reports in `statusbar`. As the new release is downloaded,
    we will get the following confirmation window:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ce30fe9-45d9-4623-af41-99a6370b9375.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'After pressing OK, the application closes and a new window showing the installation
    process pops up:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbe45246-db00-4d92-8ee3-756fbec9299e.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'When it''s done, start the updated application. Note that the footer now contains
    the latest released version:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72b231a9-33c3-439a-aed8-13eee7da86c7.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've completed our chat application. We started this chapter by programming
    the actions of the title bar. On the way, we learned how to control application
    window state in Electron. We looked into the WebSockets technology on the example
    of simple echo server and the accompanying client. Going deeper, we designed chat
    services based on WebSockets. We bound client events to the component states.
    We were introduced to the Jest testing framework and examined a generic approach
    to unit-testing React components. Besides, we created regression tests for both
    stateless and stateful components. We packaged our application and built an installer.
    We fiddled with publishing releases and made the application update whenever a
    new release is available.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的聊天应用程序。我们从编程标题栏的操作开始了本章。在这个过程中，我们学会了如何在Electron中控制应用程序窗口状态。我们通过简单的回声服务器和相应的客户端示例来了解了WebSockets技术。更深入地，我们设计了基于WebSockets的聊天服务。我们将客户端事件绑定到组件状态。我们介绍了Jest测试框架，并研究了对React组件进行单元测试的通用方法。此外，我们为无状态和有状态组件创建了回归测试。我们打包了我们的应用程序并构建了安装程序。我们对发布版本进行了调整，并使应用程序在有新版本可用时进行更新。
