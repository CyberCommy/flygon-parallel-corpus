- en: Creating a Chat System with Electron and React – Enhancement, Testing, and Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We finished the last chapter with a static prototype. We learned about React,
    composed the components, but didn't provide them with any state. Now, we will
    start binding the state of the application window to the Header component. As
    the state concept clarified, we will move to the chat services. After getting
    a brief introduction to the WebSockets technology, we will implement both the
    server and client. We will bind the service events to the application state. Finally,
    we will have a fully working chat. We won't stop on it, but will take care of
    the technical debt. So, we will set up the Jest testing framework and unit-test
    both the stateless and stateful components. Afterward, we will package the application
    and publish releases though a basic HTTP server. We will extend the application
    to update when new releases are available.
  prefs: []
  type: TYPE_NORMAL
- en: Revitalizing the title bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, our title bar was not really useful. Thanks to the Photon framework,
    we can already use it as a handle to drag and drop the window across the viewport,
    yet we are missing windowing actions such as close, maximize, and restore window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./app/js/Components/Header.jsx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We do not go with methods, with properties keeping anonymous functions bound
    to the object scope. This trick is possible, thanks to `babel-plugin-transform-class-properties`,
    which we included in the manifest and Webpack configuration in [Chapter 3](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml),
    *Creating a Chat System with Electron and React – Planning, Design, and Development*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We extended the component with handlers to close the window, to maximize, and
    then to restore to its original size. We already have a `close` button in JSX,
    so we just need to subscribe to the corresponding handler method for the `click`
    event using the `onClick` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `maximize` and `restore` buttons, though, are rendered in HTML conditionally,
    depending on the current window state. Since we will utilize the state, let''s
    define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isMaximized` state property takes in the corresponding flag from the current
    window instance. Now, we can extract this value from the state in JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, we render the `restore` button when it is true and `maximize` otherwise.
    We also subscribe the handlers for the `click` events on both the buttons, but
    what about changing the state after the window maximizes or restores?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can subscribe to the corresponding window events straight before the component
    is rendered to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the window changes its state handler, `updateState` invokes and actualizes
    the component state.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a static prototype, and now we will make it functional. Any chat requires
    communication between connected clients. Usually, clients do not connect directly
    but through a server. The server registers connections and forwards the messages.
    It's pretty clear how to send a message from the client to server, but can we
    do it in the opposite direction? In the olden days, we had to deal with long-polling
    techniques. That worked, but with the overhead of HTTP, it is not really suitable
    when we mean a low latency application. Luckily for us, Electron supports WebSockets.
    With that API, we can open a full-duplex, bi-directional TCP connection between
    the client and server. WebSockets provides higher speed and efficiency as compared
    to HTTP. The technology brings reduction of upto 500:1 in unnecessary HTTP traffic
    and 3:1 in latency ([http://bit.ly/2ptVzlk](http://bit.ly/2ptVzlk)). You can find
    out more about WebSockets in my book *JavaScript Unlocked* ([https://www.packtpub.com/web-development/javascript-unlocked](https://www.packtpub.com/web-development/javascript-unlocked)).
    Here, we will get acquainted with the technology briefly, with the help of a small
    demo. I suggest examining an echo server and a client. Whenever a client sends
    a text to the server, the server broadcasts it on all the connected clients. So,
    on every page with the client loaded, we receive the message in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we won''t write a protocol implementation for the server, but go
    with an existing NPM package--nodejs-websocket ([https://www.npmjs.com/package/nodejs-
    websocket](https://www.npmjs.com/package/nodejs-websocket)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the package API, we can quickly make our code to serve incoming messages
    from the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./server.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instantiate an object representing the WebSockets server (`server`).
    Within the callback of the `createServer` factory, we will receive connection
    objects. We subscribe to every connection for the `"text"` and `"error"` events.
    The first one happens when a data frame is sent from the client to the server.
    We simply forward it to every available connection. The second event is fired
    when something goes wrong, so we report the error. Finally, we start the server
    in the given port and host, for example, I set port `8001`. If this port is taken
    in your environment by any other program, just change the value of the `PORT`
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compose the client of this simplified chat as a single page application.
    So create the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./index.html`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the HTML, we placed a form with input control and output container. The intent
    is to send input value on form, submit it to the server, and display the server
    response in the output element.
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript, we store a reference to the acting nodes and create an instance
    of the WebSockets client. We subscribe for the `error`, `open`, and `message`
    client events. The first two basically report on what is happening. The last one
    receives events from the server. In our case, the server sends text messages,
    so we can take them as `e.data`. We also need to handle the input from the client.
    Therefore, we subscribe for `submit` on the form element. We use the `send` method
    of the WebSockets client to dispatch the input value to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the example, we can use the `http-server` module ([https://www.npmjs.com/package/http-server](https://www.npmjs.com/package/http-server))
    to launch a static HTTP server for our `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the following commands to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can run the server as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and then the client as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b2410346-8edf-4dc5-bb31-5b3cc5f06751.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing chat services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I believe that it''s more or less clear how WebSockets works now, and we can
    apply the API for our chat. However, in a real application, we need something
    more than to echo sent texts. Let''s put the intended event scenarios on paper:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Welcome` component handles user input and sends via the client to the `join`
    server event with the entered user name in the payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server receives the `join` event, adds a new user to the set, and broadcasts
    the `participants` event with the updated set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client receives the `participants` event and passes the set to the `Participants`
    component, which updates the participant's list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Conversation` component handles user input and sends the entered message
    via the client to the server as the `text` event with username, text, and timestamp
    in the payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server receives the `text` event and broadcasts it to all the chat participants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we deal with event messages, we need a unified format for sending and receiving
    a single source of truth. So, we implement a message wrapper--`./app/js/Service/Message.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This module exposes two static methods. One transforms the given event name
    and payload into a JSON string, which can be sent through WebSockets; another
    translates the received string into a message object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we write the server--`./app/js/Service/Server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The same as the echo server, this one subscribes to connection events to report
    what is going on and exposes the `broadcast` and `connect` methods. To make it
    handle incoming messages, we extend the `createServer` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when receiving a message, the server tries to call a handler method matching
    the event name. For example, when it receives `join` event, it calls `onjoin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The method accepts the event payload (the user name here) as the first parameter
    and the connection reference as the second. It registers the connection in `this.participant`
    map. So, we can now determine the associated user name and registration timestamp
    by a connection. The method then broadcasts the values of the map as an array
    (a set of usernames and timestamps).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we shall not forget to define `this.participants` as a map in the
    class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a handler method for the `text` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The method extracts the username associated with the given connection from the
    `this.participants`, extends the message payload with it, and broadcasts the derived
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can write the client--`./app/js/Service/Client.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The client implements the same trick with the handler methods as the server,
    but this time, we make the `connect` method return a Promise. Thus, we can adjust
    the execution flow if the client failed to connect the server. We have two handlers:
    `onparticipants` and `ontext`. Both of them simply bypass the received message
    to the application. Since the `Client` class extends `EventEmitter`, we can use
    `this.emit` to fire an event and any subscribed application module will be able
    to catch it. Besides, the client exposes two public methods: `join` and `message`.
    One (`join`) will be consumed by the `Welcome` component to register the provided
    username on the server, and the other (`message`) is called from the `Participants`
    component to communicate the submitted text to the server. Both the methods rely
    on the `send` private method, which actually dispatches messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron comprises of the Node.js runtime and therefore allows us to run the
    server. So, to make it simpler, we will include the server into the application.
    For that, we modify the server code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now it runs the supplied `client.connect` to establish a connection with our
    WebSockets server. If it's the very first instance of the application running,
    no server is yet available. Therefore, the client fails to connect and execution
    flow jumps into the catch callback. There, we start the server and reconnect the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing functionality to the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now when we have the server and client services, we can enable them in the
    application. The most suitable place is the `App` container--`./app/js/Containers/App.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you remember that we rendered either the `ChatPane` or `Welcome` component
    conditionally in the static prototype?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Back then, we hardcoded `name`, yet it belongs to the component state. So,
    we can initialize the state in the class constructor like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, `name` is empty by default and we, therefore, show the `Welcome` component.
    We can type in a new name there. As it''s submitted, we need to somehow change
    the state in the parent component. We achieve it with a technique known as **Lifting
    state up**. We declare a handler for the `name` change event in the `App` container
    and pass it to the `Welcome` component with the props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, we extract `name` from the state and use it in the expression. Initially,
    `name` is empty and therefore the `Welcome` component is rendered. We declare
    the `onNameChange` handler and pass it to the `Welcome` component with the props.
    The handler receives the submitted name, registers the new connection on the server
    (`this.client.join`), and changes the component state. So, the `ChatPane` component
    replaces `Welcome`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will edit the `Welcome` component--`./app/js/Components/Welcome.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a component expects any props, it usually means that we have to apply
    the `defaultProps` and `propTypes` static methods. These belong to the `React.Component`
    API and are automatically called during component initialization. The first one
    sets a default value for the props and the second validates them. In HTML, we
    subscribe to the `onSubmit` handler for the form `submit` event. In the handler,
    we need to access an input value. With the `ref` JSX attribute, we added the instance
    as a reference to the input element. So, from the `onSubmit` handler, we can obtain
    the input value as `this.nameEl.value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, now the user can register in the chat, and we need to show the chat UI--`./app/js/Components/ChatPane.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This one is a composite component that lays out the `Participants` and `Conversation`
    children components and forwards `client` to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is meant to display the list of participants--`./app/js/Components/Participants.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need some construction work. First, we define the state, which includes
    the participant list from the props. We also subscribe to the client `participants`
    event and update the state every time the server sends an updated list. When rendering
    the list, we also show participant registration time, such as joined 5 minutes
    ago. For that, we use a third-party component, `TimeAgo`, provided by the `react-timeago`
    NPM package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, we are coming to the `Conversation` component--`./app/js/Components/Conversation.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: During the construction, we subscribe to the client `text` event and collect
    the received messages in the `this.messages` array. We use these messages to set
    the component state. In the `render` method, we extract the message list from
    the state and traverse it to render every item. The message view includes the
    sender's name, text, and time. The name we output as it is. We split the text
    in lines and wrap them with the paragraph element. To display time, we use the
    `normalizeTime` static method. This method transforms the `Date` object into a
    long string (date and time) when it's older than today, and into a short string
    (date) otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a form for sending messages to the chat. The ideal method would
    be to put the form into a separate component, but for the sake of brevity, we
    will keep it next to the conversation view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty much as in the `Welcome` component, we make a local reference to the
    text area node and subscribe the `onSubmit` handler for the form `submit` event.
    To make it user-friendly, we set `onKeydown` to listen to a keyboard event on
    the text area. When *Enter* is pressed during typing, we submit the form. So,
    we have to now add new handlers to the component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When the form is submitted either by pressing the OK button or *Enter*, we pass
    the message to the server via the `message` method of the client and reset the
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'I don''t know about you, but I have the itch to run the application and see
    it in action. We have two options here. We can just start multiple instances from
    the same machine, register each one with a different name, and start chatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/389cf4cd-b808-434f-a669-4649c4fef2f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, we set a public IP in the `App` container to make the chat available
    across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit-tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In real life, we cover application functionality with unit-tests. When it comes
    to React, the Jest testing framework is the first to pop up in one''s mind. The
    framework is developed by Facebook as well as React. Jest is not aimed at React
    only; you can test any JavaScript. Just to see how it works, we can set up a new
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Jest by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `scripts` section in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Place the example unit for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./unit.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple pure function that double any given number. What we need to
    do now is to just place a JavaScript file of a name matching the `*.(spec|test).js`
    pattern--`./unit.spec.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you are familiar with Mocha or, better, Jasmine, you will have no problem
    reading this test suite. We describe an aspect (`describe()`), declare our expectations
    (`it()`), and assert that the result produced by the unit under test meets the
    requirements (`expect()`). Basically, the syntax doesn't differ from the one we
    used in [Chapter 2](013f4079-2a91-4776-a2bb-82e9ff5eb552.xhtml), *Creating a File
    Explorer with NW.js – Enhancement and Delivery*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running `npm test`, we get the following report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6bd66e6-b7d5-4c3e-a007-73158c9efea9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What makes Jest preferable in our case is that it''s really close to the React
    philosophy and incorporates specific features for testing a React application.
    For example, Jest comprises of the `toMatchSnapshot` assertion method. So, we
    can build a component in the virtual DOM, and make and save the snapshot of the
    element. Then, after refactoring, we run the tests. Jest takes actual snapshots
    of the modified components and compares them to the stored ones. That''s a common
    approach for regression tests. Before putting it into practice, we have to set
    up Jest for our environment. We specified our bundling configuration in `webpack.config.js`.
    Jest won''t consider this file. We have to compile the source for Jest separately,
    and we can do it with `babel-jest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin takes the code transformation instructions from the Babel runtime
    config--`./.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use preset env ([https://babeljs.io/docs/plugins/preset-env/](https://babeljs.io/docs/plugins/preset-env/)),
    which automatically determines and loads the plugins required by the target environment
    (Node.js 7). Do not forget to install the preset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We also apply the `transform-class-properties` and `transform-class-properties`
    plugins to get access to rest, spread, and ES Class Fields and Static Properties
    syntax, respectively (we have already used these plugins for Webpack configuration
    in [Chapter 3](e8e11085-df99-4abc-8bf2-974934a69cb8.xhtml), *Creating a Chat System
    with Electron and React – Planning, Design, and Development*).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in the `normalizeTime` test example, we will modify the manifest--`./package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This time, we also explicitly point Jest to our source directory, `app/js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I explained earlier, we will produce snapshots of React components for further
    assertions. That can be achieved with the `react-test-renderer` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write our first component regression test--`./app/js/Components/Footer.spec.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, it turned out that easy. We create an element with `renderer.create` and
    obtain static data representation by calling the `toJSON` method. When we first
    run the test (`npm test`), it creates the `__snapshots__` directory with the snapshot
    next to the test file. Every subsequent time, Jest compares the stored snapshots
    to the actual ones.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reset snapshots, just run ``npm test -- -u``.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing a stateful component is similar--`./app/js/Components/Participants.spec.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use the `getInstance` method of the created element to access the component
    instance. Thus, we can call the methods of the instance that set the concrete
    state. Here, we pass the fixture list of participants directly to the `onClientParticipants`
    handler. The component renders the list, and we make a snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regression tests are good to check whether the component wasn''t broken during
    refactoring, but they do not guarantee that the component behaved as intended
    in the first place. React provides an API via the `react-dom/test-utils` module
    ([https://facebook.github.io/react/docs/test-utils.html](https://facebook.github.io/react/docs/test-utils.html)),
    which we can use to assert that the component really renders everything we expect
    from it. With third-party package enzyme, we can do even more ([http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)).
    To get an idea about it, we add a test in the `Footer` suite--`./app/js/Components/Footer.spec.jsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we assume that the component renders an HTML footer element (`tree.find(
    "footer" )`). We also check whether the footer contains the project name from
    the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e9f94f-9b0f-42e5-8b81-ec9c543ff535.png)'
  prefs: []
  type: TYPE_IMG
- en: Packaging and distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we worked with File Explorer and NW.js, we used the `nwjs-builder` tool
    for packaging our application. The Electron has an even more sophisticated tool--electron-builder
    ([https://github.com/electron-userland/electron-builder](https://github.com/electron-userland/electron-builder)).
    Actually, it builds an application installer. The range of target package formats
    electron-builder supports is impressive. Then, why not try packaging our application?
    First, we install the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a new script to the manifest--`./package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set an arbitrary ID for the application in field build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We definitely want to provide the application with an icon, so we create the
    `build` subdirectory and place their `icon.icns` for macOS, `icon.ico` for Windows
    there. Icons for Linux will be extracted from `icon.icns`. Alternatively, you
    can place icons in `build/icons/` named after their sizes--`64x64.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we have not yet granted our application window with an icon. To fix
    it, we modify our main process script--`./app/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything seems ready, so we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As the process completes, we can find the generated package in the default
    format in the newly created `dist` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu: `chat-1.0.0-x86_64.AppImage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` Windows: `chat Setup 1.0.0.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` MacOS: `chat-1.0.0.dmg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, we can aim for a specific target format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the diverse package format may require additional metadata in the
    manifest ([https://github.com/electron-userland/electron-builder/wiki/Options](https://github.com/electron-userland/electron-builder/wiki/Options)).
    For instance, packaging in `.deb` requires both the `homepage` and `author` fields
    filled in.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Built-in capacities for auto updates is one of Electron's most prominent advantages
    over NW.js. Electron's `autoUpdater` module ([http://bit.ly/1KKdNQs](http://bit.ly/1KKdNQs))
    utilizes the Squirrel framework ([https://github.com/Squirrel](https://github.com/Squirrel)),
    which makes *silent* possible. It works nicely in conjunction with the existing
    solution for multiplatform release servers; in particular, one can run it with
    Nuts ([https://github.com/GitbookIO/nuts](https://github.com/GitbookIO/nuts))
    using GitHub as a backend. We can also quickly set up a fully-featured node server
    based on `electron-release-server` ([https://github.com/ArekSredzki/electron-release-server](https://github.com/ArekSredzki/electron-release-server)),
    which includes release management UI.
  prefs: []
  type: TYPE_NORMAL
- en: Electron-updater doesn't support Linux. The project maintainers recommend using
    the distribution's package manager to update the application.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, we will walk through a simplified autoupdate approach
    that doesn't require a real release server, but only requires access to static
    releases via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by installing the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add to the manifest''s `build` field--publish property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we state that our `dist` folder will be available publicly on `127.0.0.1:8080`,
    and we go on with the `generic` provider. Alternatively, the provider can be set
    to Bintray ([https://bintray.com/](https://bintray.com/)) or GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We modify our main process script to take advantage of the `electron-updater`
    API--`./app/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we subscribe for the `autoUpdater` events and report them to the
    renderer script using the `send` function. When `update-downloaded` is fired,
    we send the `update- downloaded` event to the renderer. The renderer on this event
    supposedly reports to the user about a newly downloaded version and asks whether
    it would be convenient to restart the application. When confirmed, the renderer
    sends the `restart` event. From the main process, we subscribe to it using `ipcMain`
    ([http://bit.ly/2pChUNg](http://bit.ly/2pChUNg)). So, when `reset` is fired, `autoUpdater`
    restarts the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `electron-debug` won''t be available after packaging, so we have
    to remove it from the main process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we make a few changes to the renderer script--`./app/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In HTML, we add the `<i>` element with ID `statusbar`, which will print out
    reports from the main process. In JavaScript, we subscribe for main process events
    using `ipcRenderer` ([http://bit.ly/2p9xuwt](http://bit.ly/2p9xuwt)). On the `info`
    event, we change the content of the `statusbar` element with the event payload
    string. When `update-downloaded` occurs, we call `confirm` for the user opinion
    about a suggested restart. If the result is positive, we send the `restart` event
    to the main process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, we edit CSS to stick our `statusbar` element in the left-bottom
    corner of the viewport--`./app/assets/css/custom.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is done; let''s rock it! So, we first rebuild the project and release
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We make the release available through HTTP using `http-server` ([https://www.npmjs.com/package/http-
    server](https://www.npmjs.com/package/http-server)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the release to install the application. The application starts up as
    usual because no new releases are available yet, so we release a new version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the footer component, we display the application name and version taken by
    the `require` function from the manifest. Webpack retrieves it at compilation
    time. So, if `package.json` is modified after the application is built, the changes
    do not reflect in the footer; we need to rebuild the project.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can take the name and version dynamically from the `app` ([http://bit.ly/2qDmdXj](http://bit.ly/2qDmdXj))
    object of Electron and forward it as an IPC event to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will start our previously installed release and this time, we will
    observe the `autoUpdater` reports in `statusbar`. As the new release is downloaded,
    we will get the following confirmation window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ce30fe9-45d9-4623-af41-99a6370b9375.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After pressing OK, the application closes and a new window showing the installation
    process pops up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbe45246-db00-4d92-8ee3-756fbec9299e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When it''s done, start the updated application. Note that the footer now contains
    the latest released version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72b231a9-33c3-439a-aed8-13eee7da86c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've completed our chat application. We started this chapter by programming
    the actions of the title bar. On the way, we learned how to control application
    window state in Electron. We looked into the WebSockets technology on the example
    of simple echo server and the accompanying client. Going deeper, we designed chat
    services based on WebSockets. We bound client events to the component states.
    We were introduced to the Jest testing framework and examined a generic approach
    to unit-testing React components. Besides, we created regression tests for both
    stateless and stateful components. We packaged our application and built an installer.
    We fiddled with publishing releases and made the application update whenever a
    new release is available.
  prefs: []
  type: TYPE_NORMAL
