- en: Java Language Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语言基础
- en: Now that you have a general idea about Java and its related terms and tools,
    we will start discussing Java as a programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对Java及其相关术语和工具有了一个大致的了解，我们将开始讨论Java作为一种编程语言。
- en: This chapter will introduce the basic concepts of Java as an **object-oriented
    programming** (**OOP**) language. You will learn about classes, interfaces, and
    objects, and their relations. You will also learn the concepts and features of
    OOP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Java作为**面向对象编程**（**OOP**）语言的基本概念。您将了解类、接口和对象及其关系。您还将学习OOP的概念和特性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basic terms in Java programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java编程的基本术语
- en: Classes and objects (instances)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象（实例）
- en: Class (static) and object (instance) members
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类（静态）和对象（实例）成员
- en: Interface, implementation, and inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口、实现和继承
- en: OOP concepts and features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOP的概念和特性
- en: Exercise – Interface versus abstract class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-接口与抽象类
- en: We call them basics because they are the founding principles of Java as a language,
    and there is more to learn before you can start programming professionally. For
    those who are learning Java for the first time, learning the basics of Java is
    a steep slope to climb, but the path becomes easier thereafter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称它们为基础，因为它们是Java作为一种语言的基本原则，而在您可以开始专业编程之前还有更多要学习。对于那些第一次学习Java的人来说，学习Java的基础是一个陡峭的斜坡，但之后的道路会变得更容易。
- en: The basic terms of Java programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java编程的基本术语
- en: The notion of Java programming basics has many interpretations. Some tutorials
    assume the basics to be the same for any object-oriented language. Others discuss
    syntax and basic language elements and grammar rules. Yet others reduce the basics
    to the value types, operators, statements, and expressions that allow computations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程基础的概念有很多解释。一些教程假设基础对于任何面向对象的语言都是相同的。其他人讨论语法和基本语言元素和语法规则。还有一些人将基础简化为允许计算的值类型、运算符、语句和表达式。
- en: Our view of Java basics consists of some elements from each of the earlier approaches.
    The only criteria for the selection we used were practicality and a gradual increase
    of complexity. We will start with simple definitions in this section, and then
    dive deeper into them in the subsequent sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Java基础的看法包括了前面各种方法的一些元素。我们选择的唯一标准是实用性和逐渐增加的复杂性。我们将从本节的简单定义开始，然后在后续章节中深入探讨。
- en: Byte code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节码
- en: In the broadest terms, a Java program (or any computer program for that matter)
    means a sequential set of instructions for a computer, that tell it what to do. Before
    executing on a computer, a program must be compiled from a human-readable, high-level
    programming language into a machine-readable binary code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最广泛的意义上，Java程序（或任何计算机程序）意味着一系列顺序指令，告诉计算机该做什么。在计算机上执行之前，程序必须从人类可读的高级编程语言编译成机器可读的二进制代码。
- en: In the case of Java, the human-readable text, called a source code, is stored
    in a `.java` file and can be compiled into byte code by the Java compiler `javac`.
    Java byte code is the instruction set for JVM. The byte code is stored in a `.class`
    file and can be interpreted and compiled into binary code by, JVM or, more specifically,
    by the **Just-In-Time** (**JIT**) compiler used by JVM. The binary code is then
    executed by a microprocessor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的情况下，人类可读的文本，称为源代码，存储在一个`.java`文件中，并可以通过Java编译器`javac`编译成字节码。Java字节码是JVM的指令集。字节码存储在一个`.class`文件中，并可以由JVM或更具体地说是由JVM使用的**即时**（**JIT**）编译器解释和编译成二进制代码。然后由微处理器执行二进制代码。
- en: An important feature of byte code is that it can be copied from one machine
    and executed on another machine's JVM. That is what Java portability means.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码的一个重要特点是它可以从一台机器复制到另一台机器的JVM上执行。这就是Java可移植性的含义。
- en: Defects (bugs) and their severity and priority
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺陷（bug）及其严重程度和优先级
- en: The word *bug*, with the meaning of *little faults and difficulties*, existed
    as early as the 19th century. The origin of this word is unknown, but it looks
    as if the verb *to bug* in a sense *to annoy* comes from that feeling of a pesky
    bothering coming from an insect—a bug—that buzzes around and threatens to bite
    you or something. The word was applied to programming defects as soon as a computer
    was first built.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*bug*这个词，意思是*小故障和困难*，早在19世纪就存在了。这个词的起源是未知的，但看起来好像动词*to bug*的意思是*打扰*，来自于一种讨厌的感觉，来自于一个嗡嗡作响并威胁要咬你或其他东西的昆虫-虫子。这个词在计算机第一次建造时就被用于编程缺陷。'
- en: The defects vary by their severity – the degree of the effect they have on the
    program execution, or its results. Some defects are quite insignificant, like
    a format, in which the data are presented for a human. It would be another matter
    if the same data have to be consumed by some other system that could not process
    data presented in such a format. Then such a defect may be qualified as critical,
    because it would not allow the system to complete the data processing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷的严重程度各不相同-它们对程序执行或结果的影响程度。一些缺陷是相当微不足道的，比如数据以人类可读的格式呈现。如果同样的数据必须由其他无法处理这种格式的系统消耗，那就另当别论了。那么这样的缺陷可能被归类为关键，因为它将不允许系统完成数据处理。
- en: The severity of a defect depends on how it affects the program, not on how difficult
    it is to fix it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷的严重程度取决于它对程序的影响，而不是修复它有多困难。
- en: Some defects may force the program to exit before it has achieved the desired
    result. For example, a defect may lead to the exhaustion of memory or another
    resource, and cause JVM to shut down.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缺陷可能会导致程序在达到期望结果之前退出。例如，一个缺陷可能导致内存或其他资源的耗尽，并导致JVM关闭。
- en: The defect priority, how high the defect is on the to-do list, generally corresponds
    to the severity. But some low severity defects may be prioritized higher because
    of a customer perception. For example, the grammar error on a website, or a typo
    that may be perceived as offensive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A defect's priority typically corresponds to its severity but sometimes, the
    priority may be increased based on customer perception.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Java program dependencies
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also mentioned that a program may require the use of other programs and procedures
    that are already compiled into bytecodes. For JVM to find them, you must list
    the corresponding `.class` files in the `java` command using the `-classpath` option.
    Several programs and procedures make up a Java application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The other programs and procedures used by the application for its tasks are
    called application dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Notice that JVM does not read a `.class` file until some other class code requests
    it. So, it well may be that some of the `.class` files listed on a classpath are
    never used if the conditions under which they are needed never happen during the
    application's execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A statement is a language construct that can be compiled into a set of instructions
    to a computer. The closest analogy from everyday life to a Java statement is a
    sentence in the English language, a basic unit of language that expresses a complete
    thought. Every statement in Java must end with a `;` (semi-colon).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a declaration statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: int i;
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The preceding statement declares a variable `i` of type `int` which stands for
    *integer* (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an expression statement:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: i + 2;
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding statement adds 2 to the value of the existing variable `i`. When
    declared, an `int` variable is assigned a value of 0 by default, so the result
    of this expression is `2`, but it is not stored. That is why it is often combined
    with declaration and assignment statements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: int j = i + 2;
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This tells the processor to create the variable `j` of type `int` and assign
    to it a value that is equal to the current value assigned to the variable `i` increased
    by `2`. In [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, we will discuss statements and expressions in more
    detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Java method is a group of statements that are always executed together with
    the purpose of producing a certain result in response to a certain input.  A method
    has a name, either a set of input parameters or no parameters at all, a body inside
    `{}` brackets, and a return type or `void` keyword that indicates that message
    does not return any value. Here is an example of a method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: int j = i * 2;
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: return j;
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, the method name is `multiplyByTwo`. It has one
    input parameter of type `int`. The method name and the list of parameter types
    are together called **method signature**.  The number of input parameters is called
    **arity**. Two methods have the same signature if they have the same name, the
    same arity, and the same sequence of types in the list of input parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a rewording of the definition of a method signature taken from Java
    Specification, section *8.4.2 Method Signature*. On the other hand, in the same
    specification, one can encounter the phrases such as: *several methods with the
    same name and signature*, *method* `getNumberOfScales` *in class* `Tuna` *has
    a name, signature, and return type*, and similar. So, beware; even the specification''s
    authors sometimes do not include method name into the notion of the method signature,
    and don''t be confused if other programmers follow suit.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The same preceding method can be re-written in many styles and with the same
    result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Another style is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){ return i * 2; }
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i){ return i * 2; }
- en: '```'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Some programmers prefer the most compact style, to be able to see as much code
    as possible on the screen. But that could decrease another programmer's ability
    to understand the code, which could lead to programming defects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员更喜欢最紧凑的风格，以便能够在屏幕上看到尽可能多的代码。但这可能会降低另一个程序员理解代码的能力，这可能会导致编程缺陷。
- en: 'Another example is a method without input parameters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个没有输入参数的方法：
- en: '```java'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int giveMeFour(){ return 4; }
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: int giveMeFour(){ return 4; }
- en: '```'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is quite useless. In reality, a method without parameters would read data
    from a database, for example, or from another source. We showed this example just
    to demonstrate the syntax.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当无用的。实际上，没有参数的方法会从数据库中读取数据，例如，或者从其他来源读取数据。我们展示这个例子只是为了演示语法。
- en: 'Here is an example of code that does nothing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个什么都不做的代码示例：
- en: '```java'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void multiplyByTwo(){ }
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: void multiplyByTwo(){ }
- en: '```'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding method does nothing and returns nothing. The syntax requires indicating
    the absence of a return value using the keyword `void`. In reality, methods without
    return values are often used to record data to a database or to send something
    to a printer, to an email server, to another application (using web-services,
    for example), and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法什么也不做，也不返回任何东西。语法要求使用关键字`void`来指示没有返回值。实际上，没有返回值的方法通常用于将数据记录到数据库，或者发送数据到打印机、电子邮件服务器、另一个应用程序（例如使用Web服务），等等。
- en: 'And just for a complete overview, here is an example of a method with many
    parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这是一个具有许多参数的方法的示例：
- en: '```java'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String doSomething(int i, String s, double a){
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: String doSomething(int i, String s, double a){
- en: double result = Math.round(Math.sqrt(a)) * i;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: double result = Math.round(Math.sqrt(a)) * i;
- en: return s + Double.toString(result);
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 返回s + Double.toString(result);
- en: '}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The above method extracts a square root from the third parameter, multiplies
    it to the first parameter, converts the result into a string, and attaches (concatenates)
    the result to the second parameter. The types and methods from the class `Math` used
    will be covered in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*. These calculations do not make much sense and are
    provided just for illustration purposes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法从第三个参数中提取平方根，将其乘以第一个参数，将结果转换为字符串，并将结果附加（连接）到第二个参数。将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中介绍使用的`Math`类的类型和方法，*Java语言元素和类型*。这些计算并没有太多意义，仅供说明目的。
- en: Classes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'All methods in Java are declared inside of structures called **classes**. A
    class has a name and a body in brackets `{}`, where methods are declared:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有方法都声明在称为**类**的结构内。一个类有一个名称和一个用大括号`{}`括起来的主体，在其中声明方法：
- en: '```java'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class MyClass {
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我的类 {
- en: int multiplyByTwo(int i){ return i * 2; }
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: int multiplyByTwo(int i){ return i * 2; }
- en: int giveMeFour(){ return 4;}
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: int giveMeFour(){ return 4;}
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Classes also have fields, often called properties; we will talk about them in
    the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类也有字段，通常称为属性；我们将在下一节讨论它们。
- en: The Main class and the main method
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主类和主方法
- en: 'One class serves as an entry to a Java application. It has to be specified
    in the `java` command while launching the application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类作为Java应用程序的入口。在启动应用程序时，必须在`java`命令中指定它：
- en: '```java'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -cp <location of all .class files> MyGreatApplication
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: java -cp <所有.class文件的位置> MyGreatApplication
- en: '```'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding command, `MyGreatApplication` is the name of the class that
    serves as the starting point of the application. When JVM finds the file `MyGreatApplication.class`,
    it reads it into the memory and looks in it for a method called `main()`. This
    method has a fixed signature:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，`MyGreatApplication`是作为应用程序起点的类的名称。当JVM找到文件`MyGreatApplication.class`时，它会将其读入内存，并在其中查找名为`main()`的方法。这个方法有一个固定的签名：
- en: '```java'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void main(String[] args) {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: // statements go here
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: // 在这里放语句
- en: '}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s break the preceding code snippet into pieces:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把前面的代码片段分成几部分：
- en: '`public` means that this method is accessible to any external program (see
    [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`表示这个方法对任何外部程序都是可访问的（参见[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)，*包和可访问性（可见性）*）'
- en: '`static` means that there is only one copy of the method exists in all the
    memory (see the following section)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`表示该方法在所有内存中只存在一个副本（参见下一节）'
- en: '`void` means it returns nothing'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`表示它不返回任何东西'
- en: '`main` is the method name'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`是方法名'
- en: '`String[] args` means it accepts an array of String values as an input parameter
    (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String[] args`表示它接受一个String值的数组作为输入参数（参见[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)，*Java语言元素和类型*）'
- en: '`//` means it is a comment, ignored by JVM and placed here only for humans
    (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`表示这是一个注释，JVM会忽略它，这里只是为了人类（参见[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)，*Java语言元素和类型*）'
- en: The preceding `main()` method does nothing. If run, it will execute successfully
    but produce no result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`main()`方法什么也不做。如果运行，它将成功执行但不会产生结果。
- en: 'You may also see the input parameters written as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到输入参数写成如下形式：
- en: '```java'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static void main(String... args) {
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String... args) {
- en: //body that does something
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: //执行一些操作的主体
- en: '}'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It looks like a different signature, but in fact, it is the same. Since JDK
    5, Java has allowed the *last parameter* of the method signature to be declared
    as a sequence of parameters of the same type of the variable arity. This is called
    **varargs**. Inside the method, one can treat the last input parameter as an array
    `String[]`, whether it was declared as an array explicitly or as a varargs. You will
    be fine if you never use varargs in your life. We are telling you about it just
    so you can avoid confusion while reading other peoples' code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像是不同的签名，但实际上是相同的。自JDK 5以来，Java允许将方法签名的*最后一个参数*声明为相同类型的变量可变性的一系列参数。这被称为**varargs**。在方法内部，可以将最后一个输入参数视为数组`String[]`，无论它是显式声明为数组还是作为可变参数。如果你一生中从未使用过varargs，那么你会没问题。我们告诉你这些只是为了让你在阅读其他人的代码时避免混淆。
- en: 'One last, important feature of the `main()` method is the source of its input
    parameter. There is no other code that calls it. It is called by JVM itself. So,
    where do the parameters come from? One could guess that the command line is the
    source of the parameter values. In the `java` command, so far, we assumed that
    no parameters were passed to the main class. But if the main method expects some
    parameters, we can construct the command line as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`main（）`方法的最后一个重要特性是其输入参数的来源。没有其他代码调用它。它是由JVM本身调用的。那么参数是从哪里来的呢？人们可能会猜想命令行是参数值的来源。在`java`命令中，到目前为止，我们假设没有参数传递给主类。但是如果主方法期望一些参数，我们可以构造命令行如下：'
- en: '```java'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: java -cp <location of all .class files> MyGreatApplication 1 2
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: java -cp <所有.class文件的位置> MyGreatApplication 1 2
- en: '```'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This means that inside the `main()` method, the value of the first element of
    the input array `args[0]` will be `1`, while the value of the second element of
    the input array `args[1]` will be `2`. Yes, you noticed it right, the count of
    the elements in an array starts with `0`. We will discuss this further in [Chapter
    5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements and Types*. The
    result will be the same whether the `main()` method signature is described using
    an array `String[] args` explicitly or by using varargs `String... args`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在`main（）`方法中，输入数组`args [0]`的第一个元素的值将是`1`，而输入数组`args [1]`的第二个元素的值将是`2`。是的，你注意到了，数组中元素的计数从`0`开始。我们将在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中进一步讨论这个问题，*Java语言元素和类型*。无论是显式地使用数组`String[]
    args`描述`main（）`方法签名，还是使用可变参数`String... args`，结果都是一样的。
- en: The code in the `main()` method then calls methods in the same main `.class`
    file or in the other `.class` files listed with the `-classpath` option. In the
    following section, we will see how such calls can be done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`main（）`方法中的代码调用同一main`.class`文件中的方法或使用`-classpath`选项列出的其他`.class`文件中的方法。在接下来的部分中，我们将看到如何进行这样的调用。
- en: Classes and objects (instances)
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象（实例）
- en: A class is used as the template for creating objects. When an object is created,
    all fields and methods declared in the class are copied into an object. The combination
    of field values in an object is called **object state**. The methods provide object
    behavior.  An object is also called an instance of a class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 类用作创建对象的模板。创建对象时，类中声明的所有字段和方法都被复制到对象中。对象中字段值的组合称为**对象状态**。方法提供对象行为。对象也称为类的实例。
- en: Each object is created by using the operator `new` and a constructor that looks
    like a special kind of method. The primary duty of a constructor is to set an
    initial object state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都是使用运算符`new`和看起来像一种特殊类型的方法的构造函数创建的。构造函数的主要职责是设置初始对象状态。
- en: Let's us now have a closer look at Java classes and objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看一看Java类和对象。
- en: Java classes
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java类
- en: Java classes are stored in `.java` files. Each `.java` file may contain several
    classes. They are compiled by the Java compiler `javac` and stored in `.class` files.
    Each `.class` file contains one compiled class only.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java类存储在`.java`文件中。每个`.java`文件可以包含多个类。它们由Java编译器`javac`编译并存储在`.class`文件中。每个`.class`文件只包含一个已编译的类。
- en: Each `.java` file contains only one `public` class. The keyword `public` in
    front of the class name makes it accessible from the classes in other files. The
    filename must match the public class name. The file can contain other classes
    too, they are compiled into their own `.class` file, but they can be accessed
    only by the public class that gave its name to the `.java` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`.java`文件只包含一个`public`类。类名前的关键字`public`使其可以从其他文件中的类访问。文件名必须与公共类名匹配。文件还可以包含其他类，它们被编译成自己的`.class`文件，但只能被给出其名称的公共类访问`.java`文件。
- en: 'This is what the content of the file `MyClass.java` might look like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是文件`MyClass.java`的内容可能看起来像的样子：
- en: '```java'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public String method1(int i){
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1（int i）{
- en: //statements, including return statement
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private void method2(String s){
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 私有void方法2（字符串s）{
- en: //statements without return statement
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: //没有返回语句的语句
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It has two fields. The keyword `private` makes them accessible only from inside
    the class, from its method. The preceding class has two methods – one public and
    one private. The public method is accessible by any other class, while the private
    method is accessible only from other methods of the same class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个字段。关键字`private`使它们只能从类内部，从它的方法中访问。前面的类有两个方法 - 一个是公共的，一个是私有的。公共方法可以被任何其他类访问，而私有方法只能从同一类的其他方法中访问。
- en: 'This class seems to not have a constructor. So, how are the states of the objects
    based on this class going to be initialized? The answer is that, in fact, each
    class that does not define its constructor explicitly but gets a default one—without
    parameters. And here are two examples of constructors added explicitly—one without
    parameters, another with a parameter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类似乎没有构造函数。那么，基于这个类的对象的状态将如何初始化？答案是，事实上，每个没有显式定义构造函数但获得一个默认构造函数的类。这里有两个显式添加的构造函数的例子，一个没有参数，另一个有参数：
- en: '```java'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class SomeClass {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: public class SomeClass {
- en: private int field1;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: public MyClass(){
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(){
- en: this.field1 = 42;
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = 42;
- en: '}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other content of the class - methods
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: //... 类的其他内容 - 方法
- en: //    that define object behavior
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: //    定义对象行为
- en: '}'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class MyClass {
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... methods here
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: //... 方法在这里
- en: '}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding code snippet, the keyword `this` indicates the current object.
    Its usage is optional. We could write `field1 = val1;` and achieve the same result.
    But it is a good practice to use the keyword `this` to avoid confusion, especially
    when (and programmers often do this) the name of the parameter is the same as
    the name of the field, such as in the following constructor:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，关键字`this`表示当前对象。它的使用是可选的。我们可以写`field1 = val1;`并获得相同的结果。但是最好使用关键字`this`来避免混淆，特别是当（程序员经常这样做）参数的名称与字段的名称相同时，比如在下面的构造函数中：
- en: '```java'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public MyClass(int field1, String field1){
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int field1, String field1){
- en: field1 = field1;
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: field1 = field1;
- en: field2 = field2;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: field2 = field2;
- en: '}'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Adding the keyword `this` makes the code more friendly to human eyes. And sometimes,
    this is needed. We will discuss such cases in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 添加关键字`this`使代码更友好。有时候，这是必要的。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中讨论这样的情况，*接口、类和对象构造*。
- en: 'A constructor can also call the methods of this or any other accessible class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个构造函数也可以调用这个类或任何其他可访问类的方法：
- en: '```java'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: method1(33);
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: method1(33);
- en: method2(val2);
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: method2(val2);
- en: '}'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method1(int i){
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1(int i){
- en: //statements, including return statement
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private void method2(String s){
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: private void method2(String s){
- en: //statements without return statement
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: //没有返回语句的语句
- en: '}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If a class does not define a constructor explicitly, it gets a default constructor
    from the default base class `java.lang.Object`. We will explain what it means
    in the upcoming *Inheritance* section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类没有显式定义构造函数，它会从默认的基类`java.lang.Object`中获得一个默认构造函数。我们将在即将到来的*继承*部分解释这意味着什么。
- en: 'A class can have several constructors with different signatures that can be
    used to create objects with different states if an application logic requires
    it. Once an explicit constructor with parameters is added to a class, the default
    constructor is not accessible unless it is added explicitly too. To clarify, this
    class has only one—default—constructor:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有多个不同签名的构造函数，用于根据应用程序逻辑创建具有不同状态的对象。一旦在类中添加了带参数的显式构造函数，除非也显式添加默认构造函数，否则默认构造函数将不可访问。澄清一下，这个类只有一个默认构造函数：
- en: '```java'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: //... other methods here
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And this class has only one constructor too, but does not have a default one:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也只有一个构造函数，但没有默认构造函数：
- en: '```java'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods here
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This class has two constructors—with and without parameters:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个构造函数，一个有参数，一个没有参数：
- en: '```java'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(){ }
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(){ }
- en: public MyClass(int val1, String val2){
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods here
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding constructor without parameters does nothing. It is provided only
    for the convenience of the client code that needs to create an object of this
    class but does not care about the particular initial state of the object. In such
    cases, JVM creates the default initial object state. We will explain what the
    default state is in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的前面构造函数什么也不做。它只是为了方便客户端代码创建这个类的对象，但不关心对象的特定初始状态。在这种情况下，JVM创建默认的初始对象状态。我们将在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中解释默认状态，*接口、类和对象构造*。
- en: Each object of the same class, created by any constructor, has the same methods
    (same behavior) even if its state (values assigned to the fields) is different.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个类的每个对象，由任何构造函数创建，都有相同的方法（相同的行为），即使它的状态（分配给字段的值）是不同的。
- en: This information about Java classes is enough for a beginner. Nevertheless,
    we would like to also describe some other classes that can be included in the
    same `.java` file, so that you will recognize them in other people's code. These
    other classes are called **nested classes**. They can be accessed only from the
    classes in the same file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于Java类的信息对于初学者来说已经足够了。尽管如此，我们还想描述一些其他类，这些类可以包含在同一个`.java`文件中，这样你就可以在其他人的代码中识别它们。这些其他类被称为**嵌套类**。它们只能从同一个文件中的类中访问。
- en: 'The class we have previously described – the only one public class in the `.java`
    file – is also called a top-level class. It can include a nested class called
    an inner class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前描述的类-`.java`文件中唯一的一个公共类-也被称为顶级类。它可以包括一个称为内部类的嵌套类：
- en: '```java'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass { // top-level class
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass { //顶级类
- en: class MyOtherClass { // inner class
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: class MyOtherClass { //内部类
- en: //inner class content here
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: //内部类内容在这里
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A top-level class can also include a static (more about static members in the
    next section) nested class. A `static` class is not called an inner class, just
    a nested class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级类还可以包括一个静态（关于静态成员的更多信息请参见下一节）嵌套类。`static`类不被称为内部类，只是一个嵌套类：
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass { // top-level class
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass { //顶级类
- en: static class MyYetAnotherClass { // nested class
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: static class MyYetAnotherClass { //嵌套类
- en: // nested class content here
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: //嵌套类内容在这里
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Any method can include a class that can be accessed only within the method.
    It is called a local class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以包括一个只能在该方法内部访问的类。它被称为本地类：
- en: '```java'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass { // top-level class
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass { //顶级类
- en: void someMethod() {
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod（）{
- en: class MyInaccessibleAnywhereElseClass { // local class
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: class MyInaccessibleAnywhereElseClass { //本地类
- en: // local class content here
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: //本地类内容在这里
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: A local class is not very often used, but not because it is useless. Programmers
    just do not remember how to create a class that is needed inside one method only
    and create an external or inner class instead.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类并不经常使用，但并不是因为它没有用。程序员只是不记得如何创建一个只在一个方法内部需要的类，而是创建一个外部或内部类。
- en: 'The last but not the least kind of a class that can be included in the same
    file as a public class is called an anonymous class. It is a class without a name
    that allows the creation of an object in-place that can override the existing
    method or implement an interface. Let''s us assume that we have the following
    interface, `InterfaceA`, and the class `MyClass`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的一种可以包含在与公共类相同文件中的类是匿名类。它是一个没有名称的类，允许在原地创建一个对象，可以覆盖现有方法或实现一个接口。让我们假设我们有以下接口，`InterfaceA`，和类`MyClass`：
- en: '```java'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public interface InterfaceA{
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: public interface InterfaceA {
- en: void doSomething();
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: void doSomething（）;
- en: '}'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public class MyClass {
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: void someMethod1() {
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod1（）{
- en: System.out.println("1\. Regular is called");
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("1.常规被称为");
- en: '}'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void someMethod2(InterfaceA interfaceA) {
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod2（InterfaceA interfaceA）{
- en: interfaceA.doSomething();
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: interfaceA.doSomething（）;
- en: '}'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can execute the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行以下代码：
- en: '```java'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: MyClass myClass = new MyClass();
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass myClass = new MyClass（）;
- en: myClass.someMethod1();
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: myClass.someMethod1（）;
- en: myClass = new MyClass() {     //Anonymous class extends class MyClass
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: myClass = new MyClass（）{ //匿名类扩展类MyClass
- en: public void someMethod1(){              // and overrides someMethod1()
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: public void someMethod1（）{ //并覆盖someMethod1（）
- en: System.out.println("2\. Anonymous is called");
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("2.匿名被称为");
- en: '}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: myClass.someMethod1();
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我的类。someMethod1（）;
- en: myClass.someMethod2(new InterfaceA() { //Anonymous class implements
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: myClass.someMethod2（new InterfaceA（）{ //匿名类实现
- en: public void doSomething(){     //  InterfaceA
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: public void doSomething（）{ // InterfaceA
- en: System.out.println("3\. Anonymous is called");
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("3.匿名被称为");
- en: '}'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '```'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result is going to be:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是：
- en: '```java'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 1\. Regular is called
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 1.常规被称为
- en: 2\. Anonymous is called
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 2.匿名被称为
- en: 3\. Anonymous is called
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 3.匿名被称为
- en: '```'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We do not expect the reader to understand the preceding code in full detail
    yet. We hope that the reader will be able to do it after reading this book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望读者完全理解前面的代码。我们希望读者在阅读本书后能够做到这一点。
- en: This was a long section, with a lot of information. Most of it is just for reference,
    so do not feel bad if you do not remember everything. Just revisit this section
    after you have finished the book and acquired some practical experience with Java
    programming.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的部分，包含了很多信息。其中大部分只是供参考，所以如果你记不住所有内容，不要感到难过。在完成本书并获得一些Java编程的实际经验后，再回顾这一部分。
- en: A few more introductory sections follow. Then [Chapter 3](18c6e8b8-9d8a-4ece-9a3f-cd00474b713e.xhtml),
    *Your Development Environment Setup,* will lead you through the configuration
    of the development tools on your computer, and in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, you will start writing code and execute it - the moment every
    software developer remembers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来还有几个介绍性部分。然后[第3章]（18c6e8b8-9d8a-4ece-9a3f-cd00474b713e.xhtml），*您的开发环境设置*，将引导您配置计算机上的开发工具，并且在[第4章]（64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml），*您的第一个Java项目*，您将开始编写代码并执行它-每个软件开发人员都记得的时刻。
- en: A few more steps, and you can call yourself a Java programmer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 再走几步，你就可以称自己为Java程序员了。
- en: Java object (class instance)
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java对象（类实例）
- en: One often reads—and Oracle documentation is not an exception—that an object
    is *used to model the real-world objects*. Such a view originates from before
    the days of object-oriented programming. At that time programs had a common or
    global area to store intermediate results. If not carefully managed, different
    subroutines and procedures—that's what methods were called then—modified those
    values, stepping on each other's toes and making it very difficult to trace defects.
    Naturally, programmers tried to regulate the access to the data and to make the
    intermediate results accessible only to certain methods. A bundle of methods and
    the data only they can access started to be known as an object.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常阅读-甚至Oracle文档也不例外-对象被*用于模拟现实世界的对象*。这种观点起源于面向对象编程之前的时代。那时，程序有一个用于存储中间结果的公共或全局区域。如果不小心管理，不同的子例程和过程-那时称为方法-修改这些值，互相干扰，使得很难追踪缺陷。自然地，程序员们试图规范对数据的访问，并且使中间结果只能被某些方法访问。一组方法和只有它们可以访问的数据开始被称为对象。
- en: Such constructs were also seen as models of the real-world objects. All the
    objects around us probably have some kind of an inner state, but we do not have
    access to it and know only how the objects behave. That is, we can predict how
    they will react to this or that input.  Creating private fields in a class (object)
    that can be accessed only from the methods of the same class (object) seemed to
    be the solution to the hidden object state. With that, the original idea of modeling
    the real-world objects was carried along.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造也被视为现实世界对象的模型。我们周围的所有对象可能都有某种内在状态，但我们无法访问它，只知道对象的行为。也就是说，我们可以预测它们对这个或那个输入会有什么反应。在类（对象）中创建只能从同一类（对象）的方法中访问的私有字段似乎是隐藏对象状态的解决方案。因此，模拟现实世界对象的原始想法得以延续。
- en: But after the years of object-oriented programming, many programmers realized
    that such a view can be misleading and actually quite harmful when one tries to
    apply it consistently to all kinds of software objects. For example, an object
    can carry values used as the parameters of an algorithm that has nothing to do
    with any real-world object but has everything to do with a computational efficiency.
    Or, as another example, an object that brings back the results of a computation.
    Programmers often call it a **data transfer object** (**DTO**). It has nothing
    to do with a real-world object unless stretches the definition of a real-world
    object, but that would be, well, a stretch.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但是经过多年的面向对象编程，许多程序员意识到这样的观点可能会产生误导，并且在试图将其一贯应用于各种软件对象时实际上可能会产生相当大的危害。例如，一个对象可以携带用作算法参数的值，这与任何现实世界的对象无关，但与计算效率有关。或者，另一个例子，一个带回计算结果的对象。程序员通常称之为**数据传输对象**（**DTO**）。除非扩展现实世界对象的定义，否则它与现实世界对象无关，但那将是一个伸展。
- en: 'A software object is simply a data structure in computer memory where the actual
    values are stored. Is memory a real-world object? The physical memory cells are,
    but the information they carry does not represent the cells. It represents the
    values and methods of a software object. And this information about an object
    is not even stored in a continuous memory area: object state is stored in an area
    called heap, while methods are stored in the method area, which, depending on
    the JVM implementation, may or may not be part of the heap.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 软件对象只是计算机内存中的数据结构，实际值存储在其中。内存是一个现实世界的对象吗？物理内存单元是，但它们携带的信息并不代表这些单元。它代表软件对象的值和方法。关于对象的这些信息甚至不是存储在连续的内存区域中：对象状态存储在一个称为堆的区域中，而方法存储在方法区中，具体取决于JVM实现，可能或可能不是堆的一部分。
- en: An object, in our experience, is an integral part of the process of computation,
    which more often than not does not operate on models of real-world objects. An
    object is used to pass around values and methods, which are sometimes related
    and sometimes not. The set of methods and values might be grouped in one class
    for just a convenience or any other consideration.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的经验中，对象是计算过程的一个组成部分，通常不是在现实世界对象的模型上运行。对象用于传递值和方法，有时相关，有时不相关。方法和值的集合可能仅仅为了方便或其他考虑而被分组在一个类中。
- en: To be fair, sometimes the software objects do represent models of real-world
    objects. But the point is that it is not always the case. With that, let us not
    consider software objects as models of real-world objects, unless they really
    are. Instead, let us look at how the objects are created and used and how they
    can help us to build a useful functionality – an application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，有时软件对象确实代表现实世界对象的模型。但关键是这并不总是如此。因此，除非真的是这样，让我们不将软件对象视为现实世界对象的模型。相反，让我们看看对象是如何创建和使用的，以及它们如何帮助我们构建有用的功能
    - 应用程序。
- en: 'As we described in the previous section, an object is created based on a class,
    using the keyword `new` and a constructor – either the default or one that is
    declared explicitly. Consider, for example, the following class:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所描述的，对象是基于类创建的，使用关键字`new`和构造函数 - 要么是默认的，要么是显式声明的。例如，考虑以下类：
- en: '```java'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: private int field1;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: private int field1;
- en: private String field2;
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: private String field2;
- en: public MyClass(int val1, String val2){
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method1(int i){
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1(int i){
- en: //statements, including return statement
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods are here
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: //... 其他方法在这里
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we have this class, we can write the following in the method of some other
    class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这个类，我们可以在其他类的方法中写以下内容：
- en: '```java'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public AnotherClass {
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: public AnotherClass {
- en: '...'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: public void someMethod(){
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: public void someMethod(){
- en: MyClass myClass = new MyClass(3, "some string");
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass myClass = new MyClass(3, "some string");
- en: String result = myClass.method1(2);
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: String result = myClass.method1(2);
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, the statement `MyClass myClass = new MyClass(3, "some
    string");` creates an object of class `MyClass`, using its constructor and the
    keyword `new`, and assigns the reference of the newly created object to the variable
    `myClass`. We have chosen an identificator of the object reference that matches
    the name of the class with the first letter in a lower case. It is just a convention
    and we could have chosen another identificator (like `boo`, for example) with
    the same result. In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*, we discuss identificators and variables in more
    detail. As you can see in the next line in the preceding example, once a reference
    is created we can use it to access public members of the newly created object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，语句`MyClass myClass = new MyClass(3, "some string");`创建了一个`MyClass`类的对象，使用了它的构造函数和关键字`new`，并将新创建的对象的引用分配给变量`myClass`。我们选择了一个对象引用的标识符，它与类名匹配，第一个字母小写。这只是一个约定，我们也可以选择另一个标识符（比如`boo`），结果是一样的。在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们会更详细地讨论标识符和变量。正如你在前面的例子中看到的，在下一行中，一旦创建了一个引用，我们就可以使用它来访问新创建对象的公共成员。
- en: 'Any Java object is created only one way: by using the keyword (operator) `new` and a
    constructor. This process is also called **class instantiation**. The reference
    to the object can be passed around as any other value (as a variable, parameter,
    or returned value), and every code that has access to the reference can use it
    to access the public members of the object. We will explain what public members
    are in the following section.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Java对象都只能通过使用关键字（运算符）`new`和构造函数来创建。这个过程也被称为**类实例化**。对对象的引用可以像任何其他值一样传递（作为变量、参数或返回值），每个有权访问引用的代码都可以使用它来访问对象的公共成员。我们将在下一节中解释什么是**公共成员**。
- en: Class (static) and object (instance) members
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类（静态）和对象（实例）成员
- en: We have mentioned the term public members in relation to an object. We have
    also used the keyword `static` while talking about the `main()` method. We also
    stated that a member that is declared `static` can have only one copy in JVM memory.
    Now, we are going to define all that, and more.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了与对象相关的公共成员这个术语。在谈到`main()`方法时，我们还使用了关键字`static`。我们还声明了一个被声明为`static`的成员在JVM内存中只能有一个副本。现在，我们将定义所有这些，以及更多。
- en: Private and public
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有和公共
- en: The keywords `private` and `public` are called **access modifiers**. There are
    also default and `protected` access modifiers, but we will talk about them in
    [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*. They are called access modifiers because they regulate accessibility
    to (sometimes also called visibility of) classes, methods, and fields, from outside
    the class, and also because they modify the declaration of the corresponding class,
    method, or field.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`private`和`public`被称为**访问修饰符**。还有默认和`protected`访问修饰符，但我们将在[第7章](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml)中讨论它们，*包和可访问性（可见性）*。它们被称为访问修饰符，因为它们调节类、方法和字段的可访问性（有时也被称为可见性），并且它们修改相应的类、方法或字段的声明。
- en: A class can be private when it is a nested class only. In the preceding *Java
    class* section, we did not use an explicit access modifier for nested classes (thus,
    we used the default one), but we could have made them private if we would like
    to allow access to these classes only from the top-level class and siblings.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类只有在它是嵌套类时才能是私有的。在前面的*Java类*部分，我们没有为嵌套类使用显式访问修饰符（因此，我们使用了默认的），但如果我们希望只允许从顶级类和同级访问这些类，我们也可以将它们设为私有。
- en: A private method or private field can be accessed only from within the class
    (object) where it is declared.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法或私有字段只能从声明它的类（对象）中访问。
- en: By contrast, a public class, method, or field can be accessed from any other
    class. Notice that a method or field cannot be public if the enclosing class is
    private. Which makes sense, doesn't it? If the class itself is inaccessible publicly,
    how can its members be public?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，公共类、方法或字段可以从任何其他类中访问。请注意，如果封闭类是私有的，那么方法或字段就不能是公共的。这是有道理的，不是吗？如果类本身在公共上是不可访问的，那么它的成员如何能是公共的呢？
- en: Static members
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态成员
- en: A class can be declared static only when it is a nested class. Class members—methods
    and fields—can be static too, as long as the class is not anonymous or local.
    Any code can access a static member of a class without creating a class instance
    (object). We saw such an example in previous sections when we used the class `Math`
    in one of the code snippets. A static class member is also called a class variable
    in case of the field or a class method in case of a method. Notice that these
    names contain the word `class` as an adjective. That is because a static member
    is associated with a class, not a class instance. It means that there is only
    one copy of a static member that can exist in JVM memory, although many instances
    (objects) of the class can be created and reside there at any moment in time.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当类是嵌套类时，才能声明一个类为静态。类成员——方法和字段——也可以是静态的，只要类不是匿名的或本地的。任何代码都可以访问类的静态成员，而不需要创建类实例（对象）。在前面的章节中，我们在一个代码片段中使用了类`Math`，就是这样的一个例子。静态类成员在字段的情况下也被称为类变量，方法的情况下被称为类方法。请注意，这些名称包含`class`这个词作为形容词。这是因为静态成员与类相关联，而不是与类实例相关联。这意味着在JVM内存中只能存在一个静态成员的副本，尽管在任何时刻可以创建和驻留在那里的类的许多实例（对象）。
- en: 'Here is another example. Let''s assume we have the following class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子。假设我们有以下类：
- en: '```java'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class MyClass {
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类MyClass {
- en: private int field1;
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 私有int字段1;
- en: public static String field2;
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 公共静态字符串字段2;
- en: public MyClass(int val1, String val2){
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: public MyClass(int val1, String val2){
- en: this.field1 = val1;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: this.field1 = val1;
- en: this.field2 = val2;
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: this.field2 = val2;
- en: '}'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String method1(int i){
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: public String method1(int i){
- en: //statements, including return statement
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: //语句，包括返回语句
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void method2(){
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: public static void method2(){
- en: //statements
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: //语句
- en: '}'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //... other methods are here
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'From any method of any other class, the public static members of the preceding
    `MyClass` class can be accessed as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.field2 = "any string";
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: String s = MyClass.field2 + " and another string";
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The result of the preceding operations will be the assigning to the variable
    `s` of the value `any string and another string`. The `String` class will be discussed
    further in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, one can access a public static method `method2()` of the class `MyClass`
    as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.method2();
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'The other methods of the class `MyClass` can still be accessed via an instance
    (object):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: MyClass mc = new MyClass(3, "any string");
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: String someResult = mc.method1(42);
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there is no need to create an object of class `MyClass` if all its
    members are static.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, sometimes it is possible to access a static member using the
    object reference. The following code may work – it depends on the implementation
    of the `javac` compiler. If it works, it produces the same result as the preceding
    code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: MyClass mc = new MyClass(3, "any string");
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: mc.field2 = "Some other string";
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: mc.method2();
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers provide a warning saying something like *static member being
    accessed by instance reference*, but they still let you do it. Others produce
    the error *cannot make a static reference to the non-static method/field* and
    force you to correct your code. The Java specification does not regulate such
    a case. But it is not a good practice to access a static class member via a reference
    to an object because it makes the code ambiguous for a human reader. So, you are
    better off avoiding doing that even if your compiler is more forgiving.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Object (instance) members
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A non-static class member is also called an instance variable in case of the
    field or an instance method in case of a method. It can be accessed only via reference
    to the object followed by a dot "`.`" We have seen several such examples already.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'In line with the long-established tradition, the fields of an object are usually
    declared private. If necessary, the methods `set()` and/or `get()` are provided
    to access such private values. They are often called setters and getters as they
    set and get values of private fields. Here is an example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: public void setField1(String val){
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val;
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: public String getField1(){
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: return this.field1;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: public void setField2(String val){
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val;
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: public String getField2(){
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: return this.field2;
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods are here
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is necessary to make sure that the object state cannot be changed.
    To support such a case, programmers use a constructor to set the state and remove
    setters:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: public String getField1(){
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: return this.field1;
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: public String getField2(){
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: return this.field2;
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: //... other non-setting methods are here
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Such an object is called immutable.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two methods with the same name but different signatures represent method overloading.
    Here is an example:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i){
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: public int method(int i, String v){
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is not allowed and will cause a compilation error, because return
    values are not a part of the method signature and cannot be used to distinguish
    one method from another if they have the same signature:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i){
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: public int method(int i){ //error
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, this is allowed, because the methods have different signatures:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: public String method(String v, int i){
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i, String v){
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Interface, implementation, and inheritance
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are stepping into the most significant area of Java programming – the heavily
    used Java programming terms of interface, implementation, and inheritance.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday life, the word interface is quite popular. Its meaning is very close
    to the role Java interface plays in programming. It defines the public face of
    an object. It describes how it is possible to interact with the object and what
    can be expected of it. It hides inner class workings and exposes only method signatures
    with return values and access modifiers. An interface cannot be instantiated.
    An object of an interface type can be created only by creating an object of a
    class that implements this interface (interface implementation will be covered
    more thoroughly in the next section).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following class:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i){
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: public int method(int i, String v){
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Its interface is as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: public interface MyClassInterface {
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: String method(int i);
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: int method(int i, String v);
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: So, we could write `public class MyClass implements MyClassInterface {...}`.
    We will talk about it in the next section.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Since an interface is a *public* face, the method access modifier `public` is
    assumed by default and can be omitted.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: An interface does not describe how the object of the class can be created. To
    discover that, one must look at the class and see what the signatures of the constructors
    it has are. One can also check and see if public static class members are present
    that can be accessed without creating an object. So, an interface is only the
    public face of a class *instance*.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover the rest of interface capabilities. According to the Java Specification,
    *The body of an interface may declare members of the interface, that is, fields, methods,
    classes, and interfaces.* If you are confused and asking what the difference between
    an interface and a class is, you have a legitimate concern which we are going
    to address now.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Fields in the interface are implicitly public, static, and final. The modifier
    `final` means their values cannot be changed. By contrast, in a class, the implicit
    (default) access modifier of a class itself, its fields, methods, and constructors
    is package-private, which means it is visible only within its own package. Packages
    are named groups of related classes. You will learn about them in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml),
    *Packages and Accessibility (Visibility)*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: A method in the body of an interface may be declared default, static, or private.
    The purpose of the default method will be explained in the next section. A static
    method can be accessed from anywhere via the interface name and the dot "`.`".
    Private methods can be accessed only by other methods inside the same interface.
    By contrast, the default access modifier for the methods in classes is package-private.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: As for the classes declared inside an interface, they are implicitly static. They
    are also public and can be accessed without an instance of an interface, which
    is impossible to create anyway. We are not going to talk more about such classes
    because they are used in very particular areas that are beyond the scope of this
    book.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to a class, an interface allows the declaration of an inner or nested
    interface inside its body. It can be accessed from outside like any static member,
    using the top-level interface with the dot "`.`". We would like to remind you
    that an interface is public by default and cannot be instantiated, and thus is
    static by default.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: There is one last very important term related to interfaces. A method signature
    listed in the interface without an implementation is called an **abstract method** and
    the interface itself is called **abstraction** because it abstracts, summarizes,
    and removes the signatures from the implementation. An abstraction cannot be instantiated.
    As an example, if you put the keyword `abstract` in front of any class and try
    to create its object, the compiler will throw an error even if all the methods
    in the class are not abstract. In such a case, the class behaves as an interface
    with the default methods only. Yet, there is a significant difference in their
    usage, which you will see after reading the upcoming *Inheritance* section of
    this chapter.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about interfaces in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*, and cover their access modifiers in [Chapter
    7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility (Visibility)*.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interface can be implemented by a class, which means that the class has
    a body for each of the abstract methods listed in the interface. Here is an example:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: interface Car {
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: double getMaxSpeedInMilesPerHour();
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car{
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: return 100d;
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: We named the class `CarImpl` to indicate that it is an implementation of the
    interface `Car`. But we could name it any other way we like.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'Both interface and its class implementation can have other methods too without
    causing a compiler error. The only requirement for the extra method in the interface
    is that it has to be default and have a body. Adding any other method to a class
    does not interfere with the interface implementation.  For example:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: interface Car {
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: double getMaxSpeedInMilesPerHour();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: default int getPassengersCount(){
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car{
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: private int doors;
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: private double weight, speed;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: public CarImpl(double weight, double speed, int doors){
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: this.weight = weight;
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: this.speed = speed;
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: this.dooes = doors;
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: return this.weight;
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: return this.speed;
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumberOfDoors(){
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: return this.doors;
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now create an instance of a class `CarImpl`, we can call all the methods
    we have declared in the class:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: CarImpl car = new CarImpl(500d, 50d, 3);
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: car.getWeightInPounds();         //Will return 500.0
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: car.getMaxSpeedInMilesPerHour(); //Will return 50.0
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: car.getNumberOfDoors();          //Will return 3
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: That was not surprising.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'But, here is something you might not have expected:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();          //Will return 4
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that by implementing an interface class acquires all the default
    methods the interface has. That is the purpose of the default methods: to add
    functionality to all classes that implement the interface. Without it, if we add
    an abstract method to an old interface, all current interface implementations
    will trigger a compiler error. But, if we add a new method with the modifier default,
    the existing implementations will continue working as usual.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, another nice trick. If a class implements a method with the same signature
    as the default method, it will `override` (a technical term) the behavior of the
    interface. Here is an example:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: interface Car {
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: double getMaxSpeedInMilesPerHour();
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: default int getPassengersCount(){
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car{
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: private int doors;
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: private double weight, speed;
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: public CarImpl(double weight, double speed, int doors){
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: this.weight = weight;
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: this.speed = speed;
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: this.dooes = doors;
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: return this.weight;
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: return this.speed;
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumberOfDoors(){
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: return this.doors;
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: return 3;
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the interface and class described in this example, we can write the
    following code:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: CarImpl car = new CarImpl(500d, 50d, 3);
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();        //Will return 3 now !!!!
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: If not all of the abstract methods of the interface have been implemented the
    class must be declared abstract, and cannot be instantiated.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an interface is to represent its implementations – all objects
    of all the classes that have implemented it. For example, we could create another
    class that implements the `Car` interface:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: public class AnotherCarImpl implements Car{
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: return 2d;
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: return 3d;
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumberOfDoors(){
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: return 5;
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can let the `Car` interface represent each of them:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Car car = new CarImpl(500d, 50d, 3);
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: car.getWeightInPounds();          //Will return 500.0
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: car.getMaxSpeedInMilesPerHour();  //Will return 50.0
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: car.getNumberOfDoors();           //Will produce compiler error
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();         //Still returns 3 !!!!
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: car = new AnotherCarImpl();
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: car.getWeightInPounds();          //Will return 2.0
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: car.getMaxSpeedInMilesPerHour();  //Will return 3.0
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: car.getNumberOfDoors();           //Will produce compiler error
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();         //Will return 5
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Several interesting observations can be made from looking at the preceding code
    snippet. First, when the variable `car` is declared as an interface type (not
    a class type as in the previous example), one cannot call a method not declared
    in the interface.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Second, the `car.getPassengersCount()` method returns `3` the first time. One
    could have expected it to return `4`, because `car` was declared as an interface
    type and one could have expected the default method to work. But, in fact, the
    variable `car` refers the object of class `CarImpl`, and that is why the class
    implementation of the `car.getPassengersCount()` method is executed.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Working with an interface, you should remember that the signatures come from
    the interface, but the implementation comes from a class, or from a default interface
    method if the class does not implement it. Here shines another feature of default
    methods. They serve both as a signature that can be implemented and as an implementation
    if the class does not implement it.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: If there are several default methods in an interface, it is possible to create
    private methods accessible only by the default methods of the interface. They
    can be used to contain common functionality instead of repeating it in every default
    method. The private methods cannot be accessed from outside the interface.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can now reach the summit of Java basics complexity. After this,
    and all the way to the end of the book, we will only be adding some details and
    building up your programming skills. It will be a walk on a high altitude plateau
    - the longer you walk, the more comfortable you feel. But, to get to that height,
    we need to climb the last uphill pitch; inheritance.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can acquire (inherit) all the non-private non-static members, so that
    when we use the object of this class, we cannot have any idea where these members
    actually reside – in this class or in the class from which they were inherited.
    To indicate inheritance, the keyword `extends` is used. For example, consider
    the following classes:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: private void m1(){...}
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: public void m2(){...}
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: class B extends class A {
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: public void m3(){...}
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: class C extends class B {
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the objects of classes `B` and `C` behave as if each of them
    has methods `m2()` and `m3()`. The only limitation is that a class can extend
    one class only. Class `A` is a base (or parent) class for both class `B` and class
    `C`. Class `B` is a base class for class `C` only. And, as we have mentioned already,
    each of them has the default base class `java.lang.Object`. Classes `B` and `C`
    are subclasses of class `A`. Class `C` is also a subclass of class `B`.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, an interface can extend to many other interfaces at the same time.
    If `AI`, `BI`, `CI`, `DI`, `EI`, and `FI` are interfaces, then the following is
    allowed:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: interface AI extends BI, CI, DI {
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: //the interface body
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: interface DI extends EI, FI {
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: //the interface body
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the interface `AI` inherits all the non-private non-static
    signatures of the interfaces `BI`, `CI`, `DI`, `EI`, and `FI`, and any other interfaces
    that are base interfaces of the interfaces `BI`, `CI`, `DI`, `EI`, and `FI`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the topic of the previous section, *Implementation*, a class
    can implement many interfaces:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: class A extends B implements AI, BI, CI, DI {
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: //the class body
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that class `A` inherits all non-private non-static members of class
    `B` and implements the interfaces `AI`, `BI`, `CI`, and `DI`, as well as their
    base interfaces. The ability to implement multiple interfaces comes from the fact
    that the preceding example would have exactly the same result if re-written like
    this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: interface AI extends BI, CI, DI {
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: //the interface body
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: class A extends B implements AI {
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: //the class body
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: The `extended` interface (class) is also called superinterface (superclass)
    or parent interface (parent class). The extending interface (class) is called
    a child interface (child class) or subinterface (subclass).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate this with examples. We start with an interface inheritance:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: interface Vehicle {
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: interface Car extends Vehicle {
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: int getPassengersCount();
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car {
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: The class `CarImpl` in the preceding code must implement both signatures (listed
    in the interface `Vehicle` and in the interface `Car`), because from its perspective
    they both belong to the interface `Car`. Otherwise, a compiler will complain,
    or class `CarImpl` has to be declared abstract (and cannot be instantiated).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us look at another example:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: interface Vehicle {
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: public class VehicleImpl implements Vehicle {
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: interface Car extends Vehicle {
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: int getPassengersCount();
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl extends VehicleImpl implements Car {
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the class `CarImpl` does not need to implement the abstract
    method `getWeightInPounds()` because it has inherited the implementation from
    the base class `VehicleImpl`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'One consequence of the described class inheritance is usually not intuitive
    for a beginner. To demonstrate it, let us add the method `getWeightInPounds()`
    to the class `CarImpl`:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: public class VehicleImpl {
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl extends VehicleImpl {
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: return 3000d;
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we do not use interfaces, for simplicity. Because the class
    `CarImpl` is a child of the class `VehicleImpl`, it can behave as an object of
    class `VehicleImpl` and this code will compile just fine:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: VehicleImpl vehicle = new CarImpl();
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: vehicle.getWeightInPounds();
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: The question is, what value do you expect to be returned in the second line
    of the preceding snippet? If you guessed 3,000, you are correct. If not, do not
    feel embarrassed. It takes time to get used to it. The rule is that the reference
    of a base class type can refer to an object of any of its children. It is widely
    used for overriding base class behaviors.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: The summit is close. Only one step is left, although it brings something that
    you probably won't have expected if you did not know anything about Java before
    reading this book.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: The java.lang.Object class
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, here is a surprise. Each Java class, by default (without an explicit declaration),
    extends the class `Object`. To be precise, it is `java.lang.Object`, but we have
    not introduced packages yet and will only be talking about them in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages
    and Accessibility (Visibility)*.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'All Java objects inherit all the methods from it. There are ten of them:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean equals (Object obj)`'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int hashCode()`'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Class getClass()`'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String toString()`'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected Object clone()`'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait()`'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait(long timeout)`'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait(long timeout, int nanos)`'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void notify()`'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void notifyAll()`'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly visit each of these methods.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Before we do that, we would like to mention that you can override their default
    behavior in your classes, and re-implement them any way you need, which programmers
    often do. We will explain how to do this in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `equals()` of the `java.lang.Object` class looks like this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object obj) {
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: //compares references of the current object
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: //and the reference obj
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of its usage:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: Car car1 = new CarImpl();
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Car car2 = car1;
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: Car car3 = new CarImpl();
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: car1.equals(car2);    //returns true
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: car1.equals(car3);    //returns false
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding example, the implementation of the default
    method `equals()` compares only memory references that point to the addresses
    where the objects are stored. That is why the references `car1` and `car2` are
    equal – because they point to the same object (same area of the memory, same address),
    while the `car3` reference points to another object.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: A typical re-implementation of the `equals()` method uses an object's state
    for comparison instead. We will explain how to do this in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: The hashCode() method
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hashCode()` method of the `java.lang.Object` class looks like this:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: public int hashCode(){
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: //returns a hash code value for the object
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: //based on the integer representation of the memory address
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: The Oracle documentation states that, if two methods are the same according
    to the default behavior of the `equals()` method described previously, then they
    have the same `hashCode()` return value. Which is great! But unfortunately, the
    same document states that it is possible that two different (according to the
    `equals()` method) objects can have the same `hasCode()` return value. That is
    why programmers prefer to re-implement the `hashCode()` method and use it while
    re-implementing the `equals()` method instead of using the object state. The need
    to do it does not arise very often though, and we are not going into the details
    of such an implementation. If interested, you can find good articles about it
    on the internet.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: The getClass() method
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getClass()` method of the `java.lang.Object` class looks like this:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: public Class getClass(){
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: //returns object of class Class that has
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: //many methods that provide useful information
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used piece of information from this method is the name of
    the class that was the template for the current object. We will get into why one
    may need it in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction**.* The name of the class can be accessed via
    the object of the class `Class`, returned by this method.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: The toString() method
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `toString()` method of the `java.lang.Object` class looks like this:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: public String toString(){
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: //return string representation of the object
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is typically used to print the content of the object. Its default
    implementation looks like this:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: return getClass().getName()+"@"+Integer.toHexString(hashCode());
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is not very informative, so programmers re-implement it in
    their classes. This is the most commonly re-implemented method of the class `Object`.
    Programmers practically do it for each of their classes. We will explain more
    about the `String` class and its methods in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements.*
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: The clone() method
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `clone()` method of the `java.lang.Object` class looks like this:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: protected Object clone(){
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: //creates copy of the object
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: The default result of this method returns a copy of the object fields as-is,
    which is fine if the values are not an object reference. Such values are called
    **primitive type**, which we will define precisely in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types.* But if an object field holds a reference to
    another object, only the reference itself will be copied, not the referred object
    itself. That is why such a copy is called a shallow one. To get a deep copy, one
    has to re-implement the `clone()` method and follow all the references of the
    tree of objects that can be quite a widespread. Fortunately, the `clone()` method
    is not used very often. In fact, you may never encounter a need to use it.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: While reading this, you may wonder, what happens to an object when it is used
    as a method parameter. Is it passed inside the method as a copy using the `clone()`
    method? If so, is it passed as a shallow or a deep copy? The answer is, neither.
    Only a reference to the object is passed in as the parameter value, so all the
    methods that receive the same object reference can access the same area of the
    memory where the object state is stored.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: This presents a potential risk for unexpected data modification and subsequent
    data corruption – bringing them to an inconsistent state. That is why, while passing
    around an object, programmers have to always be aware that they are accessing
    values that may be shared across other methods and classes. We will talk more
    about this in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types* and expand on it in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM
    Processes and Garbage Collection* while talking about threads and concurrent processing
    in general.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: The wait() and notify() methods
  id: totrans-799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `wait(),` and `notify()` methods and their overloaded versions are used
    for communication between threads—the lightweight processes for concurrent processing. Programmers
    do not re-implement these methods. They just use them to increase the throughput
    and performance of their applications. We will go into more details about the `wait()`
    and `notify()` methods in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml),
    *JVM Processes and Garbage Collection*.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Now, congratulations are in order. You have stepped on the summit of Java basics
    complexity and will now continue walking horizontally, adding details and practicing
    the acquired knowledge. You have constructed in your head a framework of Java
    knowledge while reading the first two chapters. Don't feel frustrated if not everything
    is clear of if you forget something. Keep reading, and you will have many opportunities
    to refresh your knowledge, extend it, and retain it for a longer run. It is going
    to be an interesting journey with a nice reward at the final destination.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: OOP concepts
  id: totrans-802
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can talk about concepts that will make more sense to you, compared
    to presenting them before you learned the main terminology and saw the code examples.
    These concepts are:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'Object/class: This keeps the state and behavior together'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encapsulation: It hides the state and details of the implementation'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inheritance: It propagates behavior/signatures down the chain of class/interface
    extensions'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interface: It isolates signatures from their implementations'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polymorphism: This allows an object to be represented by multiple implemented
    interfaces and any of the base classes, including `java.lang.Object`.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, you are familiar with all of the above, so this is going to be mostly
    a summary, adding only a few details. That's how we learn – from observing specific
    facts, building a bigger picture, and improving that picture as new observations
    come in. We do it all the time, don't we?
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: Object/class
  id: totrans-810
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java program and an entire application can be written without creating a single
    object. Just use the `static` keyword in front of every method and every field
    of a class you are creating and call them from the static `main()` method. You
    will be limited in your programming capabilities. You will not be able to create
    an army of objects that can work in parallel doing a similar job on their own
    copy of data, for example. But your application will still work.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Besides, in Java 8,  functional programming features were added that allow us
    to pass around functions the same way an object can be passed. So, your object-less
    application could be quite capable. And several languages without object creating
    capabilities were used very effectively. Yet, after object-oriented languages
    proved to be useful and became popular, the first being Smalltalk, several traditionally
    procedural languages—PHP, Perl, Visual Basic, COBOL 2002, Fortran 2003, and Pascal,
    to name a few—added object-oriented capabilities.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: As we just mentioned, Java also extended its features into covering functional
    programming, thus blurring the borders between procedural, object-oriented, and
    functional languages. Yet, the presence of classes and the ability to use them
    to create objects is the first of the concepts that a programming language must
    support in order to be classified as object-oriented.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation—the ability to make data and functions (methods) inaccessible
    from outside or have controlled access—was one of the primary drivers for creating
    object-oriented languages. Smalltalk was created on the idea of messages passing
    between objects, which is done in both Smalltalk and Java when one object calls
    a method on another object.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation allows invocation of services of an object without knowing how
    those services are implemented. It reduces the software's system complexity and
    increases its maintainability. Each object does its job without the need to coordinate
    the changes in the implementation with its clients, so long as it does not violate
    the contract that is captured in the interface.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss encapsulation in further detail in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml),
    *Packages and Accessibility (Visibility)*.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-818
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is another OOP concept supported by every object-oriented language.
    It is usually described as the ability to reuse the code, which is a true but
    often misunderstood statement. Some programmers assume that inheritance claims
    to be able to reuse code *between applications*. In our experience, code reusability
    between applications can be accomplished without inheritance and is more dependent
    on the functional similarity between applications than the particular programming
    language feature. It is more related to the skill of the extracting common code
    into a shared reusable library than anything else.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: In Java, or any other object-oriented language, inheritance allows the reuse
    of common functionality, implemented in a base class, *across its children*. It
    can be used for bringing modularity and improving code reusability across applications
    by assembling base classes into a common shared library. But in practice, such
    an approach is rarely used because each application usually has such particular
    requirements that a common base class is either too simplistic and effectively
    useless or carries many methods specific to each of the applications. Besides,
    in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces, Classes,
    and Objects Construction*, we will show that reusability is much easier achieved
    using an aggregation, which is based on using independent objects instead of inheritance.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: Together with an interface, inheritance makes polymorphism possible.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: Interface (abstraction)
  id: totrans-822
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes OOP concept of an interface is also called abstraction because an
    interface summarizes (abstracts) the public description of an object behavior
    from the details of its implementation and hides (abstracts) it. An interface
    is an integral part of an encapsulation and polymorphism, but important enough
    to be stated as a separate concept. Its significance will become especially apparent
    in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented Design
    (OOD)* *P**rinciples*, when we discuss the transition from a project idea and
    vision to the specific programming solution.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Interface and inheritance provide the foundation for polymorphism.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-825
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the code examples we have provided, you have probably already realized
    that an object has all the methods that are listed in the implemented interfaces
    and all the non-private non-static methods of its base classes, including `java.lang.Object`.
    Like a person with many citizenships, it can pass as an object of any of its base
    classes or implemented interfaces. This language capability is called a polymorphism
    (from *poly* – many and *morphos* – form).
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in broad terms, method overloading—when a method with the same
    name can have different behavior depending on its signature—exhibits polymorphic
    behavior too.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Interface versus abstract class
  id: totrans-828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between an interface and an abstract class? We did not
    talk about it, so you will need to do some research.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: After the default methods of interfaces were introduced in Java 8, the difference
    shrunk significantly, and is negligible in many cases.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  id: totrans-831
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract class can have a constructor, while an interface cannot.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can have a state, while an interface cannot. The fields of
    an abstract class can be private and protected, while in an interface, fields
    are public, static, and final.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can have method implementation with any access modifiers,
    while implemented default methods in an interface are public only.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: If the class you would like to amend extends to another class already, you cannot
    use an abstract class, but you can implement an interface, because a class can
    extend to only one other class but can implement multiple interfaces.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-836
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the foundational concepts of Java and of any
    object-oriented programming language. You now have an understanding of classes
    and objects as the basic building blocks of Java, know what static and instance
    members are, and know about interface, implementation, and inheritance. That was
    the most complex and challenging exercise of this beginner chapter, and brought
    the reader to the core of Java language, introducing the language framework we
    are going to use throughout the rest of the book. The exercise allowed the reader
    to get exposure to the discussion about the differences between an interface and
    an abstract class, which has become much narrower after Java 8's release.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn to practical matters of programming. The reader
    will be guided through the concrete steps of installing the necessary tools and
    configuring the development environment on their computer. After that, all the
    new ideas and software solutions will be demonstrated, with specific code examples.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
