- en: Java Language Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a general idea about Java and its related terms and tools,
    we will start discussing Java as a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce the basic concepts of Java as an **object-oriented
    programming** (**OOP**) language. You will learn about classes, interfaces, and
    objects, and their relations. You will also learn the concepts and features of
    OOP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic terms in Java programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and objects (instances)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class (static) and object (instance) members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface, implementation, and inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP concepts and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Interface versus abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call them basics because they are the founding principles of Java as a language,
    and there is more to learn before you can start programming professionally. For
    those who are learning Java for the first time, learning the basics of Java is
    a steep slope to climb, but the path becomes easier thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: The basic terms of Java programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notion of Java programming basics has many interpretations. Some tutorials
    assume the basics to be the same for any object-oriented language. Others discuss
    syntax and basic language elements and grammar rules. Yet others reduce the basics
    to the value types, operators, statements, and expressions that allow computations.
  prefs: []
  type: TYPE_NORMAL
- en: Our view of Java basics consists of some elements from each of the earlier approaches.
    The only criteria for the selection we used were practicality and a gradual increase
    of complexity. We will start with simple definitions in this section, and then
    dive deeper into them in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Byte code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the broadest terms, a Java program (or any computer program for that matter)
    means a sequential set of instructions for a computer, that tell it what to do. Before
    executing on a computer, a program must be compiled from a human-readable, high-level
    programming language into a machine-readable binary code.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Java, the human-readable text, called a source code, is stored
    in a `.java` file and can be compiled into byte code by the Java compiler `javac`.
    Java byte code is the instruction set for JVM. The byte code is stored in a `.class`
    file and can be interpreted and compiled into binary code by, JVM or, more specifically,
    by the **Just-In-Time** (**JIT**) compiler used by JVM. The binary code is then
    executed by a microprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: An important feature of byte code is that it can be copied from one machine
    and executed on another machine's JVM. That is what Java portability means.
  prefs: []
  type: TYPE_NORMAL
- en: Defects (bugs) and their severity and priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *bug*, with the meaning of *little faults and difficulties*, existed
    as early as the 19th century. The origin of this word is unknown, but it looks
    as if the verb *to bug* in a sense *to annoy* comes from that feeling of a pesky
    bothering coming from an insect—a bug—that buzzes around and threatens to bite
    you or something. The word was applied to programming defects as soon as a computer
    was first built.
  prefs: []
  type: TYPE_NORMAL
- en: The defects vary by their severity – the degree of the effect they have on the
    program execution, or its results. Some defects are quite insignificant, like
    a format, in which the data are presented for a human. It would be another matter
    if the same data have to be consumed by some other system that could not process
    data presented in such a format. Then such a defect may be qualified as critical,
    because it would not allow the system to complete the data processing.
  prefs: []
  type: TYPE_NORMAL
- en: The severity of a defect depends on how it affects the program, not on how difficult
    it is to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Some defects may force the program to exit before it has achieved the desired
    result. For example, a defect may lead to the exhaustion of memory or another
    resource, and cause JVM to shut down.
  prefs: []
  type: TYPE_NORMAL
- en: The defect priority, how high the defect is on the to-do list, generally corresponds
    to the severity. But some low severity defects may be prioritized higher because
    of a customer perception. For example, the grammar error on a website, or a typo
    that may be perceived as offensive.
  prefs: []
  type: TYPE_NORMAL
- en: A defect's priority typically corresponds to its severity but sometimes, the
    priority may be increased based on customer perception.
  prefs: []
  type: TYPE_NORMAL
- en: Java program dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also mentioned that a program may require the use of other programs and procedures
    that are already compiled into bytecodes. For JVM to find them, you must list
    the corresponding `.class` files in the `java` command using the `-classpath` option.
    Several programs and procedures make up a Java application.
  prefs: []
  type: TYPE_NORMAL
- en: The other programs and procedures used by the application for its tasks are
    called application dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that JVM does not read a `.class` file until some other class code requests
    it. So, it well may be that some of the `.class` files listed on a classpath are
    never used if the conditions under which they are needed never happen during the
    application's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A statement is a language construct that can be compiled into a set of instructions
    to a computer. The closest analogy from everyday life to a Java statement is a
    sentence in the English language, a basic unit of language that expresses a complete
    thought. Every statement in Java must end with a `;` (semi-colon).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a declaration statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding statement declares a variable `i` of type `int` which stands for
    *integer* (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an expression statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: i + 2;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding statement adds 2 to the value of the existing variable `i`. When
    declared, an `int` variable is assigned a value of 0 by default, so the result
    of this expression is `2`, but it is not stored. That is why it is often combined
    with declaration and assignment statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int j = i + 2;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This tells the processor to create the variable `j` of type `int` and assign
    to it a value that is equal to the current value assigned to the variable `i` increased
    by `2`. In [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, we will discuss statements and expressions in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Java method is a group of statements that are always executed together with
    the purpose of producing a certain result in response to a certain input.  A method
    has a name, either a set of input parameters or no parameters at all, a body inside
    `{}` brackets, and a return type or `void` keyword that indicates that message
    does not return any value. Here is an example of a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: int j = i * 2;
  prefs: []
  type: TYPE_NORMAL
- en: return j;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, the method name is `multiplyByTwo`. It has one
    input parameter of type `int`. The method name and the list of parameter types
    are together called **method signature**.  The number of input parameters is called
    **arity**. Two methods have the same signature if they have the same name, the
    same arity, and the same sequence of types in the list of input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was a rewording of the definition of a method signature taken from Java
    Specification, section *8.4.2 Method Signature*. On the other hand, in the same
    specification, one can encounter the phrases such as: *several methods with the
    same name and signature*, *method* `getNumberOfScales` *in class* `Tuna` *has
    a name, signature, and return type*, and similar. So, beware; even the specification''s
    authors sometimes do not include method name into the notion of the method signature,
    and don''t be confused if other programmers follow suit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same preceding method can be re-written in many styles and with the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another style is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){ return i * 2; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers prefer the most compact style, to be able to see as much code
    as possible on the screen. But that could decrease another programmer's ability
    to understand the code, which could lead to programming defects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is a method without input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int giveMeFour(){ return 4; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is quite useless. In reality, a method without parameters would read data
    from a database, for example, or from another source. We showed this example just
    to demonstrate the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of code that does nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void multiplyByTwo(){ }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method does nothing and returns nothing. The syntax requires indicating
    the absence of a return value using the keyword `void`. In reality, methods without
    return values are often used to record data to a database or to send something
    to a printer, to an email server, to another application (using web-services,
    for example), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'And just for a complete overview, here is an example of a method with many
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String doSomething(int i, String s, double a){
  prefs: []
  type: TYPE_NORMAL
- en: double result = Math.round(Math.sqrt(a)) * i;
  prefs: []
  type: TYPE_NORMAL
- en: return s + Double.toString(result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The above method extracts a square root from the third parameter, multiplies
    it to the first parameter, converts the result into a string, and attaches (concatenates)
    the result to the second parameter. The types and methods from the class `Math` used
    will be covered in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*. These calculations do not make much sense and are
    provided just for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All methods in Java are declared inside of structures called **classes**. A
    class has a name and a body in brackets `{}`, where methods are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: int multiplyByTwo(int i){ return i * 2; }
  prefs: []
  type: TYPE_NORMAL
- en: int giveMeFour(){ return 4;}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Classes also have fields, often called properties; we will talk about them in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Main class and the main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One class serves as an entry to a Java application. It has to be specified
    in the `java` command while launching the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: java -cp <location of all .class files> MyGreatApplication
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding command, `MyGreatApplication` is the name of the class that
    serves as the starting point of the application. When JVM finds the file `MyGreatApplication.class`,
    it reads it into the memory and looks in it for a method called `main()`. This
    method has a fixed signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: // statements go here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break the preceding code snippet into pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` means that this method is accessible to any external program (see
    [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static` means that there is only one copy of the method exists in all the
    memory (see the following section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void` means it returns nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` is the method name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String[] args` means it accepts an array of String values as an input parameter
    (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//` means it is a comment, ignored by JVM and placed here only for humans
    (see [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding `main()` method does nothing. If run, it will execute successfully
    but produce no result.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also see the input parameters written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args) {
  prefs: []
  type: TYPE_NORMAL
- en: //body that does something
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like a different signature, but in fact, it is the same. Since JDK
    5, Java has allowed the *last parameter* of the method signature to be declared
    as a sequence of parameters of the same type of the variable arity. This is called
    **varargs**. Inside the method, one can treat the last input parameter as an array
    `String[]`, whether it was declared as an array explicitly or as a varargs. You will
    be fine if you never use varargs in your life. We are telling you about it just
    so you can avoid confusion while reading other peoples' code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last, important feature of the `main()` method is the source of its input
    parameter. There is no other code that calls it. It is called by JVM itself. So,
    where do the parameters come from? One could guess that the command line is the
    source of the parameter values. In the `java` command, so far, we assumed that
    no parameters were passed to the main class. But if the main method expects some
    parameters, we can construct the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: java -cp <location of all .class files> MyGreatApplication 1 2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This means that inside the `main()` method, the value of the first element of
    the input array `args[0]` will be `1`, while the value of the second element of
    the input array `args[1]` will be `2`. Yes, you noticed it right, the count of
    the elements in an array starts with `0`. We will discuss this further in [Chapter
    5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements and Types*. The
    result will be the same whether the `main()` method signature is described using
    an array `String[] args` explicitly or by using varargs `String... args`.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `main()` method then calls methods in the same main `.class`
    file or in the other `.class` files listed with the `-classpath` option. In the
    following section, we will see how such calls can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects (instances)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is used as the template for creating objects. When an object is created,
    all fields and methods declared in the class are copied into an object. The combination
    of field values in an object is called **object state**. The methods provide object
    behavior.  An object is also called an instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Each object is created by using the operator `new` and a constructor that looks
    like a special kind of method. The primary duty of a constructor is to set an
    initial object state.
  prefs: []
  type: TYPE_NORMAL
- en: Let's us now have a closer look at Java classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Java classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java classes are stored in `.java` files. Each `.java` file may contain several
    classes. They are compiled by the Java compiler `javac` and stored in `.class` files.
    Each `.class` file contains one compiled class only.
  prefs: []
  type: TYPE_NORMAL
- en: Each `.java` file contains only one `public` class. The keyword `public` in
    front of the class name makes it accessible from the classes in other files. The
    filename must match the public class name. The file can contain other classes
    too, they are compiled into their own `.class` file, but they can be accessed
    only by the public class that gave its name to the `.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the content of the file `MyClass.java` might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public String method1(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements, including return statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private void method2(String s){
  prefs: []
  type: TYPE_NORMAL
- en: //statements without return statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It has two fields. The keyword `private` makes them accessible only from inside
    the class, from its method. The preceding class has two methods – one public and
    one private. The public method is accessible by any other class, while the private
    method is accessible only from other methods of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class seems to not have a constructor. So, how are the states of the objects
    based on this class going to be initialized? The answer is that, in fact, each
    class that does not define its constructor explicitly but gets a default one—without
    parameters. And here are two examples of constructors added explicitly—one without
    parameters, another with a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class SomeClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = 42;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other content of the class - methods
  prefs: []
  type: TYPE_NORMAL
- en: //    that define object behavior
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... methods here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, the keyword `this` indicates the current object.
    Its usage is optional. We could write `field1 = val1;` and achieve the same result.
    But it is a good practice to use the keyword `this` to avoid confusion, especially
    when (and programmers often do this) the name of the parameter is the same as
    the name of the field, such as in the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int field1, String field1){
  prefs: []
  type: TYPE_NORMAL
- en: field1 = field1;
  prefs: []
  type: TYPE_NORMAL
- en: field2 = field2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the keyword `this` makes the code more friendly to human eyes. And sometimes,
    this is needed. We will discuss such cases in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A constructor can also call the methods of this or any other accessible class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: method1(33);
  prefs: []
  type: TYPE_NORMAL
- en: method2(val2);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String method1(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements, including return statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private void method2(String s){
  prefs: []
  type: TYPE_NORMAL
- en: //statements without return statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If a class does not define a constructor explicitly, it gets a default constructor
    from the default base class `java.lang.Object`. We will explain what it means
    in the upcoming *Inheritance* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can have several constructors with different signatures that can be
    used to create objects with different states if an application logic requires
    it. Once an explicit constructor with parameters is added to a class, the default
    constructor is not accessible unless it is added explicitly too. To clarify, this
    class has only one—default—constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And this class has only one constructor too, but does not have a default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This class has two constructors—with and without parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(){ }
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding constructor without parameters does nothing. It is provided only
    for the convenience of the client code that needs to create an object of this
    class but does not care about the particular initial state of the object. In such
    cases, JVM creates the default initial object state. We will explain what the
    default state is in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*.
  prefs: []
  type: TYPE_NORMAL
- en: Each object of the same class, created by any constructor, has the same methods
    (same behavior) even if its state (values assigned to the fields) is different.
  prefs: []
  type: TYPE_NORMAL
- en: This information about Java classes is enough for a beginner. Nevertheless,
    we would like to also describe some other classes that can be included in the
    same `.java` file, so that you will recognize them in other people's code. These
    other classes are called **nested classes**. They can be accessed only from the
    classes in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class we have previously described – the only one public class in the `.java`
    file – is also called a top-level class. It can include a nested class called
    an inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass { // top-level class
  prefs: []
  type: TYPE_NORMAL
- en: class MyOtherClass { // inner class
  prefs: []
  type: TYPE_NORMAL
- en: //inner class content here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'A top-level class can also include a static (more about static members in the
    next section) nested class. A `static` class is not called an inner class, just
    a nested class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass { // top-level class
  prefs: []
  type: TYPE_NORMAL
- en: static class MyYetAnotherClass { // nested class
  prefs: []
  type: TYPE_NORMAL
- en: // nested class content here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any method can include a class that can be accessed only within the method.
    It is called a local class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass { // top-level class
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod() {
  prefs: []
  type: TYPE_NORMAL
- en: class MyInaccessibleAnywhereElseClass { // local class
  prefs: []
  type: TYPE_NORMAL
- en: // local class content here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: A local class is not very often used, but not because it is useless. Programmers
    just do not remember how to create a class that is needed inside one method only
    and create an external or inner class instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last but not the least kind of a class that can be included in the same
    file as a public class is called an anonymous class. It is a class without a name
    that allows the creation of an object in-place that can override the existing
    method or implement an interface. Let''s us assume that we have the following
    interface, `InterfaceA`, and the class `MyClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface InterfaceA{
  prefs: []
  type: TYPE_NORMAL
- en: void doSomething();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod1() {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("1\. Regular is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void someMethod2(InterfaceA interfaceA) {
  prefs: []
  type: TYPE_NORMAL
- en: interfaceA.doSomething();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: MyClass myClass = new MyClass();
  prefs: []
  type: TYPE_NORMAL
- en: myClass.someMethod1();
  prefs: []
  type: TYPE_NORMAL
- en: myClass = new MyClass() {     //Anonymous class extends class MyClass
  prefs: []
  type: TYPE_NORMAL
- en: public void someMethod1(){              // and overrides someMethod1()
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("2\. Anonymous is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: myClass.someMethod1();
  prefs: []
  type: TYPE_NORMAL
- en: myClass.someMethod2(new InterfaceA() { //Anonymous class implements
  prefs: []
  type: TYPE_NORMAL
- en: public void doSomething(){     //  InterfaceA
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("3\. Anonymous is called");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is going to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Regular is called
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Anonymous is called
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Anonymous is called
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We do not expect the reader to understand the preceding code in full detail
    yet. We hope that the reader will be able to do it after reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: This was a long section, with a lot of information. Most of it is just for reference,
    so do not feel bad if you do not remember everything. Just revisit this section
    after you have finished the book and acquired some practical experience with Java
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: A few more introductory sections follow. Then [Chapter 3](18c6e8b8-9d8a-4ece-9a3f-cd00474b713e.xhtml),
    *Your Development Environment Setup,* will lead you through the configuration
    of the development tools on your computer, and in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, you will start writing code and execute it - the moment every
    software developer remembers.
  prefs: []
  type: TYPE_NORMAL
- en: A few more steps, and you can call yourself a Java programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Java object (class instance)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One often reads—and Oracle documentation is not an exception—that an object
    is *used to model the real-world objects*. Such a view originates from before
    the days of object-oriented programming. At that time programs had a common or
    global area to store intermediate results. If not carefully managed, different
    subroutines and procedures—that's what methods were called then—modified those
    values, stepping on each other's toes and making it very difficult to trace defects.
    Naturally, programmers tried to regulate the access to the data and to make the
    intermediate results accessible only to certain methods. A bundle of methods and
    the data only they can access started to be known as an object.
  prefs: []
  type: TYPE_NORMAL
- en: Such constructs were also seen as models of the real-world objects. All the
    objects around us probably have some kind of an inner state, but we do not have
    access to it and know only how the objects behave. That is, we can predict how
    they will react to this or that input.  Creating private fields in a class (object)
    that can be accessed only from the methods of the same class (object) seemed to
    be the solution to the hidden object state. With that, the original idea of modeling
    the real-world objects was carried along.
  prefs: []
  type: TYPE_NORMAL
- en: But after the years of object-oriented programming, many programmers realized
    that such a view can be misleading and actually quite harmful when one tries to
    apply it consistently to all kinds of software objects. For example, an object
    can carry values used as the parameters of an algorithm that has nothing to do
    with any real-world object but has everything to do with a computational efficiency.
    Or, as another example, an object that brings back the results of a computation.
    Programmers often call it a **data transfer object** (**DTO**). It has nothing
    to do with a real-world object unless stretches the definition of a real-world
    object, but that would be, well, a stretch.
  prefs: []
  type: TYPE_NORMAL
- en: 'A software object is simply a data structure in computer memory where the actual
    values are stored. Is memory a real-world object? The physical memory cells are,
    but the information they carry does not represent the cells. It represents the
    values and methods of a software object. And this information about an object
    is not even stored in a continuous memory area: object state is stored in an area
    called heap, while methods are stored in the method area, which, depending on
    the JVM implementation, may or may not be part of the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: An object, in our experience, is an integral part of the process of computation,
    which more often than not does not operate on models of real-world objects. An
    object is used to pass around values and methods, which are sometimes related
    and sometimes not. The set of methods and values might be grouped in one class
    for just a convenience or any other consideration.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, sometimes the software objects do represent models of real-world
    objects. But the point is that it is not always the case. With that, let us not
    consider software objects as models of real-world objects, unless they really
    are. Instead, let us look at how the objects are created and used and how they
    can help us to build a useful functionality – an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we described in the previous section, an object is created based on a class,
    using the keyword `new` and a constructor – either the default or one that is
    declared explicitly. Consider, for example, the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String method1(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements, including return statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods are here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have this class, we can write the following in the method of some other
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public AnotherClass {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: public void someMethod(){
  prefs: []
  type: TYPE_NORMAL
- en: MyClass myClass = new MyClass(3, "some string");
  prefs: []
  type: TYPE_NORMAL
- en: String result = myClass.method1(2);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the statement `MyClass myClass = new MyClass(3, "some
    string");` creates an object of class `MyClass`, using its constructor and the
    keyword `new`, and assigns the reference of the newly created object to the variable
    `myClass`. We have chosen an identificator of the object reference that matches
    the name of the class with the first letter in a lower case. It is just a convention
    and we could have chosen another identificator (like `boo`, for example) with
    the same result. In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*, we discuss identificators and variables in more
    detail. As you can see in the next line in the preceding example, once a reference
    is created we can use it to access public members of the newly created object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any Java object is created only one way: by using the keyword (operator) `new` and a
    constructor. This process is also called **class instantiation**. The reference
    to the object can be passed around as any other value (as a variable, parameter,
    or returned value), and every code that has access to the reference can use it
    to access the public members of the object. We will explain what public members
    are in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Class (static) and object (instance) members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned the term public members in relation to an object. We have
    also used the keyword `static` while talking about the `main()` method. We also
    stated that a member that is declared `static` can have only one copy in JVM memory.
    Now, we are going to define all that, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Private and public
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The keywords `private` and `public` are called **access modifiers**. There are
    also default and `protected` access modifiers, but we will talk about them in
    [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility
    (Visibility)*. They are called access modifiers because they regulate accessibility
    to (sometimes also called visibility of) classes, methods, and fields, from outside
    the class, and also because they modify the declaration of the corresponding class,
    method, or field.
  prefs: []
  type: TYPE_NORMAL
- en: A class can be private when it is a nested class only. In the preceding *Java
    class* section, we did not use an explicit access modifier for nested classes (thus,
    we used the default one), but we could have made them private if we would like
    to allow access to these classes only from the top-level class and siblings.
  prefs: []
  type: TYPE_NORMAL
- en: A private method or private field can be accessed only from within the class
    (object) where it is declared.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, a public class, method, or field can be accessed from any other
    class. Notice that a method or field cannot be public if the enclosing class is
    private. Which makes sense, doesn't it? If the class itself is inaccessible publicly,
    how can its members be public?
  prefs: []
  type: TYPE_NORMAL
- en: Static members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class can be declared static only when it is a nested class. Class members—methods
    and fields—can be static too, as long as the class is not anonymous or local.
    Any code can access a static member of a class without creating a class instance
    (object). We saw such an example in previous sections when we used the class `Math`
    in one of the code snippets. A static class member is also called a class variable
    in case of the field or a class method in case of a method. Notice that these
    names contain the word `class` as an adjective. That is because a static member
    is associated with a class, not a class instance. It means that there is only
    one copy of a static member that can exist in JVM memory, although many instances
    (objects) of the class can be created and reside there at any moment in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example. Let''s assume we have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: public static String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String method1(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements, including return statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static void method2(){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods are here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'From any method of any other class, the public static members of the preceding
    `MyClass` class can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.field2 = "any string";
  prefs: []
  type: TYPE_NORMAL
- en: String s = MyClass.field2 + " and another string";
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The result of the preceding operations will be the assigning to the variable
    `s` of the value `any string and another string`. The `String` class will be discussed
    further in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, one can access a public static method `method2()` of the class `MyClass`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: MyClass.method2();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other methods of the class `MyClass` can still be accessed via an instance
    (object):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: MyClass mc = new MyClass(3, "any string");
  prefs: []
  type: TYPE_NORMAL
- en: String someResult = mc.method1(42);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, there is no need to create an object of class `MyClass` if all its
    members are static.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, sometimes it is possible to access a static member using the
    object reference. The following code may work – it depends on the implementation
    of the `javac` compiler. If it works, it produces the same result as the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: MyClass mc = new MyClass(3, "any string");
  prefs: []
  type: TYPE_NORMAL
- en: mc.field2 = "Some other string";
  prefs: []
  type: TYPE_NORMAL
- en: mc.method2();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers provide a warning saying something like *static member being
    accessed by instance reference*, but they still let you do it. Others produce
    the error *cannot make a static reference to the non-static method/field* and
    force you to correct your code. The Java specification does not regulate such
    a case. But it is not a good practice to access a static class member via a reference
    to an object because it makes the code ambiguous for a human reader. So, you are
    better off avoiding doing that even if your compiler is more forgiving.
  prefs: []
  type: TYPE_NORMAL
- en: Object (instance) members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A non-static class member is also called an instance variable in case of the
    field or an instance method in case of a method. It can be accessed only via reference
    to the object followed by a dot "`.`" We have seen several such examples already.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line with the long-established tradition, the fields of an object are usually
    declared private. If necessary, the methods `set()` and/or `get()` are provided
    to access such private values. They are often called setters and getters as they
    set and get values of private fields. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public void setField1(String val){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getField1(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.field1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void setField2(String val){
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getField2(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.field2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other methods are here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is necessary to make sure that the object state cannot be changed.
    To support such a case, programmers use a constructor to set the state and remove
    setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getField1(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.field1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getField2(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.field2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: //... other non-setting methods are here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Such an object is called immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two methods with the same name but different signatures represent method overloading.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int method(int i, String v){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is not allowed and will cause a compilation error, because return
    values are not a part of the method signature and cannot be used to distinguish
    one method from another if they have the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int method(int i){ //error
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, this is allowed, because the methods have different signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public String method(String v, int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i, String v){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Interface, implementation, and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are stepping into the most significant area of Java programming – the heavily
    used Java programming terms of interface, implementation, and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday life, the word interface is quite popular. Its meaning is very close
    to the role Java interface plays in programming. It defines the public face of
    an object. It describes how it is possible to interact with the object and what
    can be expected of it. It hides inner class workings and exposes only method signatures
    with return values and access modifiers. An interface cannot be instantiated.
    An object of an interface type can be created only by creating an object of a
    class that implements this interface (interface implementation will be covered
    more thoroughly in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: private int field1;
  prefs: []
  type: TYPE_NORMAL
- en: private String field2;
  prefs: []
  type: TYPE_NORMAL
- en: public MyClass(int val1, String val2){
  prefs: []
  type: TYPE_NORMAL
- en: this.field1 = val1;
  prefs: []
  type: TYPE_NORMAL
- en: this.field2 = val2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String method(int i){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int method(int i, String v){
  prefs: []
  type: TYPE_NORMAL
- en: //statements
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface MyClassInterface {
  prefs: []
  type: TYPE_NORMAL
- en: String method(int i);
  prefs: []
  type: TYPE_NORMAL
- en: int method(int i, String v);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: So, we could write `public class MyClass implements MyClassInterface {...}`.
    We will talk about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Since an interface is a *public* face, the method access modifier `public` is
    assumed by default and can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: An interface does not describe how the object of the class can be created. To
    discover that, one must look at the class and see what the signatures of the constructors
    it has are. One can also check and see if public static class members are present
    that can be accessed without creating an object. So, an interface is only the
    public face of a class *instance*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover the rest of interface capabilities. According to the Java Specification,
    *The body of an interface may declare members of the interface, that is, fields, methods,
    classes, and interfaces.* If you are confused and asking what the difference between
    an interface and a class is, you have a legitimate concern which we are going
    to address now.
  prefs: []
  type: TYPE_NORMAL
- en: Fields in the interface are implicitly public, static, and final. The modifier
    `final` means their values cannot be changed. By contrast, in a class, the implicit
    (default) access modifier of a class itself, its fields, methods, and constructors
    is package-private, which means it is visible only within its own package. Packages
    are named groups of related classes. You will learn about them in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml),
    *Packages and Accessibility (Visibility)*.
  prefs: []
  type: TYPE_NORMAL
- en: A method in the body of an interface may be declared default, static, or private.
    The purpose of the default method will be explained in the next section. A static
    method can be accessed from anywhere via the interface name and the dot "`.`".
    Private methods can be accessed only by other methods inside the same interface.
    By contrast, the default access modifier for the methods in classes is package-private.
  prefs: []
  type: TYPE_NORMAL
- en: As for the classes declared inside an interface, they are implicitly static. They
    are also public and can be accessed without an instance of an interface, which
    is impossible to create anyway. We are not going to talk more about such classes
    because they are used in very particular areas that are beyond the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to a class, an interface allows the declaration of an inner or nested
    interface inside its body. It can be accessed from outside like any static member,
    using the top-level interface with the dot "`.`". We would like to remind you
    that an interface is public by default and cannot be instantiated, and thus is
    static by default.
  prefs: []
  type: TYPE_NORMAL
- en: There is one last very important term related to interfaces. A method signature
    listed in the interface without an implementation is called an **abstract method** and
    the interface itself is called **abstraction** because it abstracts, summarizes,
    and removes the signatures from the implementation. An abstraction cannot be instantiated.
    As an example, if you put the keyword `abstract` in front of any class and try
    to create its object, the compiler will throw an error even if all the methods
    in the class are not abstract. In such a case, the class behaves as an interface
    with the default methods only. Yet, there is a significant difference in their
    usage, which you will see after reading the upcoming *Inheritance* section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about interfaces in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*, and cover their access modifiers in [Chapter
    7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and Accessibility (Visibility)*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interface can be implemented by a class, which means that the class has
    a body for each of the abstract methods listed in the interface. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface Car {
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  prefs: []
  type: TYPE_NORMAL
- en: double getMaxSpeedInMilesPerHour();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car{
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  prefs: []
  type: TYPE_NORMAL
- en: return 100d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We named the class `CarImpl` to indicate that it is an implementation of the
    interface `Car`. But we could name it any other way we like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both interface and its class implementation can have other methods too without
    causing a compiler error. The only requirement for the extra method in the interface
    is that it has to be default and have a body. Adding any other method to a class
    does not interfere with the interface implementation.  For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface Car {
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  prefs: []
  type: TYPE_NORMAL
- en: double getMaxSpeedInMilesPerHour();
  prefs: []
  type: TYPE_NORMAL
- en: default int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car{
  prefs: []
  type: TYPE_NORMAL
- en: private int doors;
  prefs: []
  type: TYPE_NORMAL
- en: private double weight, speed;
  prefs: []
  type: TYPE_NORMAL
- en: public CarImpl(double weight, double speed, int doors){
  prefs: []
  type: TYPE_NORMAL
- en: this.weight = weight;
  prefs: []
  type: TYPE_NORMAL
- en: this.speed = speed;
  prefs: []
  type: TYPE_NORMAL
- en: this.dooes = doors;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.weight;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.speed;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumberOfDoors(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.doors;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now create an instance of a class `CarImpl`, we can call all the methods
    we have declared in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CarImpl car = new CarImpl(500d, 50d, 3);
  prefs: []
  type: TYPE_NORMAL
- en: car.getWeightInPounds();         //Will return 500.0
  prefs: []
  type: TYPE_NORMAL
- en: car.getMaxSpeedInMilesPerHour(); //Will return 50.0
  prefs: []
  type: TYPE_NORMAL
- en: car.getNumberOfDoors();          //Will return 3
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That was not surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, here is something you might not have expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();          //Will return 4
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that by implementing an interface class acquires all the default
    methods the interface has. That is the purpose of the default methods: to add
    functionality to all classes that implement the interface. Without it, if we add
    an abstract method to an old interface, all current interface implementations
    will trigger a compiler error. But, if we add a new method with the modifier default,
    the existing implementations will continue working as usual.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, another nice trick. If a class implements a method with the same signature
    as the default method, it will `override` (a technical term) the behavior of the
    interface. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface Car {
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  prefs: []
  type: TYPE_NORMAL
- en: double getMaxSpeedInMilesPerHour();
  prefs: []
  type: TYPE_NORMAL
- en: default int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car{
  prefs: []
  type: TYPE_NORMAL
- en: private int doors;
  prefs: []
  type: TYPE_NORMAL
- en: private double weight, speed;
  prefs: []
  type: TYPE_NORMAL
- en: public CarImpl(double weight, double speed, int doors){
  prefs: []
  type: TYPE_NORMAL
- en: this.weight = weight;
  prefs: []
  type: TYPE_NORMAL
- en: this.speed = speed;
  prefs: []
  type: TYPE_NORMAL
- en: this.dooes = doors;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.weight;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.speed;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumberOfDoors(){
  prefs: []
  type: TYPE_NORMAL
- en: return this.doors;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 3;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the interface and class described in this example, we can write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CarImpl car = new CarImpl(500d, 50d, 3);
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();        //Will return 3 now !!!!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If not all of the abstract methods of the interface have been implemented the
    class must be declared abstract, and cannot be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an interface is to represent its implementations – all objects
    of all the classes that have implemented it. For example, we could create another
    class that implements the `Car` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class AnotherCarImpl implements Car{
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return 2d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public double getMaxSpeedInMilesPerHour(){
  prefs: []
  type: TYPE_NORMAL
- en: return 3d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getNumberOfDoors(){
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 5;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can let the `Car` interface represent each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Car car = new CarImpl(500d, 50d, 3);
  prefs: []
  type: TYPE_NORMAL
- en: car.getWeightInPounds();          //Will return 500.0
  prefs: []
  type: TYPE_NORMAL
- en: car.getMaxSpeedInMilesPerHour();  //Will return 50.0
  prefs: []
  type: TYPE_NORMAL
- en: car.getNumberOfDoors();           //Will produce compiler error
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();         //Still returns 3 !!!!
  prefs: []
  type: TYPE_NORMAL
- en: car = new AnotherCarImpl();
  prefs: []
  type: TYPE_NORMAL
- en: car.getWeightInPounds();          //Will return 2.0
  prefs: []
  type: TYPE_NORMAL
- en: car.getMaxSpeedInMilesPerHour();  //Will return 3.0
  prefs: []
  type: TYPE_NORMAL
- en: car.getNumberOfDoors();           //Will produce compiler error
  prefs: []
  type: TYPE_NORMAL
- en: car.getPassengersCount();         //Will return 5
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Several interesting observations can be made from looking at the preceding code
    snippet. First, when the variable `car` is declared as an interface type (not
    a class type as in the previous example), one cannot call a method not declared
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the `car.getPassengersCount()` method returns `3` the first time. One
    could have expected it to return `4`, because `car` was declared as an interface
    type and one could have expected the default method to work. But, in fact, the
    variable `car` refers the object of class `CarImpl`, and that is why the class
    implementation of the `car.getPassengersCount()` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with an interface, you should remember that the signatures come from
    the interface, but the implementation comes from a class, or from a default interface
    method if the class does not implement it. Here shines another feature of default
    methods. They serve both as a signature that can be implemented and as an implementation
    if the class does not implement it.
  prefs: []
  type: TYPE_NORMAL
- en: If there are several default methods in an interface, it is possible to create
    private methods accessible only by the default methods of the interface. They
    can be used to contain common functionality instead of repeating it in every default
    method. The private methods cannot be accessed from outside the interface.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can now reach the summit of Java basics complexity. After this,
    and all the way to the end of the book, we will only be adding some details and
    building up your programming skills. It will be a walk on a high altitude plateau
    - the longer you walk, the more comfortable you feel. But, to get to that height,
    we need to climb the last uphill pitch; inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can acquire (inherit) all the non-private non-static members, so that
    when we use the object of this class, we cannot have any idea where these members
    actually reside – in this class or in the class from which they were inherited.
    To indicate inheritance, the keyword `extends` is used. For example, consider
    the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: private void m1(){...}
  prefs: []
  type: TYPE_NORMAL
- en: public void m2(){...}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class B extends class A {
  prefs: []
  type: TYPE_NORMAL
- en: public void m3(){...}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class C extends class B {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the objects of classes `B` and `C` behave as if each of them
    has methods `m2()` and `m3()`. The only limitation is that a class can extend
    one class only. Class `A` is a base (or parent) class for both class `B` and class
    `C`. Class `B` is a base class for class `C` only. And, as we have mentioned already,
    each of them has the default base class `java.lang.Object`. Classes `B` and `C`
    are subclasses of class `A`. Class `C` is also a subclass of class `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, an interface can extend to many other interfaces at the same time.
    If `AI`, `BI`, `CI`, `DI`, `EI`, and `FI` are interfaces, then the following is
    allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface AI extends BI, CI, DI {
  prefs: []
  type: TYPE_NORMAL
- en: //the interface body
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface DI extends EI, FI {
  prefs: []
  type: TYPE_NORMAL
- en: //the interface body
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the interface `AI` inherits all the non-private non-static
    signatures of the interfaces `BI`, `CI`, `DI`, `EI`, and `FI`, and any other interfaces
    that are base interfaces of the interfaces `BI`, `CI`, `DI`, `EI`, and `FI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the topic of the previous section, *Implementation*, a class
    can implement many interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A extends B implements AI, BI, CI, DI {
  prefs: []
  type: TYPE_NORMAL
- en: //the class body
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that class `A` inherits all non-private non-static members of class
    `B` and implements the interfaces `AI`, `BI`, `CI`, and `DI`, as well as their
    base interfaces. The ability to implement multiple interfaces comes from the fact
    that the preceding example would have exactly the same result if re-written like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface AI extends BI, CI, DI {
  prefs: []
  type: TYPE_NORMAL
- en: //the interface body
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class A extends B implements AI {
  prefs: []
  type: TYPE_NORMAL
- en: //the class body
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `extended` interface (class) is also called superinterface (superclass)
    or parent interface (parent class). The extending interface (class) is called
    a child interface (child class) or subinterface (subclass).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate this with examples. We start with an interface inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface Car extends Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: int getPassengersCount();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl implements Car {
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The class `CarImpl` in the preceding code must implement both signatures (listed
    in the interface `Vehicle` and in the interface `Car`), because from its perspective
    they both belong to the interface `Car`. Otherwise, a compiler will complain,
    or class `CarImpl` has to be declared abstract (and cannot be instantiated).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: interface Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: double getWeightInPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class VehicleImpl implements Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface Car extends Vehicle {
  prefs: []
  type: TYPE_NORMAL
- en: int getPassengersCount();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl extends VehicleImpl implements Car {
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the class `CarImpl` does not need to implement the abstract
    method `getWeightInPounds()` because it has inherited the implementation from
    the base class `VehicleImpl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One consequence of the described class inheritance is usually not intuitive
    for a beginner. To demonstrate it, let us add the method `getWeightInPounds()`
    to the class `CarImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class VehicleImpl {
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return 2000d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public class CarImpl extends VehicleImpl {
  prefs: []
  type: TYPE_NORMAL
- en: public double getWeightInPounds(){
  prefs: []
  type: TYPE_NORMAL
- en: return 3000d;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int getPassengersCount(){
  prefs: []
  type: TYPE_NORMAL
- en: return 4;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we do not use interfaces, for simplicity. Because the class
    `CarImpl` is a child of the class `VehicleImpl`, it can behave as an object of
    class `VehicleImpl` and this code will compile just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: VehicleImpl vehicle = new CarImpl();
  prefs: []
  type: TYPE_NORMAL
- en: vehicle.getWeightInPounds();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The question is, what value do you expect to be returned in the second line
    of the preceding snippet? If you guessed 3,000, you are correct. If not, do not
    feel embarrassed. It takes time to get used to it. The rule is that the reference
    of a base class type can refer to an object of any of its children. It is widely
    used for overriding base class behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The summit is close. Only one step is left, although it brings something that
    you probably won't have expected if you did not know anything about Java before
    reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: The java.lang.Object class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, here is a surprise. Each Java class, by default (without an explicit declaration),
    extends the class `Object`. To be precise, it is `java.lang.Object`, but we have
    not introduced packages yet and will only be talking about them in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages
    and Accessibility (Visibility)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Java objects inherit all the methods from it. There are ten of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public boolean equals (Object obj)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int hashCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Class getClass()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public String toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected Object clone()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait(long timeout)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait(long timeout, int nanos)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void notify()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void notifyAll()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly visit each of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Before we do that, we would like to mention that you can override their default
    behavior in your classes, and re-implement them any way you need, which programmers
    often do. We will explain how to do this in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The method `equals()` of the `java.lang.Object` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object obj) {
  prefs: []
  type: TYPE_NORMAL
- en: //compares references of the current object
  prefs: []
  type: TYPE_NORMAL
- en: //and the reference obj
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Car car1 = new CarImpl();
  prefs: []
  type: TYPE_NORMAL
- en: Car car2 = car1;
  prefs: []
  type: TYPE_NORMAL
- en: Car car3 = new CarImpl();
  prefs: []
  type: TYPE_NORMAL
- en: car1.equals(car2);    //returns true
  prefs: []
  type: TYPE_NORMAL
- en: car1.equals(car3);    //returns false
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding example, the implementation of the default
    method `equals()` compares only memory references that point to the addresses
    where the objects are stored. That is why the references `car1` and `car2` are
    equal – because they point to the same object (same area of the memory, same address),
    while the `car3` reference points to another object.
  prefs: []
  type: TYPE_NORMAL
- en: A typical re-implementation of the `equals()` method uses an object's state
    for comparison instead. We will explain how to do this in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Objects Construction*.
  prefs: []
  type: TYPE_NORMAL
- en: The hashCode() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hashCode()` method of the `java.lang.Object` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public int hashCode(){
  prefs: []
  type: TYPE_NORMAL
- en: //returns a hash code value for the object
  prefs: []
  type: TYPE_NORMAL
- en: //based on the integer representation of the memory address
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The Oracle documentation states that, if two methods are the same according
    to the default behavior of the `equals()` method described previously, then they
    have the same `hashCode()` return value. Which is great! But unfortunately, the
    same document states that it is possible that two different (according to the
    `equals()` method) objects can have the same `hasCode()` return value. That is
    why programmers prefer to re-implement the `hashCode()` method and use it while
    re-implementing the `equals()` method instead of using the object state. The need
    to do it does not arise very often though, and we are not going into the details
    of such an implementation. If interested, you can find good articles about it
    on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The getClass() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getClass()` method of the `java.lang.Object` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public Class getClass(){
  prefs: []
  type: TYPE_NORMAL
- en: //returns object of class Class that has
  prefs: []
  type: TYPE_NORMAL
- en: //many methods that provide useful information
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used piece of information from this method is the name of
    the class that was the template for the current object. We will get into why one
    may need it in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction**.* The name of the class can be accessed via
    the object of the class `Class`, returned by this method.
  prefs: []
  type: TYPE_NORMAL
- en: The toString() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `toString()` method of the `java.lang.Object` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString(){
  prefs: []
  type: TYPE_NORMAL
- en: //return string representation of the object
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is typically used to print the content of the object. Its default
    implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return getClass().getName()+"@"+Integer.toHexString(hashCode());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is not very informative, so programmers re-implement it in
    their classes. This is the most commonly re-implemented method of the class `Object`.
    Programmers practically do it for each of their classes. We will explain more
    about the `String` class and its methods in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements.*
  prefs: []
  type: TYPE_NORMAL
- en: The clone() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `clone()` method of the `java.lang.Object` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: protected Object clone(){
  prefs: []
  type: TYPE_NORMAL
- en: //creates copy of the object
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The default result of this method returns a copy of the object fields as-is,
    which is fine if the values are not an object reference. Such values are called
    **primitive type**, which we will define precisely in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types.* But if an object field holds a reference to
    another object, only the reference itself will be copied, not the referred object
    itself. That is why such a copy is called a shallow one. To get a deep copy, one
    has to re-implement the `clone()` method and follow all the references of the
    tree of objects that can be quite a widespread. Fortunately, the `clone()` method
    is not used very often. In fact, you may never encounter a need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: While reading this, you may wonder, what happens to an object when it is used
    as a method parameter. Is it passed inside the method as a copy using the `clone()`
    method? If so, is it passed as a shallow or a deep copy? The answer is, neither.
    Only a reference to the object is passed in as the parameter value, so all the
    methods that receive the same object reference can access the same area of the
    memory where the object state is stored.
  prefs: []
  type: TYPE_NORMAL
- en: This presents a potential risk for unexpected data modification and subsequent
    data corruption – bringing them to an inconsistent state. That is why, while passing
    around an object, programmers have to always be aware that they are accessing
    values that may be shared across other methods and classes. We will talk more
    about this in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types* and expand on it in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml), *JVM
    Processes and Garbage Collection* while talking about threads and concurrent processing
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: The wait() and notify() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `wait(),` and `notify()` methods and their overloaded versions are used
    for communication between threads—the lightweight processes for concurrent processing. Programmers
    do not re-implement these methods. They just use them to increase the throughput
    and performance of their applications. We will go into more details about the `wait()`
    and `notify()` methods in [Chapter 11](e8c37d86-291d-4500-84ea-719683172477.xhtml),
    *JVM Processes and Garbage Collection*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, congratulations are in order. You have stepped on the summit of Java basics
    complexity and will now continue walking horizontally, adding details and practicing
    the acquired knowledge. You have constructed in your head a framework of Java
    knowledge while reading the first two chapters. Don't feel frustrated if not everything
    is clear of if you forget something. Keep reading, and you will have many opportunities
    to refresh your knowledge, extend it, and retain it for a longer run. It is going
    to be an interesting journey with a nice reward at the final destination.
  prefs: []
  type: TYPE_NORMAL
- en: OOP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can talk about concepts that will make more sense to you, compared
    to presenting them before you learned the main terminology and saw the code examples.
    These concepts are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Object/class: This keeps the state and behavior together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encapsulation: It hides the state and details of the implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inheritance: It propagates behavior/signatures down the chain of class/interface
    extensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interface: It isolates signatures from their implementations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polymorphism: This allows an object to be represented by multiple implemented
    interfaces and any of the base classes, including `java.lang.Object`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, you are familiar with all of the above, so this is going to be mostly
    a summary, adding only a few details. That's how we learn – from observing specific
    facts, building a bigger picture, and improving that picture as new observations
    come in. We do it all the time, don't we?
  prefs: []
  type: TYPE_NORMAL
- en: Object/class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java program and an entire application can be written without creating a single
    object. Just use the `static` keyword in front of every method and every field
    of a class you are creating and call them from the static `main()` method. You
    will be limited in your programming capabilities. You will not be able to create
    an army of objects that can work in parallel doing a similar job on their own
    copy of data, for example. But your application will still work.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, in Java 8,  functional programming features were added that allow us
    to pass around functions the same way an object can be passed. So, your object-less
    application could be quite capable. And several languages without object creating
    capabilities were used very effectively. Yet, after object-oriented languages
    proved to be useful and became popular, the first being Smalltalk, several traditionally
    procedural languages—PHP, Perl, Visual Basic, COBOL 2002, Fortran 2003, and Pascal,
    to name a few—added object-oriented capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As we just mentioned, Java also extended its features into covering functional
    programming, thus blurring the borders between procedural, object-oriented, and
    functional languages. Yet, the presence of classes and the ability to use them
    to create objects is the first of the concepts that a programming language must
    support in order to be classified as object-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation—the ability to make data and functions (methods) inaccessible
    from outside or have controlled access—was one of the primary drivers for creating
    object-oriented languages. Smalltalk was created on the idea of messages passing
    between objects, which is done in both Smalltalk and Java when one object calls
    a method on another object.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation allows invocation of services of an object without knowing how
    those services are implemented. It reduces the software's system complexity and
    increases its maintainability. Each object does its job without the need to coordinate
    the changes in the implementation with its clients, so long as it does not violate
    the contract that is captured in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss encapsulation in further detail in [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml),
    *Packages and Accessibility (Visibility)*.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is another OOP concept supported by every object-oriented language.
    It is usually described as the ability to reuse the code, which is a true but
    often misunderstood statement. Some programmers assume that inheritance claims
    to be able to reuse code *between applications*. In our experience, code reusability
    between applications can be accomplished without inheritance and is more dependent
    on the functional similarity between applications than the particular programming
    language feature. It is more related to the skill of the extracting common code
    into a shared reusable library than anything else.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, or any other object-oriented language, inheritance allows the reuse
    of common functionality, implemented in a base class, *across its children*. It
    can be used for bringing modularity and improving code reusability across applications
    by assembling base classes into a common shared library. But in practice, such
    an approach is rarely used because each application usually has such particular
    requirements that a common base class is either too simplistic and effectively
    useless or carries many methods specific to each of the applications. Besides,
    in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces, Classes,
    and Objects Construction*, we will show that reusability is much easier achieved
    using an aggregation, which is based on using independent objects instead of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Together with an interface, inheritance makes polymorphism possible.
  prefs: []
  type: TYPE_NORMAL
- en: Interface (abstraction)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes OOP concept of an interface is also called abstraction because an
    interface summarizes (abstracts) the public description of an object behavior
    from the details of its implementation and hides (abstracts) it. An interface
    is an integral part of an encapsulation and polymorphism, but important enough
    to be stated as a separate concept. Its significance will become especially apparent
    in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented Design
    (OOD)* *P**rinciples*, when we discuss the transition from a project idea and
    vision to the specific programming solution.
  prefs: []
  type: TYPE_NORMAL
- en: Interface and inheritance provide the foundation for polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the code examples we have provided, you have probably already realized
    that an object has all the methods that are listed in the implemented interfaces
    and all the non-private non-static methods of its base classes, including `java.lang.Object`.
    Like a person with many citizenships, it can pass as an object of any of its base
    classes or implemented interfaces. This language capability is called a polymorphism
    (from *poly* – many and *morphos* – form).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in broad terms, method overloading—when a method with the same
    name can have different behavior depending on its signature—exhibits polymorphic
    behavior too.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Interface versus abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between an interface and an abstract class? We did not
    talk about it, so you will need to do some research.
  prefs: []
  type: TYPE_NORMAL
- en: After the default methods of interfaces were introduced in Java 8, the difference
    shrunk significantly, and is negligible in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract class can have a constructor, while an interface cannot.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can have a state, while an interface cannot. The fields of
    an abstract class can be private and protected, while in an interface, fields
    are public, static, and final.
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can have method implementation with any access modifiers,
    while implemented default methods in an interface are public only.
  prefs: []
  type: TYPE_NORMAL
- en: If the class you would like to amend extends to another class already, you cannot
    use an abstract class, but you can implement an interface, because a class can
    extend to only one other class but can implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the foundational concepts of Java and of any
    object-oriented programming language. You now have an understanding of classes
    and objects as the basic building blocks of Java, know what static and instance
    members are, and know about interface, implementation, and inheritance. That was
    the most complex and challenging exercise of this beginner chapter, and brought
    the reader to the core of Java language, introducing the language framework we
    are going to use throughout the rest of the book. The exercise allowed the reader
    to get exposure to the discussion about the differences between an interface and
    an abstract class, which has become much narrower after Java 8's release.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn to practical matters of programming. The reader
    will be guided through the concrete steps of installing the necessary tools and
    configuring the development environment on their computer. After that, all the
    new ideas and software solutions will be demonstrated, with specific code examples.
  prefs: []
  type: TYPE_NORMAL
