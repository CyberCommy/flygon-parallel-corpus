- en: STL Algorithm Equivalents in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many programmers coming from other high-performance programming languages,
    particularly C++, understand the concept of the **Standard Templating Library** (**STL**).
    This library provides common programming data structures and functions access
    to a generalized library in order to rapidly iterate and write performant code
    at scale. Go does not have a built-in STL. This chapter will focus on how to utilize
    some of the most common STL practices within Go. The STL has four commonly referenced
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Being familiar with these topics will help you to write Go code more quickly
    and effectively, utilizing commonly implemented and optimized patterns. In this
    chapter, we are going to learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use STL practices in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize standard programming algorithms with respect to Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How containers store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How functions work in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to properly use iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, all of these pieces are still part of our performance puzzle. Knowing
    when to use the right algorithm, container, or functor will help you to write
    better-performing code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding algorithms in the STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Algorithms in the STL perform functions such as sorting and searching, as well
    as manipulating and counting data. These are called by the `<algorithm>` header
    in C++ and are used on ranges of elements. The groups of objects that are modified
    do not impact the structure of the container they are associated with. The patterns
    outlined in each of the subheadings here use Go''s language structure to implement
    these algorithms. The following types of algorithm will be explained in this section
    of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min and max elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to understand how all of these algorithms work will help you to produce
    performant code when you need to use these techniques to manipulate data structures
    using algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **sort** algorithm sorts an array into ascending order. Sort doesn''t require
    new containers to be created, destroyed, or copied—the sort algorithm sorts all
    the elements within their container. We can do this in Go with the standard library
    sort. Go''s standard library sort has helper functions for different data types
    (`IntsAreSorted`, `Float64sAreSorted`, and `StringsAreSorted`) for sorting their
    respective data types. We can implement the sorting algorithm as illustrated in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code instantiates simple data structures with values. After this, we sort
    each of these data structures using the built-in `sort` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we execute this, we can see that all of our slices have been sorted in order,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f300c9de-491f-4a81-91f3-de0892136d22.png)'
  prefs: []
  type: TYPE_IMG
- en: Integers are sorted low to high, strings are sorted alphabetically, and floats
    are sorted low to high. These are the default sorting methods within the `sort`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **reverse** algorithm takes a dataset and reverses the values of the set.
    The Go standard `sort` package does not have a built-in way to reverse slices.
    We can write a trivial `reverse` function in order to reverse the order of our
    dataset, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This function iterates through the slice, increments and decrements `x` and
    `y` until they converge, and swaps the elements in the slice, as we can see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fecb8769-eec6-4e8f-b2a1-cb458c9f6ea3.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, our slice is reversed using the `reverse()` function. Using the
    standard library makes a function that would be difficult to write by hand simple,
    concise, and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Min element and max element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can find the smallest and largest values within a dataset using the `min_element`
    and `max_element` algorithms respectively. We can implement `min_element` and
    `max_element` in Go using a simple iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll write a function to find the smallest integer in the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will follow the same process, but will attempt to find the largest
    integer in the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we''ll use these functions to print the resulting minimum and maximum
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions iterate through a slice of integers and find the minimum and
    maximum values within the slice, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ef9856d-ff05-4ca0-aaf3-d8aa36112563.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from our execution, the minimum and maximum values are found.
  prefs: []
  type: TYPE_NORMAL
- en: We also have `math.Min` and `math.Max` defined in the Go `math` package. These
    are only used for comparing `float64` data types. Float comparison is not an easy
    task, so the Go designers decided to make the default `Min` and `Max` signature;
    in the `math` library, you should use floats. If Go were to have generics, the
    main function we wrote above could potentially work for different types. This
    is part of the Go language design—keeping things simple and consolidated.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Binary search** is an algorithm that is used to find the location of a specific
    element in a sorted array. It starts by targeting the middle element in the array.
    If there is no match, the algorithm next takes the half of the array that could
    contain the item and uses the middle value to find the target. As we learned in
    [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and
    Algorithms*, binary search is an efficient algorithm at *O* (log *n*). The Go
    standard library `sort` package has a built-in binary search function. We can
    use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The binary search algorithm correctly finds the value of the integer we are
    searching for, `2`, in the position that it is expected to be in (position `1`
    in a zero-indexed slice). We can see the binary search execution in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deb1ce15-a3ba-4e03-957f-7c347ea83fa7.png)'
  prefs: []
  type: TYPE_IMG
- en: As a conclusion, the algorithms found in the STL all translate nicely to Go.
    Go's default functions and iterators make it easy to compose simple, reusable
    algorithms. In the next section, we will learn about containers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers fall under three separate categories in the STL:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequence containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence container adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to cover these three types of containers in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequence containers store data elements of a specific type. There are five
    current implementations of sequence containers: `array`, `vector`, `deque`, `list`,
    and `forward_list`. These sequence containers make it easy to reference data in
    a sequential manner. Being able to utilize these sequence containers is a great
    shortcut to writing effective code and reusing modular bits of the standard library.
    We will explore these in the following subsections.'
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **array** in Go is similar to that of an array in C++. Go''s array structures
    are statically defined during compile time and are not resizable. Arrays are implemented
    in Go in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This array holds the values of the strings defined in the `arrayExample` variable,
    which is defined as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go originally had a **vector** implementation, but this was removed very early
    on in the language development (October 11, 2011). It was deemed that slices are
    better (as was the title of the pull request) and slices became the de facto vector
    implementation in Go. We can implement a slice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Slices are beneficial because, like vectors in the STL, they can grow or shrink
    based on addition or deletion. In our example, we create a slice, append a value
    to the slice, and remove a value from the slice, as illustrated in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we execute our vector example, we can see our appending and removing in
    action, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e76ae808-21bd-4a85-ace9-d0627b4d30ae.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `tri` element was appended to the end of our slice, and
    we can also see that the `baz` element (element number 3 in the slice) was removed
    based on our `remove()` function call.
  prefs: []
  type: TYPE_NORMAL
- en: Deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **deque**, or a double-ended queue, is a container that can be expanded.
    These expansions can occur in the front or the back of the container. Deques are
    often used when the top or the back of a queue needs to be referenced frequently.
    The following code block is a simple implementation of a deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `deque` package takes a slice of elements and pushes them onto the queue
    with the `PushLeft` function. Next, we can pop elements off of the left and the
    right of the deque, until our queue is empty. We can see the execution of our
    deque logic in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f7cf55a-1bfc-4ddd-8621-72fdbb477ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: Our results show the output of the manipulation of the deque and how we can
    pull things from either end of the queue. Being able to pull things from either
    end of the queue is advantageous in data manipulation, and this is why a deque
    is a popular data structure choice.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **list** is Go''s implementation of a doubly linked list. This is built into
    the container/list package in the standard library. We can perform many actions
    using the implementation of a generic doubly linked list, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A doubly linked list is similar to the deque container, but it allows for insertion
    and removal from the middle of the stack if necessary. Doubly linked lists are used much
    more often in practice. We can see the execution of our doubly linked list code
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9cac75c-cea0-4d60-a222-dede65b5634b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that all the elements are in the order in which they were coordinated
    on the stack in the output from our program. Linked lists are quintessential to
    programming, as they are a fundamental algorithm that much of today's computer
    science is built on.
  prefs: []
  type: TYPE_NORMAL
- en: Forward list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **forward list** is an implementation of a singly linked list. A singly linked
    list typically has a smaller memory footprint than a doubly linked list; however,
    iteration through a singly linked list isn''t as good, particularly in the reverse
    direction. Let''s see how to implement a forward list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our program and define our structures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create our `Append` function and apply it in our `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the resulting output in the following screenshot, all of
    the pieces of data we appended to our singly linked list are accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb95afd0-8331-4c4a-a236-2988b3672f40.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial elements of this data structure are put into the list in the order
    that they were added within the code block. This is expected, as singly linked
    lists are often used in order to keep the order of data within the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Container adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Container adapters** take a sequential container and adapt the way it is
    used in order for the original sequential container to function in its intended
    manner. During the investigation of these container adapters, we will learn how
    all of them are created and how they are used from a practical standpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Queues** are containers that follow the **FIFO** queuing method, or **first
    in first out**. This means that we can add things to the container and pull them
    from the other end of the container. We can make the simplest form of a queue
    by appending and dequeueing from a slice, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we append strings to our `simpleQueue` and then dequeue them
    by removing the first element of the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4019bac0-03c1-48b9-b70d-8bc356bece3f.png)'
  prefs: []
  type: TYPE_IMG
- en: In our output, we can see that we correctly added elements to the queue and
    removed them.
  prefs: []
  type: TYPE_NORMAL
- en: Priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **priority queue** is a container that uses a heap to keep a prioritized list
    of the elements within the container. Priority queues are helpful because you
    can order the result set by priority. Priority queues are often used for many
    practical applications, from load balancing web requests to data compression,
    to Dijkstra's algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our priority queue example, we create a new priority queue and insert a
    couple of different programming languages that have a given priority. We start
    with Java being the first priority and then Go becomes the first priority. PHP
    gets added and Java''s priority gets pushed down to 3\. The following code is
    an example of a priority queue. Here, we instantiate the necessary requirements,
    create a new priority queue, insert elements into the priority queue, change the
    priority of those items, and pop items from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After our execution of this sample code, we can see a proper ordering of the
    languages based on the priority queue values that we have set, as we can see in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fee330b8-41fd-4f84-bf6a-897163106ca2.png)'
  prefs: []
  type: TYPE_IMG
- en: Priority queues are a commonly used, important data structure. They are used
    in order to process the most important elements within a data structure first,
    and being able to implement this with STL equivalents helps us to save time and
    effort while being able to prioritize incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **stack** serves the grouping of data using `push` and `pop` to add and remove
    elements from the container. Stacks usually have a **LIFO** (short for **last
    in first out**) order of operation, and the `Peek` operation usually lets you
    see what is on top of the stack without removing it from the stack. Stacks are
    very handy for things that have a bounded set of memory, as they can utilize the allocated memory
    effectively. The following code is a simple implementation of a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output from our program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5668bbc-af83-441e-9686-3cba9578e963.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our stack operations were executed as expected. Being able to
    use stack manipulation is important in computer science as this is how many low-level
    programming techniques are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Associative containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Associative containers** are containers that implement associative arrays.
    These arrays are ordered and differ only in the constraints placed by the algorithm
    on each of their elements. The STL references associative containers—namely set,
    map, multiset, and multimap. We will explore these in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **set** is used to only store keys. Go doesn''t have a set type, so a `map`
    of the type to a Boolean value is used frequently in order to build a set. The
    following code block is an implementation of an STL equivalent set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output shows that we were able to set and delete the values accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7addd1b1-797a-4329-b59f-542ae2b6fb62.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see from our output that our code can properly manipulate a set, which
    is crucial for common key–value pairings.
  prefs: []
  type: TYPE_NORMAL
- en: Multiset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Multisets** are unordered sets with a count associated with each element.
    There are lots of convenient bits of manipulation that can be used with multisets,
    such as taking the difference, scaling the set, or checking the cardinality of
    a set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we build a multiset `x`, scale it by `2` as a multiset `y`,
    validate that `x` is a subset of `y`, and check the cardinality of `x`. We can
    see an example implementation of a multiset in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we execute this code, we can see `x`, the scaled version of `x`, `y`, the
    validation of `x` as a subset of `y`, and the cardinality calculation of `x`.
    The following is the output from the execution of our multiset code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e1f8c99-6d59-49b1-a0e6-46cec4e2d93a.png)'
  prefs: []
  type: TYPE_IMG
- en: Multisets are useful for set manipulation and are convenient because there can
    be multiple instances of each element. A good practical example of a multiset
    would be a shopping cart—you can add many items to your shopping cart and you
    can have many counts of the same item in your shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **map** is a kind of container that is used to store key–value pairs. Go's
    built-in `map` type uses a hash table to store keys and their associated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, instantiating a map is simple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s have a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4851a8a9-75ea-4ead-9a1a-5c545d7e85eb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding execution result, we can see that we can create a map, reference
    a value in a map by using its key, and find the number of elements in our map
    using the `Len()` built-in type.
  prefs: []
  type: TYPE_NORMAL
- en: Multimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **multimap** is a map where one or more values can be returned with a key.
    A practical application of a multimap would be a web query string. Query strings
    can have multiple values assigned to the same key, as we can see with the following
    example URL: `https://www.example.com/?foo=bar&foo=baz&a=b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are going to create a multimap of cars. Our `car` struct
    has a year and a style associated with each car. We''ll be able to aggregate these
    different types together. The following code snippet is an implementation of a
    multimap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have multiple versions of cars with a `2019` model year (a convertible and `SUV`).
    In our resulting output, we can see these values aggregated together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9e210b0-fd35-4fc8-b8f8-9e5d3d55f297.png)'
  prefs: []
  type: TYPE_IMG
- en: Multimaps are useful when you have a one-to-many association that you'd like
    to capture in a map. In the next section, we will look at function objects.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Function objects**, also known as **functors**, are used for generating,
    testing, and operating on data. If you declare an object as a functor, you can
    use that object as one would use a function call. Oftentimes, the algorithms in
    the STL need a parameter to perform their designated tasks. Functors tend to be
    a useful way to assist in performing those tasks. In this section, we will learn
    about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal and external iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **functor** is a functional programming paradigm in which a transformation
    is performed on a structure while the structure is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we take an integer slice, `intSlice`, and lift the slice into
    a functor. `IntSliceFunctor` is an interface that includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fmt.Stringer`, which defines the string format for the value with its representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map(fn func(int int) IntSliceFunctor` – this mapping applies `fn` to each
    element in our slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A convenience function, `Ints() []int`, which allows you to get the `int` slice
    the functor holds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we have our lifted slice, we can perform operations on our newly created
    functor. In our example, we perform a square operation and a modulus three operation.
    The following is an example implementation of a functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'During the execution of this code, we can see that our function manipulation
    with functors worked as expected. We took our initial `intSlice`, lifted it into
    a functor, applied a square to each value with `squareFunc`, and applied `%3`
    to each value with `modThreeFunc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/894922cf-f5cd-4fdb-bdc0-3d3673dc0c35.png)'
  prefs: []
  type: TYPE_IMG
- en: Functors are a very powerful language construct. A functor abstracts a container
    in a way that is easily modifiable. It also allows for a separation of concerns—for
    instance, you can separate iteration logic from calculation logic, functors can
    be parameterized more simply, and functors can also be stateful.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed iterators in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency*. Iterators are objects that allow the traversal of
    lists and other containers. Iterators are often implemented as part of a container''s
    interface, which is an important method for a programmer. These are often split
    into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Internal iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover what these categories are in more detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Internal iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internal** **iterators** are represented as higher-order functions (often
    utilizing anonymous functions, as we saw in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency*). Higher-order functions take functions as arguments
    and return functions as outputs. Anonymous functions are functions that aren''t
    bound to identifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal iterators often map themselves to applying a function to every element
    in a container. This can be represented by a variable identifier or it can be
    represented anonymously. The authors of the language have mentioned that apply/reduce
    are possible in Go, but shouldn't be used (this is because `for` loops tend to
    be preferred in Go). This pattern follows along with Go's motto of *simple is
    better than clever*.
  prefs: []
  type: TYPE_NORMAL
- en: External iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**External iterators** are used in order to access elements within an object
    and point to the next element in the object (known as element access and traversal,
    respectively). Go uses the `for` loop iterator heavily. The `for` loop is Go''s
    only natural looping construct, and greatly simplifies program construction. A
    `for` loop is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see our output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12e62017-4ec8-4562-9e54-15c3dac96969.png)'
  prefs: []
  type: TYPE_IMG
- en: Our `for` loop iterator is simple, but it proves a strong point—sometimes, simplicity
    works as expected for difficult problem sets.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generators** return the subsequent value in a sequence when a function is
    called. As you can see in the following code block, anonymous functions can be
    used to implement the generator iterator pattern in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When `incrementCounter()` is called, the integer represented in the function
    is incremented. Being able to use anonymous functions concurrently in this manner
    is a big draw for a lot of programmers coming to Go from other languages. It gives
    a succinct method for drawing on the concurrency of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **implicit iterator** gives the programmer an easy way to iterate through
    the elements that are stored within a container. This is often created with a
    built-in range in Go. The built-in range allows you to iterate through your container.
    The following is a code snippet implementing an implicit iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the resulting output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d46622c2-5514-4696-a784-1fa92aed1b26.png)'
  prefs: []
  type: TYPE_IMG
- en: This output shows our iteration through the range of our `stringExample` variable.
    The `range` function is a very powerful construct that is concise and easy to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use STL practices in Go. We also learned
    how to utilize standard programming algorithms with respect to Go, learned about
    how containers store data, learned how functions work in Go, and looked at how
    to use iterators properly. As we continue on our Go performance journey, we should
    always keep these algorithms, containers, functors, and iterators at the forefront
    of our choices for writing code. Doing so will help us to write idiomatic Go quickly
    and concisely. Choosing the proper combination of these STL idioms will help us
    to manipulate the data that we have in our hands faster and more effectively.
    In the next chapter, we will learn how to compute vectors and matrices in Go.
  prefs: []
  type: TYPE_NORMAL
