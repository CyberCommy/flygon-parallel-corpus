- en: Chapter 4. Project 4 – Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the most successful apps on the app stores are games. They proved to
    be really popular as mobile users tend to play all sort of games while commuting,
    in waiting rooms, when traveling, or even when relaxing at home. It is a fact
    that mobile users are more inclined to pay for a game than for any other kind
    of app in the market as the perceived value is higher most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Modern games are usually built in powerful gaming engines such as Unity or Unreal,
    as they provide a wide range of tools and frameworks to work with sprites, animations,
    or physics. But the reality is that great games can also be built in React Native
    due to its native capabilities. Moreover, React Native has introduced many web
    and mobile app programmers into game development as it offers them a familiar
    and intuitive interface. Of book, there are some concepts in game development
    which need to be understood in order to make the most of the library when building
    games. Concepts like sprites, ticks, or collisions are small hurdles, which may
    need to be overcome by non-game developers before building a game.
  prefs: []
  type: TYPE_NORMAL
- en: The game will be built for both iOS and Android, and will use a limited number
    of external libraries. Redux, the state management library, was chosen to help
    calculate the position of every sprite on each frame.
  prefs: []
  type: TYPE_NORMAL
- en: We will use some custom sprites and add a sound effect to notice each time the
    score is increased. One of the main challenges when building a game is making
    sure the sprites are rendered responsively, so different devices will show the
    game with the same proportions providing the same game experience across different
    screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: This game will be designed to be played in portrait mode only.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game we will build in this lesson has simple mechanics:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to help a parrot fly between rocks in a cave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tapping the screen will result in the parrot flying higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gravity will pull the parrot toward the ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any collision between the parrot and the rocks or the ground will result in
    the end of the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The score will be increased every time the parrot flies through a group of rocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kind of game is very well suited to being built with React Native, as it
    doesn't really need complex animations or physics capabilities. All we need to
    be sure of is that we move every sprite (graphics component) on the screen at
    the correct time to create the feeling of continuous animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the initial screen for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screen presents the logo and instructions about how to get the game started.
    In this case, a simple tap will start up the game mechanics causing the parrot
    to fly forward and up on every tap.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The player must help our parrot to fly through the rocks. Each time a set of
    rocks is passed, the player will get one point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make it more difficult, the heights of the rocks will vary forcing the parrot
    to fly higher or lower to pass through the rocks. If the parrot collides with
    a rock or the ground, the game will stop and the final score will be presented
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview](Images/04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this point, the user will be able to restart the game by tapping again on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it nicer and easier to play, tapping can be done anywhere on the screen,
    causing a different effect depending on which screen the user is on:'
  prefs: []
  type: TYPE_NORMAL
- en: On the initial screen tapping will start up the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-game tapping will result in the parrot flying higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the **GAME OVER** screen tapping will restart the game and reset the score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be observed, it will be a very simple game but, due to this, easily extendable
    and fun to play. One import aspect when building this kind of app is counting
    with a nice set of graphics. For this matter, we will download our assets from
    one of the multiple game assets markets, which can be found online (most game
    assets cost a small amount of money although free assets can be found every now
    and then).
  prefs: []
  type: TYPE_NORMAL
- en: 'The technical challenges for this game lie more in how the sprites will be
    moved over time than on a complex state to be maintained. Despite this, we will
    use Redux to keep and update the app''s state as it is a performant and well-known
    solution. Besides revisiting Redux, we will review the following topics in this
    lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling animated sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting colliding sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute positioning in different screen resolutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sprites are the graphics used by the games, normally grouped into one or several
    images. Many game engines include tools to split and manage those graphics in
    a convenient way, but this is not the case in React Native. Since it was designed
    with a different kind of app having in mind, there are several libraries supporting
    React Native in the task of dealing with sprites, but our game will be simple
    enough not to need any of these libraries, so we will store one graphic in each
    image and we will load them separately into the app.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to build the game, let's get acquainted with the graphics we
    will load, as they will be the building blocks for the whole app.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using a `<Text/>` component to display the score in our game, we
    will use sprites for a more attractive look. These are the images we will use
    to represent the user''s score:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Numbers](Images/04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned, all these graphics will be stored in separate images (named `0.png`
    to `9.png`) due to React Native's lack of sprite splitting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a large background to make sure it will fit all screen sizes. In this
    lesson, we will use this sprite as a static graphic although it could be easily
    animated to create a nice parallax effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Background](Images/04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From this background, we will take a piece of ground to animate.
  prefs: []
  type: TYPE_NORMAL
- en: Ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ground will be animated in a loop to create a constant feeling of velocity.
    The size of this image needs to be larger than the maximum screen resolution we
    want to support, as it should be moved from one side of the screen to the opposite.
    At all times, two ground images will be displayed, one after the other to ensure
    at least one of them is shown on the screen during the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ground](Images/04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The moving rocks are the obstacles our parrot needs to pass. There will be
    one on the top and one on the bottom and both will be animated at the same speed
    as the ground. Their height will vary for each pair of rocks but always keep the
    same gap size between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rocks](Images/04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our `images` folder, we will have `rock-up.png` and `rock-down.png` representing
    each sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Parrot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use two different images for our main character so we can create an
    animation displaying when the user has tapped on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parrot](Images/04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first image will be displayed when the parrot is moving down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parrot](Images/04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This second image will be shown every time the user presses the screen to move
    the parrot up. The images will be named `parrot1.png` and `parrot2.png`.
  prefs: []
  type: TYPE_NORMAL
- en: The Home Screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the home screen, we will display two images: a logo and some instructions
    about how to get the game started. Let''s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Home Screen](Images/04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The instructions to start the game just point out that tapping will get the
    game started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Home Screen](Images/04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Game Over Screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the parrot hits a rock or the ground, the game will end. Then, it is time
    to display a game over sign and a reset button to get the game started again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game Over Screen](Images/04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although the entire screen will be touchable to get the game restarted, we
    will include a button to let the user know that tapping will result in the game
    restarting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game Over Screen](Images/04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This image will be stored as `reset.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the full list of images we will have in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Game Over Screen](Images/04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we know the list of images we will use in our game. Let's take a look at
    the whole folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `birdGame` and will be available for iOS and Android devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As this one is a simple game, we will only need one screen in which we will
    position all our sprites moving, showing, or hiding them depending on the state
    of the game, which will be managed by Redux. Therefore, our folder structure will
    be in line the standard Redux apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the folder structure](Images/04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `actions` folder will only contain one file as there are only three actions
    which may happen in this game **(** `start` **,** `tick`, and `bounce`). There
    is also a `sounds` folder to store the sound effect which will be played every
    time the parrot passes a pair of rocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the folder structure](Images/04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For each sprite, we will create a component so we can move it, show it, or
    hide it easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the folder structure](Images/04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, only one reducer will be needed to process all our actions. We will
    also create two helper files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constants.js`: This is where we will store helper variables for dividing the
    height and the width of the screen for the device playing the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sprites.js`: This stores all the functions which will calculate how the sprites
    should be positioned in each frame to create the required animations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.js`will serve as the entry point for both iOS and Android and will be
    responsible to initialize Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the folder structure](Images/04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The rest of the files are generated by React Native's CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now review the `package.json` file we will need to set the dependencies
    up in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Apart from Redux libraries, we will import `react-native-sound`, which will
    be in charge of playing any sounds in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running `npm install`, we will have our app ready to start coding. As
    happened in previous apps, the entry point for our messaging app will be the same
    code both in `index.ios.js` for iOS and in `index.android.js` for Android, but
    both will delegate the initialisation logic to `src/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`src/main.js` is responsible for initializing Redux and will set `GameContainer`
    as the root component in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use `GameContainer` as the root of the component tree in our app. As a regular
    Redux app, a `<Provider />`component is in charge of supplying the store to all
    the components which require reading or modifying the application state.
  prefs: []
  type: TYPE_NORMAL
- en: GameContainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GameContainer` is responsible for starting up the game once the user taps
    the screen. It will do this using `requestAnimationFrame()`--one of the custom
    timers implemented in React Native.'
  prefs: []
  type: TYPE_NORMAL
- en: '`requestAnimationFrame()` is similar to `setTimeout()`, but the former will
    fire after all the frame has flushed, whereas the latter will fire as quickly
    as possible (over 1000x per second on a iPhone 5S); therefore, `requestAnimationFrame()`
    is more suited for animated games as it deals only with frames.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As happens with most animated games, we need to create a loop to animate the
    sprites in the screen by calculating the next position of each element on each
    frame. This loop will be created by a function named `nextFrame()` inside our
    `GameContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function will be aborted if the property `gameOver` is set to `true`. Otherwise,
    it will trigger the action `tick()` (which calculates how the sprites should be
    moved on to the next frame, based on the elapsed time) and finally calls itself
    through `requestAnimationFrame()`. This will keep the loop in the game to animate
    the moving sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of book, this `nextFrame()` should be called at the start for the first time,
    so we will also create a `start()` function inside `GameContainer` to get the
    game started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `start` function makes sure there is no animation started by calling `cancelAnimationFrame()`.
    This will prevent any double animations being performed when the user resets the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the functions trigger the `start()` action, which will just set a flag
    in the store to notice the game has started.
  prefs: []
  type: TYPE_NORMAL
- en: We want to start the game by moving the parrot up, so the user has the time
    to react. For this, we also call the `bounce()` action.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we start the animation loop by passing the already known `nextFrame()`
    function as a callback of `requestAnimationFrame()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also review the `render()` method we will use for this container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It may be lengthy, but actually, it's a simple positioning of all the visible
    elements on the screen while wrapping them in a `<TouchableOpacity />` component
    to capture the user tapping no matter in which part of the screen. This `<TouchableOpacity
    />` component is actually not sending any feedback to the user when they tap the
    screen (we disabled it by passing `activeOpacity={1}` as a prop) since this feedback
    is already provided by the parrot bouncing on each tap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have used React Native's `<TouchableWithoutFeedback />` for this matter,
    but it has several limitations which would have harmed our performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided `onPress` attribute just defines what the app should do when the
    user taps on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: If the game is active, it will bounce the parrot sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is on the game over screen it will restart the game by calling the
    `start()` action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other children in the `render()` method are the graphic elements in our
    game, specifying for each of them, their position and size. It''s also important
    to note several points:'
  prefs: []
  type: TYPE_NORMAL
- en: There are two `<Ground />` components because we need to continuously animate
    it in the *x* axis. They will be positioned one after the other horizontally to
    animate them together so when the end of the first `<Ground />` component is shown
    on screen, the beginning of the second will follow creating the sense of continuum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The background is not contained in any custom component but in `<Image />`.
    This is because it doesn't need any special logic being a static element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some positions are multiplied by factor variables (`W` and `H`). We will take
    a deeper look at these variables in the constants section. At this point, we only
    need to know that they are variables helping in the absolute positioning of the
    elements taking into account all screen sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now put all these functions together to build up our `<GameContainer
    />`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We added three more ES6 and React lifecycle methods to this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`super()`: The constructor will save an attribute named `animationFrameId`
    to capture the ID for the animation frame in which the `nextFrame` function will
    run and also another attribute named `time` will store the exact time at which
    the game was initialized. This `time` attribute will be used by the `tick()` function
    to calculate how much the sprites should be moved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUpdate()`: This function will be called every time new props
    (positions and sizes for the sprites in the game) are passed. It will detect when
    the game must be stopped due to a collision so the game over screen will be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate()`: This performs another check to avoid re-rendering
    the game container if the game has ended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the functions are Redux related. They are in charge of connecting
    the component to the store by injecting actions and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mapStateToProps()`: This gets the data for all the sprites in the store and
    injects them into the component as props. The sprites will be stored in an array
    and therefore they will be accessed by index. On top of these, the `Score`, a
    flag noting if the current game is over, and a flag noting if the game is in progress
    will also be retrieved from the state and injected into the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapStateActionsToProps()`: This will inject the three available actions (`tick`,
    `bounce`, and `start`) into the component so they can be used by it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accessing the sprites data by index is not a recommended practice as indexes
    can change if the number of sprites grows, but we will use it like this in this
    app for simplicity reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned before, only three Redux actions will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tick()`: To calculate the next position of the sprites on the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bounce()`: To make the parrot fly up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start()`: To initialize the game variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means our `src/actions/index.js` file should be very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the `tick()` action needs to pass a payload: the time it passed since
    the last frame.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have a very limited amount of actions, our reducer will also be fairly
    simple and will delegate most of the functionality to the sprites helper functions
    in the `src/sprites.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `start()` function only needs to set the `isStarted` flag to `true`, as
    the initial state will have it set to `false` by default. We will reuse this initial
    state every time the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: '`bounce()` will use the `bounceParrot()` function from the sprites module to
    set a new direction for the main character.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important changes will happen when the `tick()` function is triggered,
    as it needs to calculate the positions of all moving elements (through the `moveSprites()`
    function), detect if the parrot has collided with any static elements (through
    the `checkForCollision()` function), and update the score in the store (through
    the `getUpdatedScore()` function).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, most of the game's functionality is delegated to the helper functions
    inside the sprites module, so let's take a deeper look into the `src/sprites.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The Sprites Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of the sprites module is formed by an array of sprites and several
    exported functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This module begins by loading the sound effect we will play when the parrot
    passes a set of rocks to give feedback to the user about the increment in their
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we define some heights for several sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '`heightOfRockUp`: This is the height of the rock which will appear in the upper
    part of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heightOfRockDown`: This is the height of the rock which will show in the lower
    part of the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heightOfGap`: We will create an invisible view between the upper and the lower
    rock to detect when the parrot has passed each set of rocks so the score is updated.
    This this gap''s height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heightOfGround`: This is a static value for the height of the ground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each other item in this module plays a role in moving or positioning the sprites
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The Sprites Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the array in charge of storing all the sprite's positions and sizes
    at a given time. Why are we using an array for storing our sprites instead of
    a hash map (Object)? Mainly for extensibility; although a hash map would make
    our code noticeably more readable, if we want to add new sprites of an existing
    type (as it happens with the `ground` sprite in this app) we would need to use
    artificial keys for each of them despite being the same type. Using an array of
    sprites is a recurrent pattern in game development which allows to decouple the
    implementation from the list of sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we want to move a sprite, we will update its position in this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The array will store the initial values for positioning and sizing all the moving
    sprites in the game.
  prefs: []
  type: TYPE_NORMAL
- en: prepareNewRockSizes()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function randomly calculates the size of the next upper and lower rock
    together with the height of the gap between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that this function only calculates the heights for the
    new set of rocks but doesn't create them. This is just a preparation step.
  prefs: []
  type: TYPE_NORMAL
- en: getRockProps()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The helper functions to format the `position` and `size` attributes of a rock
    (or `gap)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: moveSprites()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the main function as it calculates the new position for each sprite
    stored in the sprites array. Game development relies in physics to calculate the
    position for each sprite in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to move an object to the right side of the screen, we
    will need to update its `x` position a number of pixels. The more pixels we add
    to the object's `x` attribute for the next frame, the faster it will move (`sprite.x
    = sprite.x + 5;` moves `sprite` five times faster than `sprite.x = sprite.x +
    1;`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following example, the way we calculate the new position
    for each sprite is based on three factors: the current position of the sprite,
    the time that has passed since the last frame (`elapsedTime`), and the gravity/velocity
    of the sprite (`i.e. sprite.velocity.y + elapsedTime * gravity`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will use the helper function `getRockProps` to get the new
    sizes and positions for the rocks. Let''s take a look at how the `moveSprites`
    function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the next position for a sprite is, most of the time, basic addition
    (or subtraction). Let''s take, for example, how the parrot should move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The parrot will only move vertically, basing its speed on gravity, so the `x`
    attribute will always stay fixed for it while the `y` attribute will change according
    to the function `sprite.position.y +` `sprite.velocity.y * elapsedTime +` `0.5
    * gravity * elapsedTime * elapsedTime` which, in summary, adds the elapsed time
    and the gravity in different factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculations for how the rocks should move are a little more complex, as
    we need to take into account every time the rocks disappear from the screen (`if
    (sprite.position.x > 0 - sprite.size.width)`). As they have been passed, we need
    to recreate them with different heights (`rockPosition = { x: 100, y: getRockProps(sprite.type).y
    }`).'
  prefs: []
  type: TYPE_NORMAL
- en: We have the same behavior for the ground, in terms of having to recreate it
    once it abandons the screen completely (`if (sprite.position.x > -97)`).
  prefs: []
  type: TYPE_NORMAL
- en: bounceParrot()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only task for this function is changing the velocity of the main character,
    so it will fly up reversing the effect of gravity. This function will be called
    whenever the user taps on the screen while the game is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's a simple operation in which we take the parrot's sprite data from the `sprites`
    array; we change its velocity on the **y** axis to a negative value so that the
    parrot moves upwards.
  prefs: []
  type: TYPE_NORMAL
- en: checkForCollision()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`checkForCollision()` is responsible for identifying if any of the rigid sprites
    have collided with the parrot sprite, so the game can be stopped. It will use
    `hasCollided()` as a supporting function to perform the required calculations
    on each specific sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, we assume that all sprites have a rectangular shape (even though
    rocks grow thinner towards the end) because the calculation would be a lot more
    complex if we considered different shapes.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `checkForCollision()` is just looping through the `sprites` array
    to find any colliding sprite, `hasCollided()` checks for collisions based on the
    sprite size and position. In just an `if` statement, we compare the boundaries
    of a sprite and the parrot's sprite to see if any of those boundaries are occupying
    the same area of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: getUpdatedScore()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last function in the sprites module will check if the score needs to be
    updated based on parrot position relative to the gap position (the gap between
    the upper and the lower rock is also counted as a sprite):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: An `if` statement checks if the parrot's position in the **x** axis has surpassed
    the gap (`gapXPosition + gapWidth`). When this happens, we play the sound we created
    in the header of the module (`const coinSound = new sound(“coin.wav", sound.MAIN_BUNDLE);`)
    by calling its `play()` method. Moreover, we will increase the `score` variable
    and prepare a new set of rocks to be rendered when the current ones leave the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw the variables `W` and `H`. They represent one part of the screen
    if we divided it into 100 parts. Let''s take a look at the `constants.js` file
    to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`W` can be calculated as the total width of the device''s screen divided by
    `100` units (as percentages are easier to reason about when positioning our sprites).
    The same goes for `H`; it can be calculated by dividing the total height by `100`.
    Using these two constants, we can position and size our sprites relative to the
    size of the screen, so all screen sizes will display the same ratios for positions
    and sizes.'
  prefs: []
  type: TYPE_NORMAL
- en: These constants will be used in all the visual components requiring responsive
    capabilities so they will show and move different depending on the screen size.
    This technique will ensure the game is playable even in small screens as the sprites
    will be resized accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on now to the components which will be displayed inside the `<GameContainer
    />`.
  prefs: []
  type: TYPE_NORMAL
- en: Parrot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main character will be represented by this component, which will comprise
    of two different images (the same parrot with its wings up and down) driven by
    the `Y` position property passed by `<GameContainer />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a state variable named `wings` to pick which image the parrot will be--when
    it is flying up the image with the wings down will be displayed while the wings
    up will be shown when flying down. The way this will be calculated is based on
    the position of the bird on the **y** axis passed as a property from the container:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `Y` position is lower than the previous `Y` position means the bird is
    going down and therefore the wings should be up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `Y` position is higher than the previous `Y` position means the bird
    is going up and therefore the wings should be down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the parrot is fixed to `12 * W` both for the `height` and `width`
    as the sprite is a square and we want it to be sized relative to the width of
    each screen device.
  prefs: []
  type: TYPE_NORMAL
- en: RockUp and RockDown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sprites for the rocks have no logic on them and are basically `<Image />`
    components positioned and sized by the parent component. This is the code for
    `<RockUp />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The height and the width will be calculated by the following formulae: `this.props.width
    * W` and `this.props.height * H`. This will size the rock relative to the device''s
    screen and the provided height and width.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `<RockDown />` is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building the ground component is similar to the rock sprites. An image rendered
    in the proper position and size will be sufficient for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we will use `H` to relatively positioning the ground image.
  prefs: []
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We decided to use number images to render the score, so we will need to load
    them and pick the appropriate digits depending on the user''s score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are doing the following in the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the score to a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the string into a list of digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning this list of digits into a list of images using the supporting `getSource()`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the limitations in React Native `<Image />` is that its source cannot
    be required as a variable. Hence, we are using this small trick of retrieving
    the source from our `getSource()` method, which actually acquires all the possible
    images and returns the correct one through a `switch`/`case` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The start screen includes two images:'
  prefs: []
  type: TYPE_NORMAL
- en: A logo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A start button explaining how to start up the game (tapping anywhere on the
    screen)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are using our `H` and `W` constants again to ensure the elements are positioned
    in the right place on every device screen.
  prefs: []
  type: TYPE_NORMAL
- en: GameOver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the parrot collides with a rock or the ground, we should display the game
    over screen. This screen only contains two images:'
  prefs: []
  type: TYPE_NORMAL
- en: A game over sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button to restart the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the game over sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move on to the reset the game button.
  prefs: []
  type: TYPE_NORMAL
- en: StartAgain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actually, the reset button is only a sign as the user will be able to tap not
    only on the button but anywhere on the screen to get the game started. In any
    case, we will position this button properly on every screen using the *H* and
    *W* constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games are a very special kind of app. They are based on displaying and moving
    sprites on the screen, depending on the time and the user interaction. That is
    why we spent most of this lesson explaining how we could easily display all the
    images in the most performant way and how to position and size them.
  prefs: []
  type: TYPE_NORMAL
- en: We also reviewed a common trick to position and size sprites relatively to the
    height and width of the device screen.
  prefs: []
  type: TYPE_NORMAL
- en: Despite not being designed for games specifically, Redux was used to store and
    distribute the sprite's data around the components in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a general level, we proved that React Native can be used to build performant
    games and, although it lacks game-specific tooling, we can produce a very readable
    code which means it should be easy to extend and maintain. In fact, some very
    easy extensions can be created at this stage to make the game more fun and playable:
    increase speed after passing a specific amount of obstacles, reduce or increase
    the gap size, show more than one set of rocks on screen at once, and so.'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we've come to the end of this learning journey. I hope you'd a smooth
    journey and gained a lot of knowledge on React.
  prefs: []
  type: TYPE_NORMAL
- en: I wish you all the best for your future projects. Keep learning and exploring!
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name the graphics that are used by the games, normally grouped into one or several
    images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ground
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sprites
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether the following statement is True or False: Sprites are the graphics
    used by the games, normally grouped into one or several images. Many game engines
    include tools to split and manage those graphics in a convenient way, but this
    is not the case in React Native.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'State whether the following statement is True or False: The sprites array is
    the array in charge of storing all the sprite''s positions and sizes at a given
    time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which functions are in charge of connecting the component to the store by injecting
    actions and attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ________ is responsible for starting up the game once the user taps the screen.
    It will do this using `requestAnimationFrame()`--one of the custom timers implemented
    in React Native.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nextFrame()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cancelAnimationFrame()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameContainer`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mapStateToProps(state)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
