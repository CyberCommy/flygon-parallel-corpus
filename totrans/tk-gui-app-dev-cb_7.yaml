- en: Canvas and Graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the coordinate system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and arrows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing text on a canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding shapes to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding items by their position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving canvas items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions between items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting items from a canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding events to canvas items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a canvas into a PostScript file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we covered several recipes for the standard Tkinter widget.
    However, we skipped the **Canvas** widget because it offers plenty of graphical
    capabilities, and it deserves a dedicated chapter by itself to dive into its common
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: A canvas is a rectangular area where you can not only display text and geometric
    shapes, such as lines, rectangles, or ovals, but also nest other Tkinter widgets.
    These objects are called **canvas items**, and each one has a unique identifier
    that allows us to manipulate them before they are initially displayed on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the methods of the `Canvas` class with interactive samples, which
    will help us to identify frequent patterns that could be translated to the applications
    we want to build.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To draw graphic items on a canvas, we will need to specify their position using
    a **coordinate system**. Since a canvas is a two-dimensional space, points will
    be notated by their coordinates on the horizontal and vertical axes—commonly labeled
    *x* and *y* respectively.
  prefs: []
  type: TYPE_NORMAL
- en: With a simple application, we can easily illustrate how to locate these points
    in relation to the origin of the coordinate system, placed in the upper-left corner
    of the canvas area.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following program contains an empty canvas and a label that shows the location
    of the cursor on the canvas; you can move the cursor to see what position it is
    placed in, giving clear feedback on how the x and y coordinates increment or decrement,
    depending on the direction you move the mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Canvas` instance is created like any other Tkinter widget, that is, by
    first passing the parent container and the additional configuration options as
    keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows a point composed of the perpendicular projections
    of each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: The x coordinate corresponds to the distance on the horizontal axis and increments
    its value when you move the cursor from left to right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The y coordinate is the distance on the vertical axis and increments its value
    when you move the cursor from up to down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/43cd19e1-fd63-49cd-8d6f-dbca306cb2c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you might have noticed in the preceding screenshot, these coordinates directly
    map to the `x` and `y` attributes of the `event` instance passed to the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This happens because these attributes are calculated in respect to the widget
    that the event is bound to, in this case, the `<Motion>` sequence.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The canvas surface can also display items with negative values in their coordinates.
    Depending on the item size, they can be partially shown on the top or left borders
    of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, if an item is placed at a point where any of its coordinates
    is greater than the canvas size, it may partially fall outside the bottom or right
    borders.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing lines and arrows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic actions you can perform with a canvas is drawing segments
    from one point to another. Although it is possible to directly draw polygons using
    other methods, the `create_line` method of the `Canvas` class has enough options
    to understand the basics of displaying items.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will build an application that allows us to draw lines by
    clicking on the canvas. Each line will be displayed by clicking first on the point
    that will determine the line start, and a second time to set the line end.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be also able to specify some appearance options, such as color and
    width:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/917ecb33-f662-47ac-9ef6-7cb7d79595a2.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `App` class will be responsible for creating an empty canvas and handling
    mouse click events.
  prefs: []
  type: TYPE_NORMAL
- en: The information on the line options will be retrieved from the `LineForm` class.
    The approach of separating this component into a different class helps us to abstract its
    implementation details and focus on how to work with the `Canvas` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of brevity, we omit the implementation of the `LineForm` class
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete code sample in the `chapter7_02.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we want to handle the mouse clicks on the canvas, we will bind the `draw()`
    method to this type of event. We will also define the `line_start` field
  prefs: []
  type: TYPE_NORMAL
- en: 'to keep track of the start point of each new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw()` method contains the main logic of our application. The first click
    on each new line serves to determine the origin and does not perform any drawing
    operation. These coordinates are retrieved from the `event` object passed to the
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If `line_start` already has a value, we retrieve the origin point and pass
    it with the coordinates of the current event to draw the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `canvas.create_line()` method takes four arguments, where the first two
    are the horizontal and vertical coordinates of the line start and the last two
    are the coordinates corresponding to the line end.
  prefs: []
  type: TYPE_NORMAL
- en: Writing text on a canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case we want to write some text on a canvas, we do not need to use an additional
    widget, such as a Label. The `Canvas` class includes the `create_text` method
    to display a string that can be manipulated the same as any other type of canvas
    item.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use the same formatting options that we can specify to
    add style to the text of regular Tkinter widgets, such as color, font family,
    and size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will connect an Entry widget with the contents of a text
    canvas item. While the input will have the standard appearance, the text on the
    canvas will have a customized style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/7fcc52e1-d1b6-43fe-a9ef-042f22b3b08f.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The text item will be initially displayed using the `canvas.create_text()` method,
    with some additional options to use a Consolas font and a blue color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamic behavior of the text item will be implemented using `StringVar`.
    By tracing this Tkinter variable, we can modify the contents of the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can try out this program by typing some arbitrary text on the entry input
    and noticing how it automatically updates the text on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we initialize the `Entry` instance with its `StringVar` variable and
    the Canvas widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we place the widgets by calling the methods for the Pack geometry manager.
    Note the importance of calling `update()` on the root window, because we want
    to force Tkinter to process all the pending changes, in this case rendering the
    widgets before the `__init__` method continues its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We did this because the next step will be to calculate the canvas dimensions,
    and until the geometry manager has displayed the widget, it will not have the
    real values of its width and height.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we can safely retrieve the canvas dimensions. Since we want to align
    the text item with the center of the canvas, we divide the values of width and
    height by half.
  prefs: []
  type: TYPE_NORMAL
- en: 'These coordinates determine the position of the item, and together with the
    styling options, are passed to the `create_text()` method. The `text` keyword
    argument is a common option used here, but we will omit it because it will be
    dynamically set when `StringVar` changes its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The identifier returned by `create_text()` is stored in the `text_id` field.
    It will be used on the `write_text()` method to reference the item, which is invoked
    by the tracing mechanism on write operations of the `var` instance.
  prefs: []
  type: TYPE_NORMAL
- en: To update the `text` option inside the `write_text()` handler, we call the `canvas.itemconfig()`
    method with the item identifier as the first argument, and then the configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we use the `text_id` field that we stored while initializing our
    `App` instance and the contents of `StringVar` via its `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We defined our `write_text()` method so that it can receive a variable number
    of arguments even though we do not need them, because the `trace()` method of
    Tkinter variables passes them to the callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `canvas.create_text()` method has many other options to customize the created
    canvas items.
  prefs: []
  type: TYPE_NORMAL
- en: Placing the text by its upper-left corner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `anchor` option allow us to control where to place the item relative to
    the position passed as its first argument to `canvas.create_text()`. By default,
    this option value is `tk.CENTER`, which means that the text widget is centered
    on these coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to place the text on the upper-left corner of the canvas, you can
    do so by passing the `(0, 0)` position and setting the `anchor` option to `tk.NW`,
    aligning the origin to the north-west of the rectangular area the text is placed
    within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/51d7f33e-6edb-4b2d-b763-04ebf4508af2.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting line wrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the contents of a text item will be displayed in a single line.
    The `width` option allows us to define a maximum line width, which wraps lines
    longer than that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we write `Hello, world!` on the entry, the part of the text that
    exceeds the line width will be displayed in a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/689721c7-6307-4dac-b556-28b3dbb199ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding shapes to the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will cover three of the standard canvas items: rectangles,
    ovals, and arcs. All of them are displayed within a bounding box, so the use of
    only two points is necessary to set their position: the upper-left corner of the
    box and the lower-right corner.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following application allows users to freely draw some items on the canvas
    by selecting its type with three buttons—each one to select the corresponding
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Item''s positions are determined by clicking first on the canvas to set the
    upper-left corner of the box the item will be contained in, and then clicking
    to set the lower-left corner of this box and draw the item with some predefined
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/dff4558b-fd6c-4ff5-b8c6-76e02e2dee61.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application stores the currently chosen type of item, which is selected
    with one of the three buttons placed on a frame below the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking with the primary mouse button on the canvas triggers the handler that
    stores the position of the first corner of the new item, and once it is clicked
    again, it reads the value of the selected shape to conditionally draw the corresponding
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To dynamically select the type of item drawn by clicking on the canvas, we will
    create a button for each one of the shapes by iterating over the `shapes` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define each callback command using the `partial` function from the `functools`
    module. Thanks to this, we can freeze the `Button` instance and the current shape
    of the loop as arguments to the callback of each button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `set_selection()` callback marks the clicked button with the `SUNKEN` relief
    and stores the selection in the `shape` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other widget siblings are configured with the standard relief (`RAISED`)
    by navigating to the parent, available in the `master` field of the current widget,
    and then retrieving all the children widgets with the `winfo_children()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `draw_item()` handler stores the coordinates of the first click of each
    pair of events to draw the item when the canvas is clicked again—exactly like
    we previously did in the *Drawing lines and arrows* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the value of the `shape` field, one of the following methods is
    invoked to display the corresponding item type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas.create_rectangle(x0, y0, x1, y1, **options)`: Draws a rectangle whose
    upper-left corner is placed at **(x0, y0)** and lower-right corner at **(x1, y1)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/9bc92787-61f1-4eed-9c2c-1f7b422cb606.png)'
  prefs: []
  type: TYPE_IMG
- en: '`canvas.create_oval(x0, y0, x1, y1, **options)`: Draws an ellipse that fits
    into the rectangle from **(x0, y0)** to **(x1, y1)***:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/f9490d06-adc3-4f5e-872c-0fb600265970.png)'
  prefs: []
  type: TYPE_IMG
- en: '`canvas.create_arc(x0, y0, x1, y1, **options)`: Draws a quarter of the ellipse
    that would fit into the rectangle from **(x0, y0) **to **(x1, y1)**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](images/3abfc301-8ed6-4ed3-bacf-e0a8df5746e9.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Drawing lines and arrows* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding items by their position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Canvas` class includes methods to retrieve item identifiers that are close
    to a canvas coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful because it saves us from storing each reference to a canvas
    item and then calculating their current position to detect which ones are within
    a specific area or closest to a certain point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application creates a canvas with four rectangles, and changes
    the color of the one that is closest to the mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/72906402-5615-46ca-8bfb-b05a0f3b46b0.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find the closest item to the pointer, we pass the mouse event coordinates
    to the `canvas.find_closest()` method, which retrieves the identifier of the item
    that is closest to the given position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once there is at least one item in the canvas, we can safely assume that this
    method will always return a valid item identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During application initialization, we create the canvas and define the `current`
    field to store a reference to the current highlighted item. We also handle the
    `"<Motion>"` events on the canvas with the `mouse_motion()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create four items with a specific arrangement so that we can easily
    visualize the item that is closest to the mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouse_motion()` handler sets the color of the current item back to `blue` and
    saves the item identifier of the new one, which is closer to the event coordinates.
    Finally, the `fill` color of this item is set to `yellow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Initially, there are no errors when `mouse_motion()` is called for the first
    time and the `current` field is still `None`, since it is also a valid input parameter
    to `itemconfig()`; it just does not perform any action on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Moving canvas items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once placed, canvas items can be moved to a certain offset, without having to
    specify the absolute coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: When moving canvas items, it is usually relevant to calculate its current position,
    for instance, to determine whether they are placed inside a concrete canvas area,
    and restrict their movements so that they always stay within that area.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our example will consist of a simple canvas with a rectangle item, which can
    be moved horizontally and vertically using the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this item from moving outside of the screen, we will limit its movements
    inside the canvas dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To handle the arrow keyboard events, we bind the `"<KeyPress>"` and `"<KeyRelease>"`
    sequences to the application instance. The currently pressed key symbols are stored
    in the `pressed_keys` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This approach is preferred instead of separately binding the `"<Up>"`, `"<Down>"`,
    `"<Right>"`, and `"<Left>"` keys, because that would call each handler only when
    Tkinter processes the input keyboard events, causing the item to "jump" from one
    position to the next one rather than moving it smoothly on the horizontal and
    vertical axes.
  prefs: []
  type: TYPE_NORMAL
- en: The last sentence of the initialization of the `App` instance is the call to
    `process_movements()`, which starts processing the movement of the canvas item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method calculates the offset in each axis that the item should be displaced.
    Depending on the contents of the `pressed_keys` dictionary, the `speed` value
    is added or subtracted on each component of the coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After this, we retrieve the current item position by calling `canvas.coords()`
    and unpacking the couple of points that form the bounding box into four variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The center of the item is calculated by adding the `x` and `y` components of
    the upper-left corner to half of its width and height. This result, plus the offset
    in each axis, corresponds to the final position of the item after it is moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we check whether this final item position is within the canvas area.
    To do so, we take advantage of Python''s support for chaining comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, this method schedules itself with a delay of 10 milliseconds by calling
    `self.after(10, self.process_movements)`. Thus, we achieve the effect of having
    a "custom mainloop" inside Tkinter's mainloop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might wonder why we did not call `after_idle()` instead of `after()` to
    schedule the `process_movements()` method.
  prefs: []
  type: TYPE_NORMAL
- en: It might look a valid approach since there are no other events to process, apart
    from redrawing our canvas and handling keyboard inputs, so there is no need to
    add a delay between calls to `process_movements()` if there are no pending GUI
    events.
  prefs: []
  type: TYPE_NORMAL
- en: However, using `after_idle` would cause the item to move at a pace that will
    depend on the computer speed. This means that a fast system will call `process_movements()`
    more times in the same interval of time than a slower one, and this difference
    will be noticeable in the item speed.
  prefs: []
  type: TYPE_NORMAL
- en: By introducing a minimum fixed delay, we give a chance to machines with different
    capabilities to behave in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Detecting collisions between items* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions between items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a continuation of the preceding recipe, we can detect whether a rectangle
    item overlaps with another one. In fact, this can be achieved, assuming that we
    are working with shapes contained in rectangular boxes, using the `find_overlapping()`
    method from the `Canvas` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This application extends the preceding one by adding four green rectangles
    to the canvas and highlighting the one that is touched by a blue rectangle moved
    using the arrow keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/ce47f2c4-c609-4fa0-aea3-71bf7cb0b81e.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this script has many similarities with the preceding one, we marked the
    parts of the code that create the four rectangles and invoke the `canvas.find_overlapping()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modification to the `__init__` method is similar to the one in the *Finding
    items by their position* recipe, so you can review it in case you have any doubts
    and skip directly to the changes in the `process_movements()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we calculate any overlap, the fill color of all the canvas items, except
    the one that can be controlled by the user, is changed to green. These item''s
    identifiers are retrieved by the `canvas.find_all()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the item colors are reset, we call `canvas.find_overlapping()` to
    get all the items that are currently colliding with the moving item. Again, the
    item controlled by the user is excluded from the loop, and the color of the rest
    of the overlapping items (if any) is changed to yellow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The method continues its execution by moving the blue rectangle by the calculated
    offset, and scheduling `process_movements()` itself again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to detect when the moving item fully overlaps another one, instead
    of partially doing it, replace the call to `canvas.find_overlapping()` to `canvas.find_enclosed()`
    with the same parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting items from a canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides adding and modifying items on a canvas, it is also possible to delete
    them via the `delete()` method of the `Canvas` class. Although the usage of this
    method is very straightforward, there are a couple of useful patterns that we
    will see in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the more items displayed on a canvas, the longer it will take
    to Tkinter to redraw the widget. Therefore, it is convenient to remove unnecessary
    items if this could cause a performance issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will build an application that randomly displays several
    circles on a canvas. Each circle removes itself once you click on it, and the
    window contains one button to clear all the items and another button to start
    over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/f5f70f4c-b05c-4a20-a132-8128d59fc1b4.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To irregularly place the items on the canvas, we will generate the coordinates
    using the `randint` function from the `random` module. The item color will be
    randomly chosen as well by calling `choice` with a predefined list of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once generated, items can be deleted either by triggering the `on_click` handler
    when clicked or by pressing the `Clear items` button, which executes the `clear_all`
    callback. These methods internally call `canvas.delete()` with the appropriate
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `canvas.delete()` method takes one argument, which can be an item identifier
    or a tag, and removes the matching item or items, since the same tag can be used
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `on_click()` handler, we can see an example of how to remove an item
    by its identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that if we click on an empty point, `canvas.find_withtag(tk.CURRENT)` will
    return `None`, but it will not raise any error when passed to `canvas.delete()`.
    This happens because the `None` parameter will not match any item identifier or
    tag and therefore, it is a valid value even though it will not perform any action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `clear_items()` callback, we can find another example of deleting items.
    Here, instead of passing an item identifier, we used the `ALL` tag to match all
    the items and remove them from the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, the `ALL` tag works out of the box and does not need
    to be added to every canvas item.
  prefs: []
  type: TYPE_NORMAL
- en: Binding events to canvas items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to bind events to widgets; however, it is also possible
    to do so for canvas items. This helps us to write more specific and simpler event
    handlers, instead of binding all the types of events we want to process on the
    `Canvas` instance and then determining which action has to be applied according
    to the affected item.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following application shows how to implement the drag and drop functionality
    on canvas items. This is a common functionality that serves to illustrate how
    this approach can simplify our programs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a couple of items that can be dragged and dropped with the mouse—a
    rectangle and an oval. The different shapes help us to note how the click events
    are correctly applied to the corresponding item, even though the items are placed
    overlapping each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To bind events to items, we use the `tag_bind()` method from the `Canvas` class.
    This adds the event binding to all the items that match the item specifier, in
    our example, the `"draggable"` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the method is named `tag_bind()`; it would be also valid to pass an item
    identifier instead of a tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this only affects existing tagged items, so if we add new
    items later on with the `"draggable"` tag, they will not have these bindings attached.
  prefs: []
  type: TYPE_NORMAL
- en: The `button_press()` method is the handler invoked when an item is clicked.
    As usual, a common pattern to retrieve the clicked item is to call `canvas.find_withtag(tk.CURRENT)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This item identifier and the `x` and `y` coordinates of the `click` event are
    stored in the `dnd_item` field. These values will be used later to move the item
    in sync with the mouse motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `button_motion()` method processes the mouse motion events while the primary
    button is being held.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the distance that the item should be moved, we calculate the difference
    from the current event position to the previously stored coordinates. These values
    are passed to the `canvas.move()` method and saved again in the `dnd_item` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There are some variations of this drag and drop functionality that also implement
    a handler for the `<ButtonRelease-1>` sequence, which unsets the currently dragged
    item.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not necessary because once this type of event occurs, the `<Button1-Motion>`
    binding will not be triggered until an item is clicked again. This also saves
    us from checking whether `dnd_item` is not `None` at the beginning of the `button_motion()`
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to improve this example by adding some basic validations, such
    as verifying that users cannot drop an item outside of the canvas visible area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, you can use the patterns we have covered in previous recipes
    to calculate the canvas width and height and verify that the final position of
    the item is inside a valid range by chaining the comparison operators. You can
    use the structure shown in the following snippet as a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Moving canvas items* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a canvas into a PostScript file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Canvas` class natively supports saving its contents using the PostScript
    language via its `postscript()` method. This stores the graphical representation
    of canvas items, such as lines, rectangles, polygons, ovals, and arcs, however,
    it does not do so for embedded widgets and images.
  prefs: []
  type: TYPE_NORMAL
- en: We will modify a previous recipe that dynamically generates this type of simple
    items to add the functionality to save a representation of the canvas into a PostScript
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will take the code sample from the *Drawing lines and arrows* recipe to
    add a button to print the canvas contents to a PostScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main addition to the original script is the `Render canvas` button with
    the `render_canvas()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'It calls the `postscript()` method on the `canvas` instance with the `file`
    and `colormode` arguments. These options specify the path to the destination file
    that writes the PostScript and the output color information, which could be `"color"`
    for full color output, `"gray"` to translate to gray-scale equivalents, and `"mono"`
    to convert all colors to black or white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can check all the valid options that can be passed to the `postscript()`
    method on the Tk/Tcl documentation at [https://www.tcl.tk/man/tcl8.6/TkCmd/canvas.htm#M61](https://www.tcl.tk/man/tcl8.6/TkCmd/canvas.htm#M61).
    Bear in mind that PostScript is a language primarily aimed to be printed, so most
    options refer to page settings.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since PostScript files are not as popular as other file formats, you might want
    to convert the generated file from PostScript to a more familiar format such as
    PDF.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, you need a third-party software, such as **Ghostscript**, which is
    distributed under GNU's **Affero General Public License** (**AGPL**). Ghostscript's
    interpreter and renderer utilities can be invoked from your program to automatically
    convert the PostScript result to PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the latest version of the software from[ https://www.ghostscript.com/download/gsdnld.html](https://www.ghostscript.com/download/gsdnld.html) and
    add the `bin` and `lib` folders of the installation into your operating system
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, modify your Tkinter application to call the `ps2pdf` program as a subprocess
    and remove the `output.ps` file when it finish its execution, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
