- en: Working with System Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about file input and output in Go, and created
    Go versions of the `wc(1)`, `dd(1)`, and `cp(1)` utilities.
  prefs: []
  type: TYPE_NORMAL
- en: While the main subject of this chapter is Unix system files and log files, you
    will also learn many other things, including pattern matching, file permissions,
    working with users and groups, and dealing with dates and times in Go. For all
    these subjects, you will see handy Go codes that will explain the presented techniques,
    and these can be used in your own Go programs without requiring too many changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this chapter will talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Appending data to an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a file and altering each one of its lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions and pattern matching in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending information to Unix log files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dates and times in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unix file permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with user IDs and group IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning more information about files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing log files and extracting useful information from them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating difficult to guess passwords using random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which files are considered system files?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Unix operation system contains files that are responsible for the configuration
    of the system as well as its various services. Most of these files are located
    in the `/etc` directory. I also like to consider log files as system files, although
    some people might disagree. Usually, most system log files can be found inside
    `/var/log`. However, the log files of the Apache and the nginx web server can
    be found elsewhere, depending on their configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `log` package provides a general way to log information on your Unix machine,
    whereas the `log/syslog` Go package allows you to send information to the system
    logging service using the logging level and the logging facility you want. Also,
    the `time` package can help you work with dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: Putting data at the end of a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml), *File
    Input and Output*, in this chapter, we will talk about opening a file for writing
    without destroying its existing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go program that will illustrate the technique, `appendData.go`, will accept
    two command-line arguments: the message you want to append and the name of the
    file that will store the text. This program will be presented in three parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `appendData.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the first part of the program contains the Go packages that will
    be used in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The desired task is done by the `os.O_APPEND` flag of the `os.OpenFile()` function
    that tells Go to write at the end of the file. Additionally, the `os.O_CREATE`
    flag will make `os.OpenFile()` to create the file if it does not exist, which
    is pretty handy because it saves you from having to write Go code that tests whether
    the file is already there or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `fmt.Fprintf()` function is used here in order to write the message to the
    file as plain text. As you can see, `appendData.go` is a relatively small Go program
    that does not contain any surprises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `appendData.go` will create no output, but it will do its job, as
    you can see from the output of the `cat(1)` utility before and after the execution
    of `appendData.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Altering existing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will teach you how to modify the contents of a file. The program
    that will be developed does a pretty convenient job: it adds a line number in
    front of each line of a text file. This means that you will need to read the input
    file line by line, keep a variable that will hold the line number value, and save
    it using the original name. Additionally, the initial value of the variable that
    holds the line number value can be defined when you start the program. The name
    of the Go program will be `insertLineNumber.go`, and it will be presented in four
    parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will see the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is mainly the configuration of the `flag` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `lineNumber` variable is initiated by the value of the `minusINIT` flag.
    Additionally, the utility can process multiple files using a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `insertLineNumber.go` reads its input file all at once using
    `ioutil.ReadFile()`, which might not be so efficient when processing huge text
    files. However, with today's computers, this should not be a problem. A better
    approach would be to read the input file line by line, write each altered line
    to a temporary file, and then replace the original file with the temporary one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As the `range` loop will introduce an extra line at the end of the file, you
    have to delete the last line in the lines slice using the `lines[len(lines)-1]
    = ""` statement, which means that the program assumes that all the files it processes
    end with a new line. If your text files do not do that, then you might want to
    change the code of `insertLineNumber.go` or add a new line at the end of your
    text files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The running of `insertLineNumber.go` generates no visible output apart from
    the filename of each file it processes and the total number of processed lines.
    However, you can see the results of its execution by looking at the contents of
    the files you processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to process the same input file multiple times, as in the following
    example, an interesting thing will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: About log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part will teach you how to send information from a Go program to the logging
    service and therefore to system log files. Despite the obvious fact that it is
    good to keep information stored, log files are necessary for server processes
    because there is no other way for a server process to send information to the
    outside world, as it has no Terminal to send any output.
  prefs: []
  type: TYPE_NORMAL
- en: Log files are important and you should not underestimate the value of the information
    stored in them. Log files should be the first place to look for help when strange
    things start happening on a Unix machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, using a log file is better than displaying the output on
    the screen for two reasons: first, the output does not get lost, as it is stored
    on a file, and second, you can search and process log files using Unix tools,
    such as `grep(1)`, `awk(1)`, and `sed(1)`, which cannot be done when messages
    are printed on a Terminal window.'
  prefs: []
  type: TYPE_NORMAL
- en: About logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All Unix machines have a separate server process for logging log files. On macOS
    machines, the name of the process is `syslogd(8)`. On the other hand, most Linux
    machines use `rsyslogd(8)`, which is an improved and more reliable version of
    `syslogd(8)`, which was the original Unix system utility for message logging.
  prefs: []
  type: TYPE_NORMAL
- en: However, despite the Unix variant you are using, or the name of the server process
    used for logging, logging works the same way on every Unix machine and therefore
    does not affect the Go code that you will write.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to watch one or more log files is with the help of the `tail(1)`
    utility, followed by the `-f` flag and the name of the log file you want to watch.
    The `-f` flag tells `tail(1)` to wait for additional data. You will need to terminate
    such a `tail(1)` command by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Logging facilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A logging facility is like a category used for logging information. The value
    of the logging facility part can be any one of *auth*, *authpriv*, *cron*, *daemon*,
    *kern*, *lpr*, *mail*, *mark*, *news*, *syslog*, *user*, *UUCP*, *local0*, *local1*,
    *local2*, *local3*, *local4*, *local5*, *local6*, and *local7*; this is defined
    inside `/etc/syslog.conf`, `/etc/rsyslog.conf`, or another appropriate file depending
    on the server process used for system logging on your Unix machine. This means
    that if a logging facility is not defined and therefore handled, the log messages
    you send to it might get lost.
  prefs: []
  type: TYPE_NORMAL
- en: Logging levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **logging level** or **priority** is a value that specifies the severity of
    the log entry. There exist various logging levels including *debug*, *info*, *notice*,
    *warning*, *err*, *crit*, *alert*, and *emerg,* in reverse order of severity.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `/etc/rsyslog.conf` file of a Linux machine to learn more about
    how to control logging facilities and logging levels.
  prefs: []
  type: TYPE_NORMAL
- en: The syslog Go package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will present a Go program that works on all Unix machines and
    sends data to the logging service in various ways. The name of the program is
    `useSyslog.go`, and it will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will see the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You have to use the `log` package for logging and the `log/syslog` package for
    defining the logging facility and the logging level of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `syslog.New()` function call, which returns a writer, tells your program
    where to direct all log messages. The good thing is that you already know how
    to use a writer!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the developer should define both the priority and the facility that
    a program uses.
  prefs: []
  type: TYPE_NORMAL
- en: However, even with a defined priority and facility, the `log/syslog` package
    allows you to send direct log messages to other priorities using functions such
    as `sysLog.Crit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This part shows that you can call `syslog.New()` multiple times in the same
    program. Once again, calling the `Emerg()` function allows you to bypass what
    was defined by the `syslog.New()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is the only call that uses the logging priority and the logging facility
    that were defined by `syslog.New()`, by directly writing to the `sysLog` writer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `useLog.go` will generate some output on the screen, but it will
    also write data to the appropriate log files. On a macOS Sierra or a Mac OS X
    machine, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On a Debian Linux machine, you will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output from the two machines shows that the Linux machine has a different
    `syslog` configuration, which is the reason that the messages from `useLog.go`
    were also written to `/var/log/cisco.log`.
  prefs: []
  type: TYPE_NORMAL
- en: However, your main concern should not be whether the log messages will be written
    to too many files or not; rather if you will be able to find them or not!
  prefs: []
  type: TYPE_NORMAL
- en: Processing log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will process a log file that contains client IP addresses in
    order to create a summary of them. The name of the Go file will be `countIP.go`,
    and it will be presented in four parts. Note that `countIP.go` requires two parameters:
    the name of the log file and the field that contains the desired information.
    As `countIP.go` does not check whether the given field contains an IP address
    or not, it can also be used for other kinds of data if you remove some of its
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will see the expected preamble of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part comes with the following Go code, which is the beginning of
    the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `countIP.go` utility uses the `flag` package and can process multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Each input file is read line by line, whereas the `myIPs` map variable is used
    for holding the count of each IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `countIP.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is where the magic happens: first, you extract the desired field from
    the working line. Then, you use the `net.ParseIP()` function to make sure that
    you are dealing with a valid IP address: if you want the program to process other
    kinds of data, you should delete the Go code that uses the `net.ParseIP()` function.
    After that, you update the contents of the `myIPs` map based on whether the current
    IP address can be found in the map or not: you saw that code back in [Chapter
    2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)*, Writing Programs in Go*. Finally,
    you print the contents of the `myIPs` map on the screen, and you are done!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `countIP.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it would be better if the output was sorted by the count associated
    with each IP address, which you can easily do with the help of the `sort(1)` Unix
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the first 10 IP addresses, you can filter the previous output with
    the `head(1)` utility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: File permissions revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times that we need to find detailed information about the Unix permissions
    of a file. The `filePerm.go` Go utility will teach you how to read the Unix file
    permissions of a file or a directory and print them as a binary number, a decimal
    number, and a string. The program will be presented in three parts. The first
    part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, you implement two functions that will help you convert a string with nine
    characters that hold the permissions of a file into a binary number. As an example,
    the `rwxr-x---` string will be converted to `111101000`. The initial string is
    extracted from the `os.Stat()` function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `filePerm.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Changing file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will explain how to change the Unix permissions of a file or a
    directory to the desired value; however, it will not deal with the sticky bit,
    the set user ID bit, or the set group ID bit: not because they are difficult to
    implement, but because you usually do not need any of these when dealing with
    system files.'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the utility will be `setFilePerm.go`, and it will be presented in
    four parts. The new file permissions will be given as a string with nine characters
    such as `rwxrw-rw-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `setFilePerm.go` contains the expected preamble Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the implementation of the `tripletToBinary()` function that
    you saw in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the name of the function is misleading, as it does not return a binary
    number: this is my fault.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, you get the return value of `convertToBinary()` and convert it to an `os.FileMode()`
    variable in order to use it with the `os.Chmod()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `setFilePerm.go` generates the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finding other kinds of information about files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important information about a Unix file is its owner and its group,
    and this section will teach you how to find both of them using Go code. The `findOG.go`
    utility accepts a list of files as its command-line arguments and returns the
    owner and the group of each one of them. Its Go code will be presented in three
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this part, you make a call to the `os.Stat()` function to make sure that
    the file you want to process exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `findOG.go` comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Yes, this is the most cryptic code you have seen so far in this book that uses
    the return value of `os.Stat()` to extract the desired information. Additionally,
    it is neither portable, which means that it might not work on your Unix variant,
    nor you can be sure that it will continue to work in forthcoming versions of Go!
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes tasks that look easy might take you more time than expected. One of
    these tasks is the `findOG.go` program. This mainly happens because Go does not
    have an easy and portable way to find out the owner and the group of a file. Hopefully,
    this will change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `findOG.go` on macOS Sierra or Mac OS X will generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that the `fileInfo.Sys()` call returns a plethora of information
    from the file in a somehow puzzling format: the information is analogous to the
    information from a C call to `stat(2)`. The first line of output is the contents
    of the `os.Stat.Sys()` call, whereas the second line is the user ID (`501`) of
    the owner of the file and the third line is the group ID (`0`) of the owner of
    the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `findOG.go` on a Debian Linux machine will generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The good news here is that `findOG.go` worked on both macOS Sierra and Debian
    Linux, even though macOS Sierra was using Go version 1.8.1 and Debian Linux was
    using Go version 1.3.3!
  prefs: []
  type: TYPE_NORMAL
- en: Most of the presented Go code will be used later in this chapter for the implementation
    of the `userFiles.go` utility.
  prefs: []
  type: TYPE_NORMAL
- en: More pattern matching examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will present regular expressions that match more difficult patterns
    than the ones you have seen so far in this book. Just remember that regular expressions
    and pattern matching are practical subjects that you should learn by experimenting
    and sometimes failing, not by reading about them.
  prefs: []
  type: TYPE_NORMAL
- en: If you are very careful with regular expressions in Go, you can easily read
    or change almost all the system files of a Unix system that are in plain text
    format. Just be extra careful when modifying system files!
  prefs: []
  type: TYPE_NORMAL
- en: A simple pattern matching example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example of this section will improve the functionality of the `countIP.go`
    utility, by developing a program that automatically detects the field with the
    IP address; therefore, it will not require the user to define the field of each
    log entry that contains the IP address. To make things simpler, the created program
    will only process the first IP address of each line: `findIP.go` takes a single
    command-line argument, which is the name of the log file you want to process.
    The program will be presented in four parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `findIP.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is where most of the magic happens with the help of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression is pretty complex considering that we just want to match
    four decimal numbers in the 0-255 range that are separated by dots, which mainly
    shows that regular expressions can be pretty complicated when you want to be methodical.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let me explain this to you in more detail. An IP address has four parts
    separated by dots. Each one of these parts can have a value between 0 and 255,
    which means that number 257 is not an acceptable value: this is the main reason
    that the regular expression is so complex. The first case is for numbers between
    250 and 255\. The second case is for numbers between 200 and 249, and the third
    case is for numbers between 100 and 199\. The last case is for catching values
    between 0 and 99.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `findIP.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, you read the input log file line by line using `bufio.NewReader()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part has the following Go code, which deals with processing the matches
    of the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `findIP.go` executes an additional checking on the IP that was
    found by the function that performed the pattern matching operation, using `net.ParseIP()`;
    this mainly happens because IP addresses are pretty tricky, and it is considered
    good practice to double check them! Additionally, this catches the case where
    `findIP()` returns nothing because a valid IP was not found in the processed line.
    The last thing the program does before exiting is to print the contents of the
    `myIPs` map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how many incredible and useful utilities you can develop with a small
    amount of Go code: it is really amazing!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `findIP.go` on a Linux machine in order to process the `/var/log/auth.log`
    log file will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can sort the previous output by the number of times an IP was found and
    display the 10 most popular IP addresses, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, in this case, the `findIP.go` utility is used for checking the security
    of your Linux machine!
  prefs: []
  type: TYPE_NORMAL
- en: An advanced example of pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to swap the values of two fields of each
    line of a text file, provided they are in the correct format. This mainly happens
    in log files or other text files where you want to scan a line for certain types
    of data, and if the data is found, you might need to do something with them: in
    this case, you will change the place of the two values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the program will be `swapRE.go`, and it will be presented in four
    parts. Once again, the program will read a text file line by line and try to match
    the desired strings before swapping them. The utility will print the contents
    of the new file on the screen; it is the responsibility of the user to save the
    results to a new file. The format of the log entries that `swapRE.go` expects
    to process are similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The entries from the previous line that the program will swap are [`24/May/2017:06:41:11
    +0300`] and `132953`, which are the date and time and the time it took the browser
    to get the desired information, respectively; the program expects to find this
    at the end of each line. However, the regular expression also checks that the
    date and time are in the correct format and that the last field of each log entry
    is indeed a number.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see, using regular expressions in Go, can be perplexing sometimes,
    mainly because regular expressions are relatively difficult to build, in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `swapRE.go` will be the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing particularly interesting or new here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here is the Go code that allows you to process the input file line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `swapRE.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine, complex regular expressions, such as the one presented
    here, are built step by step, not all at once. Even in that case, you may still
    fail many times in the process because even the tiniest mistake in a complex regular
    expression will cause it to not do what you expect: extensive testing is the key
    here!'
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses used inside a regular expression allow you to reference each
    match afterwards and are very handy when you want to process what you have matched.
    What you want here is to find a `[` character, then two digits that will be the
    day of the month, then a word, which will be the name of the month, and then four
    digits that will be the year. Next, you match anything else until you find a `]`
    character. Then you match all the digits at the end of each line.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there might exist alternative ways to write the same regular expression.
    The general advice here is to write it in a way that is clear and that you can
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `swapRE.gowith`, a small test log file will generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Renaming multiple files using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section on pattern matching and regular expressions will work on filenames
    and will allow you to rename multiple files. As you can guess, a walk function
    will be used in the program while a regular expression will match the filenames
    you want to rename.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with files, you should be extra careful because you might accidentally
    destroy things! Putting it simply, do not test such utilities on a production
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the utility will be `multipleMV.go`, and it will be presented in
    three parts. What `multipleMV.go` will do is insert a string in front of every
    filename that is a match to the given regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The two global variables save you from having to use many parameters in your
    functions. Additionally, as the signature of the `walk()` function, presented
    in a while, cannot change, it will not be possible to pass them as parameters
    to `walk()`. So, in this case, having two global parameters makes things easier
    and simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: All the functionality of the program is embedded in the `walk()` function. After
    a successful match, the new filename is stored in the `newName` variable before
    executing the `os.Rename()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `multipleMV.go` is the implementation of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there is nothing you have not seen before: the only interesting thing
    is the call to `filepath.EvalSymlinks()` in order to not have to deal with symbolic
    links.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `multipleMV.go` is as simple as running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Searching files revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will teach you how to find files using criteria such as user ID,
    group ID, and file permissions. Although this section could have been included
    in [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml), *Files and Directories*,
    I decided to put it here, because there are times when you will want to use this
    kind of information in order to inform a system administrator that there is something
    wrong with the system.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the user ID of a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will present a program that shows the user ID of a user, given
    their username, which is more or less the output of the `id -u` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The fact that there exists a Go package named `user`, which can be found under
    the `os` package that can help you implement the desired task, should not come
    as surprise to you. The name of the program will be `userID.go`, and it will be
    presented in two parts. If you give no command-line arguments to `userID.go`,
    it will print the user ID of the current user; otherwise, it will print the user
    ID of the given username.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `userID.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `os.Getuid()` function returns the user ID of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `userID.go` comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Given a username, the `user.Lookup()` function returns a `user.User` compound
    value. We will only use the `Uid` field of that compound value to find the user
    ID of the given username.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `userID.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Finding all the groups a user belongs to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each user can belong to more than one group: this section will show how to
    find out the list of groups a user belongs to, given their username.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the utility will be `listGroups.go`, and it will be presented in
    four parts. The first part of `listGroups.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The approach that `listGroups.go` takes when there are no command-line arguments
    is similar to the one found in `userID.go`. However, there is a big difference,
    as this time you do not need the user ID of the current user, but the username
    of the current user; so you call `user.Current()`, which returns a `user.User`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: So, if a command-line argument is given to the program, it is handled by the
    previous code with the help of the `user.Lookup()` function that also returns
    a `user.User` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you get the list of the group IDs that the user: signified by the `u`
    variable: is a member of, by calling the `u.GroupIds()` function. Then, you will
    need a `for` loop to iterate over all the list elements and print them. It should
    be made clear that this list is stored in `u`; that is, a `user.User` value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `listGroups.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `listGroups.go` is much more enriched than the output of both
    the `id -G -n` and `groups` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Finding files that belong or do not belong to a given user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will create a Go program that scans a directory tree and presents
    files that belong or do not belong to a given user. The name of the program will
    be `userFiles.go`. In its default mode of operation, `userFiles.go` will display
    all files that belong to a given username; when used with the `-no` flag, it will
    only display the files that do not belong to the given username.
  prefs: []
  type: TYPE_NORMAL
- en: The code of `userFiles.go` will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for declaring `INCLUDE` and `uid` as global variables is that you
    want both of them to be accessible from every point of the program. Additionally,
    as the signature of `walkFunction()` cannot change: only its name can change:
    using global variables makes things easier for the developer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The use of a local variable named `UID` might be a poor choice, given that there
    is a global variable named `uid`! A better name for the global variable would
    have been `gUID`. Note that for an explanation of the way that the call that returns
    the `UID` variable works, you should search for the interfaces and type conversions
    in Go, because talking about it is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see the implementation of a walk function that will access every
    file and directory in a given directory tree, in order to print the desired filenames
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the utility contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here you deal with the configuration of the `flag` package before calling the
    `filepath.Walk()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `userFiles.go` generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not give any command-line arguments or flags, the `userFiles.go`
    utility will assume that you want to search the current directory for files that
    belong to the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in order to find all the files in the `/srv/www/www.highiso.net` directory
    that do not belong to the `www-data` user, you should execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Finding files based on their permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to find the Unix permissions of a file, you can improve
    the `regExpFind.go` utility from the previous chapter in order to support searching
    based on file permissions; however, in order to avoid presenting a really big
    Go program here without any practical reason, the presented program will be autonomous
    and only support finding files based on their permissions. The name of the new
    utility will be `findPerm.go`, and it will be presented in four parts. The permissions
    will be given in the command line as a string using the format returned by the
    `ls(1)` command (`rwxr-xr--`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the utility is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `PERMISSIONS` variable is made global in order to be accessible from anywhere
    in the program, and because the signature of `walkFunction()` cannot change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `findPerm.go` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part is the implementation of `walkFunction()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of `findPerm.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `findPerm.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Date and time operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show you how to work with dates and times in Go. This task
    might look insignificant, but it can be very important when you want to synchronize
    things such as log entries and error messages. We will start by illustrating some
    of the functionality of the `time` package.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will present a small Go program named `dateTime.go` that shows
    how to work with times and dates in Go. The code of `dateTime.go` will be presented
    in three parts. The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this part, you can see how you can change a date from one format to another,
    and also, how to find the date and time in a different time zone. The `time.Now()`
    function used at the beginning of the `main()` function returns the current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The list of constants that can be used for creating your own parse format can
    be found at [https://golang.org/src/time/format.go](https://golang.org/src/time/format.go).
    Go does not define the format of a date or a time in a form like DDYYYYMM or %D
    %Y %M as the rest of the programming languages do, but uses its own approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you see how you can read a string and try to convert it to a valid date,
    both successfully (`d`) and unsuccessfully (`d1`). The problem with the `d1` variable
    is the use of `February` in the `format` string: you should have used `January`
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `dateTime.go` comes with the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This part also shows how to convert a string into a date and a time, provided
    that it is in the expected format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `dateTime.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Reformatting the times in a log file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show how to implement a program that reads a log file that
    contains date and time information, in order to convert the time format found
    in each log entry. This operation might be needed when you have log files from
    different servers that are in several time zones, and you want to synchronize
    their times in order to create reports from their data or store them into a database
    to process them some other time.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the presented program will be `dateTimeLog.go`, and it will be presented
    in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just configure the `flag` package and open the input file for reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here you read the input file line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The general idea here is that once you have a match, you parse the date and
    time you found using `time.Parse()` and then convert it to the desired format
    using the `time.Format()` function. Also, you replace the initial match with the
    output of the `time.Format()` function before you print it using `strings.Replace()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `dateTimeLog.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Rotating log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files tend to get bigger and bigger all the time because data is written
    to them all the time; it would be good to have a technique for rotating them.
    This section will present such a technique. The name of the Go program will be
    `rotateLog.go`, and it will be presented in three parts. Note that for a process
    to rotate a log file, the process must be the one that opened that log file for
    writing. Trying to rotate a log that you do not own might create problems on your
    Unix machine, and should be avoided!
  prefs: []
  type: TYPE_NORMAL
- en: 'What you will also see here is another technique where you use your own log
    file for storing your log entries, with the help of `log.SetOutput()`: after a
    successful call to `log.SetOutput()`, each function call to `log.Print()` will
    make the output go to the log file used as the parameter of `log.SetOutput()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `rotateLog.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Using hard coded variables that define when the program will stop is considered
    good practice: this happens because you do not have any other way to tell `rotateLog.go`
    to stop. However, if you use the functionality of the `rotateLog.go` utility in
    a compiled program, then such variables should be given as command-line arguments,
    because you should not have to recompile the program in order to change the way
    the program behaves!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `rotateLog.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, you define the Go function named `rotateLogFile()` for rotating the desired
    log file, which is the most important part of the program. The `setUpLogFile()`
    function helps you restart the log file after you rotate it. What is also illustrated
    here is the use of `log.SetOutput()` to tell the program where to write the log
    entries. Note that you should open your log file using `os.OpenFile()`, because
    `os.Open()` will not work for `log.SetOutput()`, and `os.Open()` does open files
    for writing!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In this part, the `main()` function keeps writing data to a log file while counting
    the number of entries that have been written so far. When the defined number of
    entries have been reached (`ENTRIESPERLOGFILE`), the `main()` function will call
    the `rotateLogFile()` function, which will do the dirty work for us. On a real
    program, you will most likely not need to call `time.Sleep()` to delay the execution
    of the program. For this particular program, `time.Sleep()` will give you time
    to examine your log file using `tail -f`, should you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `rotateLog.go` will generate the following output on the screen and
    inside the `/tmp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 8](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml),*Processes and Signals*,
    will present a much better approach on log rotating that will be based on Unix
    signals.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating good random passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will illustrate how to create good random passwords in Go, in order
    to protect the security of your Unix machines. The main reason for including it
    here instead of another chapter is because the presented Go program will use the
    `/dev/random` device, which is a file defined by your Unix system, for getting
    the seed of the random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the Go program will be `goodPass.go`, and it will require just
    one optional parameter, which will be the length of the generated password: the
    default size of the generated password will be 10 characters. Additionally, the
    program will generate ASCII characters starting from `!` up to `z`. The ASCII
    code of the exclamation mark is 33, whereas the ASCII code of small z is 122.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `goodPass.go` is the required preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You have already seen the `random()` function back in [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)*,*
    *Writing Programs in Go*, so there is nothing particularly interesting here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `goodPass.go` is where the implementation of the `main()`
    function begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here, apart from reading the command-line argument, you also open the `/dev/random`
    device for reading, which happens by calling the `binary.Read()` function and
    storing what you read in the `seed` variable. The reason for using `binary.Read()`
    is that you need to specify the byte order used (`binary.LittleEndian`) and that
    you need to build an int64 instead of a series of bytes. This is an example of
    having to read from a binary file into Go types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Go has a strange way of dealing with ASCII characters because
    Go supports Unicode characters by default. However, you can still convert an integer
    number into an ASCII character as can be seen in the way you define the `newChar`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `goodPass.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Another Go update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I was writing this chapter, Go got updated. The following output shows the
    related information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find and read the documentation of the `time` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to change the Go code of `userFiles.go` in order to support multiple users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Go code of `insertLineNumber.go` in order to read the input file
    line by line, write each line to a temporary file, and then, replace the original
    file with the temporary one. If you do not know how and where to create a temporary
    file, you can use a random number generator to get a temporary filename and the
    `/tmp` directory to temporarily save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the necessary changes to `multipleMV.go` in order to print the files that
    are a match to the given regular expression without actually renaming them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to create a regular expression that matches `PNG` files and use it to process
    the contents of a log file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a regular expression that catches a date and a time string in order to
    print just the date part and delete the time part.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about many things, including working with log files,
    dealing with Unix file permissions, users, and groups, creating regular expressions,
    and processing text files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Unix signals, which allow you to communicate
    with a running program from the outside world, in an asynchronous way. Furthermore,
    we will tell you how to plot in Go.
  prefs: []
  type: TYPE_NORMAL
- en: f
  prefs: []
  type: TYPE_NORMAL
