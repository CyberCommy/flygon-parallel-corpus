- en: '*Chapter 8*: Creating Shared Libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn what libraries are and why they are such a big
    part of Linux. We also learn the differences between static libraries and dynamic
    libraries. When we know what libraries are, we start to write our own—both static
    and dynamic ones. We also take a quick peek inside a dynamic library.
  prefs: []
  type: TYPE_NORMAL
- en: The use of libraries has many benefits—for example, a developer doesn't need
    to reinvent functions over and over again as there's often an existing function
    already in a library. A big advantage with dynamic libraries is that the resulting
    program gets much smaller in size, and the libraries are upgradable even after
    the program has been compiled.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to make our own libraries with useful functions
    and install them on the system. Knowing how to make and install libraries enables
    you to share your functions with others in a standardized way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: The what and why of libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a static library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a static library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the dynamic library on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the dynamic library in a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling a statically linked program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll need the **GNU Compiler Collection** (**GCC**) compiler
    and the Make tool. You'll find installation instructions for these tools in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*. All the code samples for this chapter can
    be found in this chapter's GitHub directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch8](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3fygqOm](https://bit.ly/3fygqOm)'
  prefs: []
  type: TYPE_NORMAL
- en: The what and why of libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we go into the details of libraries, it''s essential to understand what
    they are and why they matter to us. It''s also important to understand the difference
    between static and dynamic libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge will enable you to make smarter choices when making your own
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A **dynamic library** is dynamically **linked** to the binary that uses it.
    What this means is that the library code isn't included in the binary. The library
    resides outside of the binary. This has several advantages. First, the resulting
    binary will be smaller in size since the library code isn't included. Second,
    the library can be updated without needing to recompile the binary. The disadvantage
    is that we can't move or delete the dynamic library from the system. If we do,
    the binary won't work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: A **static library**, on the other hand, is included inside the binary file.
    The advantage of this is that the binary will be completely independent of the
    library once compiled. The disadvantage is that the binary will be bigger, and
    the library can't be updated without also recompiling the binary.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen a short example of a dynamic library in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll look at some common libraries. We'll also install a new
    one on the system via the package manager that we'll use in a program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GCC compiler. You'll also need root access
    to the system, either via `su` or `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll both explore some common libraries and look at where they
    live on the system, and then install a new one and peek inside a library. In this
    recipe, we'll only deal with dynamic libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at the many libraries already on your system.
    The libraries will reside in one or more of these directories, depending on your
    distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will install a new library on the system with the Linux distribution
    package manager. The library we will install is for **cURL**, an application and
    library to fetch files or data from the internet—for example, over **HyperText
    Transfer Protocol** (**HTTP**). Follow these instructions, depending on your distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- **Debian/Ubuntu**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '- **Fedora/CentOS/Red Hat**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look inside the library with `nm`. But first, we need to
    find it with `whereis`. The path to the library is different on different distributions.
    This example is from a Debian 10 system. The file we are looking for is the `.so`
    file. Notice that we use `grep` with `nm` to only list lines with `T`. These are
    the functions that the library provides. If we were to remove the `grep` part,
    we would also see functions that this library depends on. We also add `head` to
    the command since the list of functions is long. If you want to see all the functions,
    leave out `head`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know a bit more about the library, we can use it in a program.
    Write the following code in a file and save it as `get-public-ip.c`. The program
    will send a request to the web server at `i`[fconfig.me](http://fconfig.me) and
    give you your public **Internet Protocol** (**IP**) address. The complete manual
    for the cURL library can be found online at [https://curl.se/libcurl/c/](https://curl.se/libcurl/c/).
    Notice that we don''t print anything from cURL. The library will automatically
    print the content it receives from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the code. Notice that we must also link against the cURL library using
    the `-l` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, finally, we can run the program to get our public IP address. My IP
    address is masked in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we have looked at all the steps involved in using a library to add new
    functionality. We installed the library on the system using the package manager.
    We found its location using `whereis`, investigated which functions it contains
    using `nm`, and finally used it in a program.
  prefs: []
  type: TYPE_NORMAL
- en: The `nm` program provides a quick way to see which functions a library contains.
    The `-D` option, which we used in this recipe, is for dynamic libraries. We used
    `grep` to only view functions that the library provides; otherwise, we will also
    see functions that this library depends on (those lines start with a `U`).
  prefs: []
  type: TYPE_NORMAL
- en: Since this library is not part of `libc`, we needed to link against it with
    the `-l` option to `gcc`. The name of the library should be right after the `l`,
    without any spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The [ifconfig.me](http://ifconfig.me) website is a site and service that returns
    the public IP of the client requesting the site.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: cURL is also a program. Many Linux distributions have it pre-installed. The
    cURL library provides a convenient way of using cURL functions in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: You can run `curl ifconfig.me` for the same result as the program we wrote,
    assuming you already have cURL installed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a static library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep
    into C in Linux*, we saw how to create a dynamic library and how it was linked
    from the current working directory. In this recipe, we'll make a **static library**
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: A static library is included in the binary during compilation. The advantage
    is that the binary gets a bit more portable and independent. We can remove the
    static library after compilation, and the program will still work.
  prefs: []
  type: TYPE_NORMAL
- en: The downsides are that the binary will be slightly larger and that we can't
    update the library after it has been compiled into the program.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to create static libraries will make it much easier to distribute
    and reuse your functions in new programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll need the GCC compiler. We will also use a tool called
    `ar` in this recipe. The `ar` program is almost always installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll make a small static library. The library will contain
    two functions: one for converting Celsius to Fahrenheit and one for converting
    Celsius to Kelvin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing the library functions. Write the following code in
    a file and save it as `convert.c`. This file contains both of our functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a header file with the function prototypes for these functions.
    Create another file and write the following code in it. Save it as `convert.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first task in making the library is to compile `convert.c` into an `-c`
    option to GCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have a file called `convert.o` in our current directory. We can
    verify this with the `file` command, which also tells us the type of file it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step to making it a static library is to pack it in an `ar` command.
    The `-c` option stands for *creating* the archive; the `-v` option stands for
    *verbose* output; and the `-r` option stands for *replacing* members with the
    same name. The name `libconvert.a` is the resulting filename our library will
    get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at our static library with `nm` before we move on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen here, a static library is just an object file in an archive.
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at the object file with the `file` command, we noticed it said
    *not stripped*, meaning that all the **symbols** are still in the file. *Symbols*
    are what expose the functions so that programs can access and use them. In the
    next recipe, we'll return to symbols and the meaning of *stripped* versus *not
    stripped*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot of good information about `ar` in its manual page, `man 1 ar`—for
    example, it's possible to modify and remove an already existing static library.
  prefs: []
  type: TYPE_NORMAL
- en: Using a static library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll use the static library created in the previous recipe
    in a program. Using a static library is a bit easier than using a dynamic library.
    We just add the static library (the archive file) to the list of files that will
    be compiled to a final binary.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use a static library will enable you to use other people's libraries
    and reuse your own code as static libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need both the `convert.h` file and the static library
    file, `libconvert.a`. You'll also need the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will write a small program that uses our functions from the library
    we created in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the following code in a file and save it as `temperature.c`. Notice the
    syntax for including header files from the current directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program takes two arguments: an option (either `-f` or `-k` for Fahrenheit
    or Kelvin) and a Celsius degree as a floating-point value. The program will then
    convert the Celsius degree into Fahrenheit or Kelvin, depending on the option
    chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile this program. To include the static library, we simply add it
    to the list of files to GCC. Also, make sure that the `convert.h` header file
    is in your current working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test the program with some different temperatures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, take a look at the resulting `temperature` binary with `nm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this binary will be used as a standalone program, we don''t need the
    symbols. It''s possible to *strip* the symbols from the binary with the `strip`
    command. This makes the program a bit smaller in size. Once we have stripped the
    binary from its symbols, let''s look at it again with `nm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see if a program or library is stripped or not with the `file` command.
    Remember that a static library can''t be stripped; otherwise, the linker can''t
    see the functions, and the linking will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to use the static library in a program, we give GCC the archive's
    filename and the program's `c` file, resulting in a binary that includes the static
    library.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few steps, we examined the binary with `nm`, revealing all the symbols.
    Then we stripped—removed—those symbols, using the `strip` command. If we look
    at programs such as `ls`, `more`, `sleep`, and so on with the `file` command,
    we notice that these are also *stripped*. This means that the program has had
    its symbols removed.
  prefs: []
  type: TYPE_NORMAL
- en: A static library must have its symbols untouched. If they were removed—stripped—the
    linker wouldn't find the functions, and the linking process would fail. Therefore,
    we should never strip our static libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While static libraries are convenient and easy to both create and use, **dynamic
    libraries** are more common. Just as we saw at the beginning of this chapter,
    many developers choose to provide a library and not only a program—for example,
    cURL.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll redo the library from the *Creating a static library*
    recipe that we covered earlier in this chapter so that it becomes a dynamic library.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to create dynamic libraries enables you to distribute your code
    as easy-to-implement libraries for other developers to use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the two `convert.c` and `convert.h` files from
    the *Creating a static library* recipe earlier in this chapter. You'll also need
    the GCC compiler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we make a dynamic library out of `convert.c` from the *Creating a static
    library* recipe earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s remove the object file and the old static library we created
    earlier. This will make sure we don''t use the wrong object file or the wrong
    library by mistake:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do is create a new object file from the `c` file.
    The `-c` option creates an object file, not the final binary. The `-fPIC` option
    tells GCC to generate what''s called `file`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a `.so` file, a `-shared` option does what it says—it
    creates a shared object. The `-Wl` option means that we want to pass all the options
    separated by commas to the linker. In this case, the option passed to the linker
    is `-soname` with the argument `libconvert.so`, which sets the name of the dynamic
    library to *libconvert.so*. Finally, the `-o` option specifies the name of the
    output file. Then, we list the symbols that this shared library provides, using
    `nm`. The symbols preceded by a `T` are the symbols provided by this library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a dynamic library involves two steps: creating an object file that''s
    position-independent, and packaging that file in a `.so` file.'
  prefs: []
  type: TYPE_NORMAL
- en: The code in a shared library gets loaded at runtime. Since it can't predict
    where it will end up in memory, it needs to be position-independent. That way,
    the code will work correctly, no matter where in memory it gets called.
  prefs: []
  type: TYPE_NORMAL
- en: The `-Wl,-soname,libconvert.so` GCC option might need some further explanation.
    The `-Wl` option tells GCC to treat any comma-separated words as options to the
    linker. Since we can't use a space—that would be treated as a new option—we separate
    `-soname` and `libconvert.so` with a comma instead. The linker, however, sees
    it as `-soname libconvert.so`.
  prefs: []
  type: TYPE_NORMAL
- en: '`soname` is short for *shared object name*, which is an internal name in the
    library. It''s this name that is used when referring to the library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual filename specified with the `-o` option is sometimes called the
    *real name* of the library. It''s a standard convention to use a real name that
    contains the version number of the library, such as `1` in this example. It''s
    also possible to include a minor version—for example, `1.3`. In our example, it
    would look like this: `libconvert.so.1.3`. Both the *real name* and the *soname*
    must begin with `lib`, short for *library*. All in all, this gives us a total
    of five parts for the real name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lib` (short for library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convert` (the name of the library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.so` (the extension, short for *shared object*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.1` (the major version of the library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.3` (the minor version of the library, optionally)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contrary to static libraries, dynamic libraries can be stripped and will still
    work. Note, however, that the stripping must then occur after creating the dynamic
    library on the `.so` file. If we were to strip the object (`.o`) file instead,
    we would lose all the symbols, making it useless for linking. But a `.so` file
    keeps the symbols in a special table called `.dynsym`, which the `strip` command
    won't touch. It's possible to view this table on a stripped dynamic library with
    the `readelf` command, using the `--symbols` option. So, if the `nm` command replies
    with *no symbols* on a dynamic library, you can try `readelf --symbols` instead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GCC** is a massive piece of software with lots of options. There are PDF
    manuals available for each version of GCC on GNU''s website. The manuals are about
    1,000 pages long and can be downloaded from https://gcc.gnu.org/onlinedocs/.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the dynamic library on the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen how to create both static and dynamic libraries, and in [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into C in Linux*,
    we even saw how we could use a dynamic library from our home directory. But now,
    the time has come to install a dynamic library system-wide so that any user on
    your computer can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to install a dynamic library on a system will enable you to add
    libraries system-wide for any user to use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the `libconvert.so.1` dynamic library we created
    in the previous recipe. You will also need root access to the system, either via
    `sudo` or `su`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing a dynamic library is just a matter of moving the library file and
    header file to the correct directory and running a command. However, there are
    some conventions we should follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to copy the library file to the correct place
    on the system. A common directory for user-installed libraries is `/usr/local/lib`,
    which we will use here. Since we are copying the file to a place outside of our
    home directory, we need to execute the command as the root user. We''ll use `install`
    here to set the user, the group, and the mode in a single command, and since it''s
    a system-wide install, we want it to be owned by root. It should also be executable
    since it will be included and executed at runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we must run the `ldconfig` command, which will create the necessary links
    and update the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also copy the header file to a system directory; otherwise, the user
    would have to download and keep track of the header file manually, which is less
    than ideal. A good place for user-installed header files is `/usr/local/include`.
    The word *include* is from the C language `#include` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we installed the library and the header file system-wide, we can go ahead
    and remove them from our current working directory. Doing so will make sure that
    we use the correct files in the next recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We installed the library file and header file using `install`. This program
    is excellent for tasks such as this since it sets the user (the `-o` option),
    the group (the `-g` option), and the mode (the `-m` option) in a single command.
    If we had used `cp` to copy the file, it would have been owned by the user who
    created it. We always want system-wide installation of binaries, libraries, and
    header files owned by the root user for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `/usr/local` directory is a good place for user-created stuff. We placed
    our library under `/usr/local/lib` and our header file under `/usr/local/include`.
    System libraries and header files are often placed in `/usr/lib` and `/usr/include`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When we later use the library, the system will look for it in a file with a
    `.so` ending, and hence we need a symbolic link to the library with the name `libconvert.so`.
    But we didn't need to create that link ourselves; `ldconfig` took care of that
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since we have placed the header file in `/usr/local/include`, we don't
    need to have that file in our current working directory anymore. We can now use
    the same syntax when including it like any other system header file. We'll see
    this in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dynamic library in a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a dynamic library and installed it on our system, it's
    time to try it out in a program. We have actually been using dynamic libraries
    without even thinking about it since the very beginning of this book. Functions
    such as `printf()` and so on are all part of the standard library. In the *The
    what and why of libraries* recipe from earlier in this chapter, we used another
    dynamic library called cURL. In this recipe, we'll use our very own library that
    we installed in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use custom libraries will enable you to use other developers'
    code, which will speed up the development process. There's often no need to reinvent
    the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll need the `temperature.c` code from the *Using a static
    library* recipe earlier in this chapter. That program will use the dynamic library.
    You'll also need to complete the previous recipe before attempting this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll use the `temperature.c` code to make use of the library
    we installed in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will use the `/usr/local/include`, we must modify the `#include` line
    in `temperature.c`. *Line 4* in `temperature.c` currently appears as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the preceding code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, save it as `temperature-v2.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go ahead and compile the program. GCC will use the system-wide header
    file and library file. Remember that we need to link against the library using
    the `-l` option. When we do this, we must leave out the `lib` part and `.so` ending:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s try it out with some different temperatures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify which libraries are dynamically linked with `ldd`. When we run
    this tool on our program, we see our `libconvert.so` library, `libc`, and something
    called `vdso` (*virtual dynamic shared object*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we include local header files from our current directory, the syntax is
    `#include "file.h"`. But for system-wide header files, the syntax is `#include
    <file.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the library is now installed in one of the system directories, we didn't
    need to specify the path to it. It was sufficient to link against the library
    with `-lconvert`. When doing so, all the common system-wide directories are being
    searched for the library. When we link with `-l`, we leave out both the `lib`
    part of the filename and the `.so` ending—the linker figures this out on its own.
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we verified that we are using the system-wide installation
    of `libconvert.so`, using `ldd`. Here, we also saw the standard C library, `libc`,
    and something called `vdso`. The standard C library has all the usual functions
    that we use time and time again, such as `printf()`. The `vdso` library, however,
    is a bit more arcane and is not something we are going to cover here. In short,
    it exports a small set of often-used system calls to userland to avoid too much
    context-switching, which would impair performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we've talked a lot about the `ld`. To gain a deeper
    understanding of the linker, I suggest you read its manual page with `man 1 ld`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about `ldd`, see `man 1 ldd`.
  prefs: []
  type: TYPE_NORMAL
- en: For the curious mind, there's a detailed explanation of `vdso` in `man 7 vdso`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a statically linked program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have such a deep understanding of libraries and linking, we can
    create a **statically linked** program—that is, a program with all dependencies
    compiled into it. This makes the program—more or less—dependency-free. Making
    statically linked programs isn''t common but sometimes it can be desirable—for
    example, if you for some reason need to distribute a single precompiled binary
    to many computers without worrying about installing all the libraries. But please
    note: it''s not always possible to create completely dependency-free programs.
    If a program uses a library that depends on another library, this is not easily
    accomplished.'
  prefs: []
  type: TYPE_NORMAL
- en: The downside of making and using statically linked programs is that they get
    a lot bigger in size. Also, it's no longer possible to update the program's libraries
    without recompiling the entire program. So, bear in mind that this is only used
    in rare cases.
  prefs: []
  type: TYPE_NORMAL
- en: But, by knowing how to compile statically linked programs, you not only enhance
    your knowledge but will also be able to distribute precompiled binaries to systems
    without the necessary libraries, on many different distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need to have completed the two previous recipes—in other
    words, you need to have installed the `libconvert.so.1` library on the system,
    and you need to have compiled `temperature-v2.c`. You also need the GCC compiler,
    as usual.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll compile a statically linked version of `temperature-v2.c`.
    We''ll then remove the library from the system and notice that the statically
    linked program still works while the other doesn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: On Fedora and CentOS, the static library for `libc` isn't included by default.
    To install it, run `sudo dnf install glibc-static`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To link against the libraries statically, we need to have static versions of
    all the libraries. This means that we have to recreate the archive (`.a`) version
    of our library and install that as well. These steps are the same as from the
    *Creating a static library* recipe earlier in this chapter. First, we remove the
    object file, if we still have it. Then, we create a new one and create an archive
    from that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must install the static library on the system, preferably in the same
    location as the dynamic library. A static library doesn''t need to be executable
    since it''s included at compile time, not at runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile a statically linked version of `temperature-v2.c`. The `-static`
    option makes the binary statically linked, meaning it will include the library
    code in the binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we try the program, let''s examine it with `ldd`, and also its size
    with `du`. Notice that on my system, the binary is now almost 800 kilobytes (on
    another system, it''s 1.6 megabytes). Compare this to the dynamic version, which
    is only around 20 kilobytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove both the static and the dynamic libraries from the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the dynamically linked binary, which shouldn''t work since
    we have removed a library that it depends on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s try the statically linked binary, which should work just as
    well as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A statically linked program includes all the code from all the libraries, which
    is why our binary got so huge in this example. To build a statically linked program,
    we need static versions of all the program's libraries. That's why we needed to
    recreate the static library and place it in one of the system directories. We
    also needed a static version of the standard C library, which we installed if
    we were using a CentOS or Fedora machine. On Debian/Ubuntu, it's already installed.
  prefs: []
  type: TYPE_NORMAL
