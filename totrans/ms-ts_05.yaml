- en: Chapter 5. Third Party Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our TypeScript development environment would not amount to much if we were not
    able to re-use the myriad of existing JavaScript libraries, frameworks and general
    goodness. As we have seen, however, in order to use a particular third party library
    with TypeScript, we will first need a matching definition file.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after TypeScript was released, Boris Yankov set up a github repository
    to house TypeScript definition files for third party JavaScript libraries. This
    repository, named DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped))
    quickly became very popular, and is currently the place to go for high-quality
    definition files. DefinitelyTyped currently has over 700 definition files, built
    up over time from hundreds of contributors from all over the world. If we were
    to measure the success of TypeScript within the JavaScript community, then the
    DefinitelyTyped repository would be a good indication of how well TypeScript has
    been adopted. Before you go ahead and try to write your own definition files,
    check the DefinitelyTyped repository to see if there is one already available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a closer look at using these definition files,
    and cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading definition files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NuGet within Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TypeScript Definition manager (TSD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a JavaScript Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TypeScript with Backbone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TypeScript with Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TypeScript with ExtJs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading definition files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest method of including a definition file within your TypeScript project
    is to download the matching `.d.ts` file from DefinitelyTyped. This is a simple
    matter of finding the relevant file, and downloading the raw content. Let's assume
    that we wanted to start using jQuery within our project. We have found and downloaded
    the jQuery JavaScript library (v2.1.1), and included the relevant files within
    our project, under a directory named `lib`. To download the declaration file,
    simply browse to the `jquery` directory on DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped/tree/master/jquery](https://github.com/borisyankov/DefinitelyTyped/tree/master/jquery)),
    and then click on the `jquery.d.ts` file. This will open up a GitHub page with
    an editor view of the file. On the menu bar of this editor view, click on the
    **Raw** button. This will download the `jquery.d.ts` file, and allow you to save
    it within your project directory structure. Create a new directory under the **lib**
    folder called **typings**, and save the **jquery.d.ts** file there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your project file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading definition files](img/9665OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio project structure with a downloaded jquery.d.ts file
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now modify our `index.html` file to include the `jquery` JavaScript
    file, and begin writing TypeScript code that targets the jQuery library. Our `index.html`
    file will need to be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `<script>` tag of this `index.html` file now includes a link to `jquery-2.1.1.min.js`,
    and the second `<script>` tag includes a link to the TypeScript generated `app.js`.
    Open up the `app.ts` TypeScript file, delete the exiting source, and replace it
    with the following jQuery code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This snippet starts by defining an anonymous function to execute on the jQuery
    event of `document.ready`. The `document.ready` function is similar to the `window.onload`
    function we have been using previously, and will execute once jQuery has initialized.
    The second line of this snippet simply gets a handle to the DOM element named
    `content` using jQuery selector syntax, and then calls the `html` function to
    set its HTML value.
  prefs: []
  type: TYPE_NORMAL
- en: The `jquery.d.ts` file that we downloaded is providing us with the relevant
    module declarations that we need in order to compile jQuery within TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using NuGet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NuGet is a popular package management platform that will download required external
    libraries, and automatically include them in within your Visual Studio or WebMatrix
    project. It can be used for external libraries that are packaged as DLLs – such
    as StructureMap – or it can be used for JavaScript libraries and declaration files.
    NuGet is also available as a command-line utility.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Extension Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the NuGet package manager dialog within Visual Studio, select the **Tools**
    option on the main toolbar, then select **NuGet Package Manager**, and finally
    select **Manage NuGet Packages for Solution**. This brings up the NuGet package
    manager dialog. On the left-hand side of the dialog, click on **Online**. The
    NuGet dialog will then query the NuGet website and show a list of available packages.
    At the top right of the screen is a **search** box. Click within the **search**
    box, and type `jquery` to show all packages available within NuGet for jQuery,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Extension Manager](img/9665OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: NuGet Package manager dialog with results from a query on jQuery
  prefs: []
  type: TYPE_NORMAL
- en: Each package will have an **Install** button highlighted when you select the
    package in the **search results** panel. When a package is selected, the right-hand
    pane will show more details about the NuGet package in question. Note that the
    project details panel also shows the Version of the package that you are about
    to install. Clicking on the **Install** button will download relevant files –
    as well as any dependencies – and include them automatically within your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The installation directory that NuGet uses for JavaScript files is in fact called
    `Scripts` – and not the `lib` directory that we created earlier. NuGet uses the
    `Scripts` directory as a standard, so any packages that contain JavaScript will
    install the relevant JavaScript files into the `Scripts` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Installing declaration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find that most declaration files that are found on the DefinitelyTyped
    GitHub repository have a corresponding NuGet package. These packages are named
    `<library>`.`TypeScript.DefinitelyTyped`, as a standard naming convention. If
    we type `jquery typescript` into the search box, we will see a list of these DefinitelyTyped
    packages returned. The NuGet package we are looking for is named **jquery.TypeScript.DefinitelyTyped**,
    created by **Jason Jarret**, and is, at the time of writing, at version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DefinitelyTyped packages have their own internal version number, and these
    version numbers do not necessarily match the version of the JavaScript library
    that you are using. For example, the jQuery package is at version 2.1.1, but the
    corresponding TypeScript definition package shows a version number of 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the `jQuery.TypeScript.DefinitelyTyped` package will create a `typings`
    directory under the `Scripts` directory, and then include the `jquery.d.ts` definition
    file. This directory naming standard has been adopted by the various NuGet package
    authors.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Package Manager Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio also has a command-line version of the NuGet package manager available
    as a console application, and is also integrated into Visual Studio. Clicking
    on **Tools**, then **NuGet Package Manager**, and finally on **Package Manager
    Console**, will bring up a new Visual Studio window, and initialize the NuGet
    command line interface. The command line version of NuGet has a number of features
    that are not included in the GUI version. Type `get-help NuGet` to see the list
    of top-level command line arguments that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install a NuGet package from the console command line, simply type `install-package
    <packageName>`. As an example, to install the `jquery.TypeScript.DefinitelyTyped`
    package, simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command will connect to the NuGet server, and download and install the
    package into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the toolbar of the **Package Manager Console** window are two dropdown lists,
    **Package Source** and **Default Project**. If your Visual Studio solution has
    multiple projects, you will need to select the correct project for NuGet to install
    the package into from the **Default Project** dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for package names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Searching for package names from the command line is accomplished with the
    `Get-Package –ListAvailable` command. This command takes a `–Filter` parameter
    which acts as the search criteria. As an example, to find available packages that
    include the `definitelytyped` search string, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Installing a specific version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some JavaScript libraries that are not compatible with jQuery version
    2.x, and will require a version of jQuery that is in the 1.x range. To install
    a specific version of a NuGet package, we will need to specify the `-Version`
    parameter from the command line. To install the `jquery v1.11.1` package, as an
    example, run the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NuGet will either upgrade or downgrade the version of the package you are installing,
    if it finds another version already installed within your project. In the preceding
    example, we had already installed the latest version of jQuery (2.1.1) within
    our project, so NuGet will first remove `jQuery 2.1.1` before installing `jQuery
    1.11.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript Definition Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using Node as your TypeScript development environment, then you may
    consider using the **TypeScript Definition Manager** for DefinitelyTyped (**TSD**
    at [http://definitelytyped.org/tsd/](http://definitelytyped.org/tsd/)). TSD offers
    similar functionality to the NuGet Package Manager, but is specifically geared
    towards TypeScript definitions that are part of the DefinitelyTyped GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install TSD, use `npm` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will install `tsd prerelease v0.6.x`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, you will need v0.6.x and up in order to use the install
    keyword from the command line. If you simply type `npm install tsd –g`, then npm
    will `install v0.5.x`, which does not include the `install` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Querying for packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TSD allows for querying the package repository using the `query` keyword. To
    search for the `jquery` definition files, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will search the `DefinitelyTyped` repository for any
    definition files named `jquery.d.ts`. Since there is only one, the results returned
    from the search would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using wildcards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TSD also allows for the use of the asterisk `*` as a wildcard. To search for
    `DefinitelyTyped` declaration files that start with `jquery`, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This `tsd` command will search through the repository, and return results for
    declaration files that start with jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Installing definition files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install a definition file, use the `install` keyword as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will download the `jquery.d.ts` file into the following directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TSD will create the `\typings` directory based on the current directory where
    tsd was run, so make sure that you navigate to the same base directory in your
    project whenever you use TSD from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Using third party libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of the chapter, we will begin to explore some of the more popular
    third party JavaScript libraries, their declaration files, and how to write compatible
    TypeScript for each of these frameworks. We will compare Backbone, Angular, and
    ExtJs, which are all frameworks for building rich client-side JavaScript applications.
    During our discussion, we will see that some frameworks are highly compliant with
    the TypeScript language and its features, some are partially compliant, and some
    have very low compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a JavaScript framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing a JavaScript framework or library to develop Single Page Applications
    is a difficult and sometimes daunting task. It seems that there is a new framework
    appearing every other month, promising more and more functionality for less and
    less code.
  prefs: []
  type: TYPE_NORMAL
- en: To help developers compare these frameworks, and make an informed choice, Addy
    Osmani wrote an excellent article, named *Journey Through the JavaScript MVC Jungle*.
    ([http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/](http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/)).
  prefs: []
  type: TYPE_NORMAL
- en: In essence, his advice is simple – it's a personal choice – so try some frameworks
    out, and see what best fits your needs, your programming mindset, and your existing
    skill set. The **TodoMVC** project ([http://todomvc.com](http://todomvc.com)),
    which Addy started, does an excellent job of implementing the same application
    in a number of MV* JavaScript frameworks. This really is a reference site for
    digging into a fully working application, and comparing for yourself the coding
    techniques and styles of different frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Again, depending on the JavaScript library that you are using within TypeScript,
    you may need to write your TypeScript code in a specific way. Bear this in mind
    when choosing a framework – if it is difficult to use with TypeScript, then you
    may be better off looking at another framework with better integration. If it
    is easy and natural to work with the framework in TypeScript, then your productivity
    and overall development experience will be much better.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at some of the popular JavaScript libraries, along
    with their declaration files, and see how to write compatible TypeScript. The
    key thing to remember is that TypeScript generates JavaScript – so if you are
    battling to use a third party library, then crack open the generated JavaScript
    and see what the JavaScript code looks like that TypeScript is emitting. If the
    generated JavaScript matches the JavaScript code samples in the library's documentation,
    then you are on the right track. If not, then you may need to modify your TypeScript
    until the compiled JavaScript starts matching up with the samples.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to write TypeScript code for a third party JavaScript framework
    – particularly if you are working off the JavaScript documentation – your initial
    foray may just be one of trial and error. Along the way, you may find that you
    need to write your TypeScript in a specific way in order to match this particular
    third party library. The rest of this chapter shows how three different libraries
    require different ways of writing TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone is a popular JavaScript library that gives structure to web applications
    by providing models, collections and views, amongst other things. Backbone has
    been around since 2010, and has gained a very large following, with a wealth of
    commercial websites using the framework. According to [Infoworld.com](http://Infoworld.com),
    Backbone has over 1,600 Backbone related projects on GitHub that rate over 3 stars
    – meaning that it has a vast ecosystem of extensions and related libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at Backbone written in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To follow along with the code in your own project, you will need to install
    the following NuGet packages: `backbone.js` ( currently at v1.1.2), and `backbone.TypeScript.DefinitelyTyped`
    (currently at version 1.2.3).'
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance with Backbone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the Backbone documentation, we find an example of creating a `Backbone.Model`
    in JavaScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows a typical usage of Backbone in JavaScript. We start by creating
    a variable named `Note` that extends (or derives from) `Backbone.Model`. This
    can be seen with the `Backbone.Model.extend` syntax. The Backbone `extend` function
    uses JavaScript object notation to define an object within the outer curly braces
    `{ … }`. In the preceding code, this object has four functions: `initialize`,
    `author`, `coordinates` and `allowedToEdit`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Backbone documentation, the `initialize` function will be
    called once a new instance of this class is created. In our preceding sample,
    the `initialize` function simply creates an **alert** to indicate that the function
    was called. The `author` and `coordinates` functions are blank at this stage,
    with only the `allowedToEdit` function actually doing something: `return true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to simply copy and paste the above JavaScript into a TypeScript
    file, we would generate the following compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with a third party library, and a definition file from DefinitelyTyped,
    our first port of call should be to see if the definition file may be in error.
    After all, the JavaScript documentation says that we should be able to use the
    `extend` method as shown, so why is this definition file causing an error? If
    we open up the `backbone.d.ts` file, and then search to find the definition of
    the class `Model`, we will find the cause of the compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration file snippet shows some of the definition of the Backbone
    `Model` class. Here, we can see that the `extend` function is defined as `private
    static`, and as such, it will not be available outside the Model class itself.
    This, however, seems contradictory to the JavaScript sample that we saw in the
    documentation. In the preceding comment on the `extend` function definition, we
    find the key to using Backbone in TypeScript: prefer TypeScript''s extend functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This comment indicates that the declaration file for Backbone is built around
    TypeScript''s `extends` keyword – thereby allowing us to use natural TypeScript
    inheritance syntax to create Backbone objects. The TypeScript equivalent to this
    code, therefore, must use the `extends` TypeScript keyword to derive a class from
    the base class `Backbone.Model`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are now creating a class definition named `Note` that `extends` the `Backbone.Model`
    base class. This class then has the functions `initialize`, `author`, `coordinates`
    and `allowedToEdit`, similar to the previous JavaScript version. Our Backbone
    sample will now compile and run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With either of these versions, we can create an instance of the `Note` object
    by including the following script within an HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript sample simply waits for the jQuery `document.ready` event to
    be fired, and then creates an instance of the `Note` class. As documented earlier,
    the `initialize` function will be called when an instance of the class is constructed,
    so we would see an alert box appear when we run this in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: All of Backbone's core objects are designed with inheritance in mind. This means
    that creating new Backbone collections, views and routers will use the same `extends`
    syntax in TypeScript. Backbone, therefore, is a very good fit for TypeScript,
    because we can use natural TypeScript syntax for inheritance to create new Backbone
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Backbone allows us to use TypeScript inheritance to create objects, we can
    just as easily use TypeScript interfaces with any of our Backbone objects as well.
    Extracting an interface for the `Note` class above would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update our `Note` class definition to implement this interface as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our class definition now implements the `INoteInterface` TypeScript interface.
    This simple change protects our code from being modified inadvertently, and also
    opens up the ability to work with core Backbone objects in standard object-oriented
    design patterns. We could, if we needed to, apply the Factory Pattern described
    in [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces,
    Classes and Generics*, to return a particular type of Backbone Model – or any
    other Backbone object for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The declaration file for Backbone has also added generic syntax to some class
    definitions. This brings with it further strong typing benefits when writing TypeScript
    code for Backbone. Backbone collections (surprise, surprise) house a collection
    of Backbone models, allowing us to define collections in TypeScript as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a `NoteCollection` that derives from, or `extends` a `Backbone.Collection`,
    but also uses generic syntax to constrain the collection to handle only objects
    of type `Note`. This means that any of the standard collection functions such
    as `at()` or `pluck()` will be strongly typed to return `Note` models, further
    enhancing our type safety and Intellisense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the syntax used to assign a type to the internal `model` property of the
    collection class on the second line. We cannot use the standard TypeScript syntax
    `model: Note`, as this causes a compile time error. We need to assign the `model`
    property to a the class definition, as seen with the `model=Note` syntax, or we
    can use the `{ new(): Note }` syntax as seen on the last line.'
  prefs: []
  type: TYPE_NORMAL
- en: Using ECMAScript 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backbone also allows us to use ECMAScript 5 capabilities to define getters
    and setters for `Backbone.Model` classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we have defined an interface with two properties, named `ISimpleModel`.
    We then define a `SimpleModel` class that derives from `Backbone.Model`, and also
    implements the `ISimpleModel` interface. We then have ES 5 getters and setters
    for our `Name` and `Id` properties. Backbone uses class attributes to store model
    values, so our getters and setters simply call the underlying `get` and `set`
    methods of `Backbone.Model`.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone TypeScript compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, Backbone allows us to use all of TypeScript's language features
    within our code. We can use classes, interfaces, inheritance, generics and even
    ECMAScript 5 properties. All of our classes also derive from base Backbone objects.
    This makes Backbone a highly compatible library for building web applications
    with TypeScript. We will explore more of the Backbone framework in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJs (or just Angular) is also a very popular JavaScript framework, and
    is maintained by Google. Angular takes a completely different approach to building
    JavaScript SPA's, introducing an HTML syntax that the running Angular application
    understands. This provides the application with two-way data binding capabilities,
    which automatically synchronizes models, views and the HTML page. Angular also
    provides a mechanism for **Dependency Injection** (**DI**), and uses services
    to provide data to your views and models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a sample from the Angular Tutorial, found in step 2,
    where we start to build a controller named `PhoneListCtrl`. The example provided
    in the tutorial shows the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet is typical of Angular JavaScript syntax. We start by creating
    a variable named `phonecatApp`, and register this as an Angular module by calling
    the `module` function on the `angular` global instance. The first argument to
    the `module` function is a global name for the Angular module, and the empty array
    is a place-holder for other modules that will be injected via Angular's Dependency
    Injection routines.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `controller` function on the newly created `phonecatApp` variable
    with two arguments. The first argument is the global name of the controller, and
    the second argument is a function that accepts a specially named Angular variable
    named `$scope`. Within this function, the code sets the `phones` object of the
    `$scope` variable to be an array of JSON objects, each with a `name` and `snippet`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we continue reading through the tutorial, we find a unit test that shows
    how the `PhoneListCtrl` controller is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of this code snippet use a global function called `describe`,
    and within this function another function called `it`. These two functions are
    part of a unit testing framework named Jasmine. We will cover unit testing in
    our next chapter, but for the time being, lets' focus on the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a variable named `scope` to be an empty JavaScript object, and then
    a variable named `ctrl` that uses the `new` keyword to create an instance of our
    `PhoneListCtrl` class. The `new PhoneListCtrl(scope)` syntax shows that Angular
    is using the definition of the controller just like we would use a normal class
    in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the same object in TypeScript would allow us to use TypeScript classes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first line is the same as in our previous JavaScript sample. We then, however,
    use the TypeScript class syntax to create a class named `PhoneListCtrl`. By creating
    a TypeScript class, we can now use this class as shown in our Jasmine test code:
    `ctrl = new PhoneListCtrl(scope)`. The `constructor` function of our `PhoneListCtrl`
    class now acts as the anonymous function seen in the original JavaScript sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Angular classes and $scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s expand our `PhoneListCtrl` class a little further, and have a look at
    what it would look like when completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note in this class, is that we are defining a variable named
    `myScope`, and storing the `$scope` argument that is passed in via the constructor,
    into this internal variable. This is again because of JavaScript's lexical scoping
    rules. Note the call to `_.bindAll` at the end of the constructor. This Underscore
    utility function will ensure that whenever the `GetPhonesSuccess` function is
    called, it will use the variable `this` in the context of the class instance,
    and not in the context of the calling code. We will discuss the usage of `_.bindAll`
    in detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetPhonesSuccess` function uses the `this.myScope` variable within its
    implementation. This is why we needed to store the initial `$scope` argument in
    an internal variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we notice from this code, is that the `myScope` variable is typed
    to an interface named `IScope`, which will need to be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This `IScope` interface just contains an array of objects of type `IPhone` (pardon
    the unfortunate name of this interface – it can hold Android phones as well).
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that we don't have a standard interface or TypeScript type
    to use when dealing with `$scope` objects. By its nature, the `$scope` argument
    will change its type depending on when and where the Angular runtime calls it,
    hence our need to define an `IScope` interface, and strongly type the `myScope`
    variable to this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing to note on the constructor function of the `PhoneListCtrl`
    class is the type of the `$http` argument. It is set to be of type `ng.IHttpService`.
    This `IHttpService` interface is found in the declaration file for Angular. In
    order to use TypeScript with Angular variables such as `$scope` or `$http`, we
    need to find the matching interface within our declaration file, before we can
    use any of the Angular functions available on these variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last point to note in this constructor code is the final argument, named
    `Phone`. It does not have a TypeScript type assigned to it, and so automatically
    becomes of type `any`. Let''s take a quick look at the implementation of this
    `Phone` service, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this code snippet again creates a global variable named `phonecatServices`,
    using the `angular.module` global function. We then call the `factory` function
    available on the `phonecatServices` variable, in order to define our `Phone` resource.
    This `factory` function uses a string named `'Phone'` to define the `Phone` resource,
    and then uses Angular's dependency injection syntax to inject a `$resource` object.
    Looking through this code, we can see that we cannot easily create standard TypeScript
    classes for Angular to use here. Nor can we use standard TypeScript interfaces
    or inheritance on this Angular service.
  prefs: []
  type: TYPE_NORMAL
- en: Angular TypeScript compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing Angular code with TypeScript, we are able to use classes in certain
    instances, but must rely on the underlying Angular functions such as `module`
    and `factory` to define our objects in other cases. Also, when using standard
    Angular services, such as `$http` or `$resource`, we will need to specify the
    matching declaration file interface in order to use these services. We can therefore
    describe the Angular library as having medium compatibility with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance – Angular versus Backbone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is a very powerful feature of object-oriented programming, and is
    also a fundamental concept when using JavaScript frameworks. Using a Backbone
    controller or an Angular controller within each framework relies on certain characteristics,
    or functions being available. We have seen, however, that each framework implements
    inheritance in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: As JavaScript does not have the concept of inheritance, each framework needs
    to find a way to implement it, so that the framework can allow us to extend base
    classes and their functionality. In Backbone, this inheritance implementation
    is via the `extend` function of each Backbone object. As we have seen, the TypeScript
    `extends` keyword follows a similar implementation to Backbone, allowing the framework
    and language to dovetail each other.
  prefs: []
  type: TYPE_NORMAL
- en: Angular, on the other hand, uses its own implementation of inheritance, and
    defines functions on the angular global namespace to create classes (that is `angular.module`).
    We can also sometimes use the instance of an application (that is `<appName>.controller`)
    to create modules or controllers. We have found, though, that Angular uses controllers
    in a very similar way to TypeScript classes, and we can therefore simply create
    standard TypeScript classes that will work within an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only skimmed the surface of both the Angular TypeScript syntax
    and the Backbone TypeScript syntax. The point of this exercise was to try and
    understand how TypeScript can be used within each of these two third party frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to visit [http://todomvc.com](http://todomvc.com), and have a look at
    the full source-code for the Todo application written in TypeScript for both Angular
    and Backbone. They can be found on the **Compile-to-JS** tab in the example section.
    These running code samples, combined with the documentation on each of these sites,
    will prove to be an invaluable resource when trying to write TypeScript syntax
    with an external third party library such as Angular or Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Microsoft TypeScript team and the Google Angular team have just completed
    a months long partnership, and have announced that the upcoming release of Angular,
    named Angular 2.0, will be built using TypeScript. Originally, Angular 2.0 was
    going to use a new language named AtScript for Angular development. During the
    collaboration work between the Microsoft and Google teams, however, the features
    of AtScript that were needed for Angular 2.0 development have now been implemented
    within TypeScript. This means that the Angular 2.0 library will be classed as
    highly compatible with TypeScript, once the Angular 2.0 library, and the 1.5 edition
    of the TypeScript compiler are available.
  prefs: []
  type: TYPE_NORMAL
- en: ExtJs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ExtJs is a popular JavaScript library that has a wide variety of widgets, grids,
    graphing components, layout components and more. With release 4.0, ExtJs incorporated
    a model, view, controller style of application architecture into their libraries.
    Although it is free for open-source development, ExtJs requires a license for
    commercial use. It is popular with development teams that are building web-enabled
    desktop replacements, as its look and feel is comparable to normal desktop applications.
    ExtJs, by default, ensures that each application or component will look and feel
    exactly the same, no matter which browser it is run in, and it requires little
    or no need for CSS or HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The ExtJs team, however, has not released an official TypeScript declaration
    file for ExtJs, despite much community pressure. Thankfully, the wider JavaScript
    community has come to the rescue, beginning with Mike Aubury. He wrote a small
    utility program to generate declaration files from the ExtJs documentation ([https://github.com/zz9pa/extjsTypescript](https://github.com/zz9pa/extjsTypescript)).
  prefs: []
  type: TYPE_NORMAL
- en: Whether this work influenced the current version of the ExtJs definitions on
    DefinitelyTyped or not, remains to be seen, but the original definitions from
    Mike Aubury and the current version from brian428 on DefinitelyTyped are very
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes in ExtJs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ExtJs is a JavaScript library that does things in its own way. If we were to
    categorize Backbone, Angular and ExtJs, we might say that Backbone is a highly
    compliant TypeScript library. In other words, the language features of classes
    and inheritance within TypeScript are highly compliant with Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: Angular in this case would be a partially compliant library, with some elements
    of Angular objects complying with the TypeScript language features. ExtJs, on
    the other hand, would be a minimally compliant library, with little or no TypeScript
    language features applicable to the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a sample ExtJs 4.0 application written in TypeScript.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating an ExtJs application by calling the `application` function
    on the `Ext` global instance. The `application` function then uses a JavaScript
    object, enclosed within the first and last curly braces `{ }` to define properties
    and functions. This ExtJs application sets the `name` property to be `SampleApp`,
    the `appFolder` property to be `/code/sample`, and the `controllers` property
    to be an array with a single entry: `''SampleController''`.'
  prefs: []
  type: TYPE_NORMAL
- en: We then define a `launch` property, which is an anonymous function. This `launch`
    function then uses the `create` function on the global `Ext` instance to create
    a class. The `create` function uses the `"Ext.container.Viewport"` name to create
    an instance of the `Ext.container.Viewport` class, which has the properties `layout`
    and `items`. The `layout` property can only contain one of a specific set of values,
    for example `'fit'`, `'auto'` or `'table'`. The `items` array contains further
    ExtJs specific objects, which are created depending on what their `xtype` property
    suggests.
  prefs: []
  type: TYPE_NORMAL
- en: ExtJs is one of those libraries that is not intuitive. As a programmer, you
    will need to have one browser window open with the library documentation at all
    times, and use it to figure out what each property means for each type of available
    class. It also has a lot of magic strings – in the preceding sample, the `Ext.create`
    function would fail if we miss-typed the `'Ext.container.Viewport'` string, or
    simply forgot to capitalize it in the right places. To ExtJs, `'viewport'` is
    different to `'ViewPort'`. Remember that one of our solutions to magic strings
    within TypeScript is to use enums. Unfortunately, the current version of the ExtJs
    declaration file does not have a set of enums for these class types.
  prefs: []
  type: TYPE_NORMAL
- en: Using type casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can, however, use the TypeScript language feature of type casting to help
    with writing ExtJs code. If we know what type of ExtJs object we are trying to
    create, we can cast the JavaScript object to this type, and then use TypeScript
    to check whether the properties we are using are correct for that type of ExtJs
    object. To help with this concept, let''s just take the outer definition of the
    `Ext.application` into account. Stripped of the inner code, the call to the `application`
    function on the `Ext` global object would be reduced to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the TypeScript declaration files, type casting, and a healthy dose of
    ExtJs documentation, we know that the inner JavaScript object should be of type
    `Ext.app.IApplication`, and we can therefore cast this object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line of this code snippet now uses the TypeScript type casting syntax,
    to cast the JavaScript object between the curly braces `{ }` to a type of `Ext.app.IApplication`.
    This gives us strong type checking, and Intellisense, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using type casting](img/9665OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio intellisense for an ExtJs configuration block
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, these explicit type casts can be used on any JavaScript
    object that is being used to create ExtJs classes. The declaration file for ExtJs
    currently on DefinitelyTyped uses the same names for its object definitions as
    the ExtJs documentation uses, so finding the correct type should be rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding technique of using explicit type casting is just about the only
    language feature of TypeScript that we can use with the ExtJs library – but this
    still highlights how strong typing of objects can assist us in our development
    experience, making our code more robust and resistant to errors.
  prefs: []
  type: TYPE_NORMAL
- en: ExtJs specific TypeScript compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using ExtJs on a regular basis, then you may want to take a look
    at the work done by Gareth Smith, Fabio Parra dos Santos and their team at [https://github.com/fabioparra/TypeScript](https://github.com/fabioparra/TypeScript).
    This project is a fork of the TypeScript compiler that will emit ExtJs classes
    from standard TypeScript classes. Using this version of the compiler turns the
    tables on normal ExtJs development, allowing for natural TypeScript class syntax,
    the use of inheritance via the `extends` keyword, as well as natural module naming,
    without the need for magic strings. The work done by this team shows that because
    the TypeScript compiler is open-source, it can be extended and modified to emit
    JavaScript in a specific way, or to target a specific library. Hats off to Gareth,
    Fabio and their team for their ground-breaking work in this area.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have had a look at third party JavaScript libraries and
    how they can be used within a TypeScript application. We started by looking at
    the various ways of including community released versions of TypeScript declaration
    files within our projects, from downloading the raw files, to using package managers
    like NuGet and TSD. We then looked at three types of third party libraries, and
    discussed how to integrate these libraries with TypeScript. We explored Backbone,
    which can be categorized as a highly compliant third party library, Angular, which
    is a partially compliant library, and ExtJs which is a minimally compliant library.
    We saw how various features of the TypeScript language can co-exist with these
    libraries, and showed what TypeScript equivalent code would look like in each
    of these cases. In the next chapter, we will look at Test Driven Development,
    and explore some of the libraries that are available for unit testing, integration
    testing, and automated acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
