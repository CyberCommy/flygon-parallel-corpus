- en: Chapter 6. Input and Collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers recipes surrounding game control input (keyboard, mouse,
    and gamepad), and collisions with obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Axis Mappings – keyboard, mouse, and gamepad directional input for an FPS character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis Mappings – normalized input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action Mappings – one-button responses for an FPS character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Axis and Action Mappings from C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse UI input handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UMG keyboard UI shortcut keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision – letting objects pass through one another using Ignore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision – picking up objects using Overlap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision – preventing interpenetration using Block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good input controls are extremely important in your game. Providing all of keyboard,
    mouse, and especially gamepad input is going to make your game much more palatable
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Introduction](img/00099.jpeg) You can use Xbox 360 and PlayStation controllers
    on your Windows PC—they have USB input. Check your local electronics shops for
    USB game controllers in order to find some good ones. You can also use a wireless
    controller with a game controller wireless receiver adapter connected to your
    PC.'
  prefs: []
  type: TYPE_NORMAL
- en: Axis Mappings – keyboard, mouse and gamepad directional input for an FPS character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of input mapping: **Axis mappings** and **Action mappings**.
    Axis mappings are inputs that you hold down for an extended period of time to
    get their effect (for example, holding the *W* key to move the player forward),
    while Action mappings are one-off inputs (such as pressing the *A* key on the
    gamepad to make the player jump). In this recipe, we''ll cover how to set up keyboard,
    mouse, and gamepad axis-mapped input controls to move an FPS character.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must have a UE4 project, which has a main character player in it, and a
    ground plane to walk on, ready for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a C++ class, `Warrior`, deriving from `Character`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Launch UE4, and derive a Blueprint, `BP_Warrior`, based on your `Warrior` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create and select a new Blueprint for your `GameMode` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Settings** | **Project Settings** | **Maps & Modes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** icon beside the default **GameMode** drop-down menu, which
    will create a new Blueprint of the `GameMode` class, and name of your choice (say,
    `BP_GameMode`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the new `BP_GameMode` Blueprint class that you have created to
    edit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your `BP_GameMode` blueprint, and select your Blueprinted `BP_Warrior`
    class as default `Pawn` Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To set up the keyboard''s input driving the player, open **Settings** | **Project
    Settings** | **Input**. In the following steps, we will complete the process that
    drives the player forward in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** icon beside the **Axis Mappings** heading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Axis Mappings** supports continuous (button-held) input, while **Action Mappings**
    supports one-off events.'
  prefs: []
  type: TYPE_NORMAL
- en: Give a name to the Axis mapping. This first example will show how to move the
    player forward, so name it something like **Forward**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath **Forward**, select a keyboard key to assign to this Axis mapping,
    such as *W*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** icon beside **Forward**, and select a game controller input
    to map to moving the player Forward (such as gamepad Left Thumbstick Up).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete **Axis Mappings** for Back, Left, and Right with keyboard, gamepad,
    and, optionally, mouse input bindings for each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From your C++ code, override the `SetupPlayerInputComponent` function for the
    `AWarrior` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a `Forward` function inside your `AWarrior` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Write and complete functions for the rest of the input directions, `AWarrior::Back`,
    `AWarrior::Left`, and `AWarrior::Right`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UE4 Engine allows wire-up input events directly to C++ function calls. The
    function called by an input event are member functions of some class. In the preceding
    example, we routed both the pressing of the *W* key and holding of the gamepad's
    Left Thumbstick Up to the `AWarrior::Forward` C++ function. The instance to call
    `AWarrior::Forward` on is the instance that routed the controller's input. That
    is controlled by the object set as the player's avatar in the `GameMode` class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of entering the `Forward` input axis binding in the UE4 editor, you
    can actually code it in from C++. We'll describe this in detail in a later recipe,
    *Adding Axis and Action Mappings from C++*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis Mappings – normalized input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've noticed, inputs of 1.0 right and 1.0 forward will actually sum to
    a total of 2.0 units of speed. This means it is possible to move faster diagonally
    than it is to move in purely forward, backward, left, or right directions. What
    we really should do is clamp off any input value that results in speed in excess
    of 1.0 units while maintaining the direction of input indicated. We can do this
    by storing the previous input values, and overriding the `::Tick()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open a project, and set up a `Character` derivative class (let's call ours `Warrior`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Override the `AWarrior::SetupPlayerInputComponent( UInputComponent* Input )`
    function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the corresponding `::Forward`, `::Back`, `::Right` and `::Left` functions
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AWarrior::Tick()` function, modify the input values after normalizing
    any oversize in the input vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We normalize the input vector when it is over a magnitude of 1.0\. This constricts
    the maximum input velocity to 1.0 units (rather than 2.0 units when full up and
    full right are pressed, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Action Mappings – one button responses for an FPS character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Action mapping is for handling single-button pushes (not buttons that are
    held down). For buttons that should be held down, be sure to use an Axis mapping
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a UE4 project ready with the actions that you need to complete, such as
    `Jump` or `ShootGun`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open **Settings** | **Project Settings** | **Input**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Action Mappings** heading, and click on the **+** icon beside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start to type in the actions that should be mapped to button pushes. For example,
    type in `Jump` for the first Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a key to press for that action to occur, for example, **Space Bar**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you would like the same action triggered by another key push, click on the
    **+** beside your **Action Mappings** name, and select another key to trigger
    the Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want that the **Shift**, **Ctrl**, **Alt**, or **Cmd** keys should be
    held down for the Action to occur, be sure to indicate that in the checkboxes
    to the right of the key selection box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To link your Action to a C++ code function, you need to override the `SetupPlayerInputComponent(UInputControl*
    control )` function. Enter the following code inside that function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Action Mappings** are single-button-push events that fire off C++ code to
    run in response to them. You can define any number of actions that you wish in
    the UE4 Editor, but be sure to tie up **Action Mappings** to actual key pushes
    in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can list the Actions that you want mapped from C++ code. See the following
    recipe on *Adding Axis and Action Mappings from C++* for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Axis and Action Mappings from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Axis Mappings** and **Action Mappings** can be added to your game via the
    UE4 Editor, but we can also add them directly from C++ code. Since the wireup
    to C++ functions is from C++ code anyway, you may find it convenient to define
    your Axis and Action Mappings in C++ as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need a UE4 project to which you''d like to add some Axis and Action mappings.
    You can delete the existing Axis and Action mappings listed in **Settings** |
    **Project Settings** | **Input** if you are adding them via C++ code. To add your
    custom axis and action mappings, there are two C++ functions that you need to
    know about: the `UPlayerInput::AddAxisMapping` and `UPlayerInput:: AddActionMapping`.
    These are member functions available on the `UPlayerInput` object. The `UPlayerInput`
    object is inside the `PlayerController` object, accessible via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the two static member functions of `UPlayerInput` to create
    your axis and action mappings if you''d prefer not to access player controllers
    individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, we need to define our `FInputAxisKeyMapping` or `FInputActionKeyMapping`
    objects, depending on whether you are hooking up an Axis key mapping (for buttons
    that are held down for input) or an Action key mapping (for one-off events—buttons
    that are pressed once for input).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Axis key mappings, we define an `FInputAxisKeyMapping` object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will include the string name for the action, the key to press (use the
    EKeys `enum`), and whether or not *Shift*, *Ctrl*, *Alt*, or *cmd* (Mac) should
    be held to trigger the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For action key mappings, define `FInputActionKeyMapping`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will include the string name for the action, the key to press, and whether
    or not *Shift*, *Ctrl*, *Alt*, or *cmd* (Mac) should be held to trigger the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your player `Pawn` class `SetupPlayerInputComponent` function, register
    your axis and action key mappings to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PlayerInput` object connected to a specific controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternatively, you could register to the static member functions of the
    `UPlayerInput` object directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure you're using the correct function for Axis versus Action mappings!
  prefs: []
  type: TYPE_NORMAL
- en: 'Register your Action and Axis mappings to C++ functions using C++ code just
    as shown in the preceding two recipes, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The action and axis mapping registration functions allow you to set up your
    input mappings from C++ code directly. The C++ coded input mappings are essentially
    the same as entering the input mappings in the **Settings** | **Project Settings**
    | **Input** dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse UI input handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the **Unreal Motion Graphics (UMG)** toolkit, you will find that
    mouse events are very easy to handle. We can register C++ functions to run after
    mouse clicks or other types of interactions with the UMG components.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, event registration will be via Blueprints; but in this recipe, we will
    outline how to write and wire-up C++ functions to UMG events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a UMG canvas in your UE4 project. From there, we'll register event handlers
    for the `OnClicked`, `OnPressed`, and `OnReleased` events.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click in your **Content Browser** (or click on **Add New**), and select
    **User Interface** | **Widget Blueprint**, as shown in the following screenshot.
    This will add an editable widget blueprint to your project.![How to do it...](img/00101.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on your **Widget Blueprint** to edit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to the interface by dragging it from the palette on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the **Details** panel for your button until you find the **Events**
    subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+** icon beside any event that you'd like to handle.![How to
    do it...](img/00102.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the event that appears in Blueprints to any C++ `UFUNCTION()` that
    has the `BlueprintCallable` tag in the macro. For example, in your `GameMode`
    class derivative, you could include a function such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Trigger the function call by routing to it in the Blueprints diagram under the
    event of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct and display your UI by calling **Create Widget**, followed by **Add
    to Viewport** in the **Begin Play** function of your `GameMode` (or any such main
    object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your widget Blueprint's buttons events can be easily connected to Blueprints
    events, or C++ functions via the preceding method.
  prefs: []
  type: TYPE_NORMAL
- en: UMG keyboard UI shortcut keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every user interface needs shortcut keys associated with it. To program these
    into your UMG interface, you can simply wire-up certain key combinations to an
    Action mapping. When the Action triggers, just invoke the same Blueprints function
    that the UI button itself triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have a UMG interface created already, as shown in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In **Settings** | **Project Settings** | **Input**, define a new Action mapping
    for your hot key event, for example, `HotKey_UIButton_Spell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire up the event to your UI's function call either in Blueprints or in C++
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wiring up an Action Mapping with a short circuit to the function called by the
    UI will allow you to implement hot keys in your game program nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Collision – letting objects pass through one another using Ignore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collision settings are fairly easy to get hold of. There are three classes
    of intersection for collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ignore`: Collisions that pass through each other without any notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Overlap`: Collisions that trigger the `OnBeginOverlap` and `OnEndOverlap`
    events. Interpenetration of objects with an Overlap setting is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Block`: Collisions that prevent all interpenetration, and prevent objects
    from overlapping each other at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects are classed into one of many **Object Type**. The **Collision** settings
    for a particular Blueprint's Component allow you to class the object as an **Object
    Type** of your choice as well as to specify how that object collides with all
    other objects of all other types. This takes a tabular format in the **Details**
    | **Collision** section of the Blueprint Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following screenshot shows the **Collision** settings for
    a character''s `CapsuleComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision – letting objects pass through one another using Ignore](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have a UE4 project with some objects that you'd like to program intersections
    for.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the Blueprint editor for the object that you'd like other objects to simply
    pass through and ignore. Under the **Components** listing, select the component
    that you'd like to program settings for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With your component selected, see your **Details** tab (usually on the right).
    Under **Collision Presets**, select either the **NoCollision** or **Custom…**
    presets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you select the **NoCollision** preset, you can just leave it at that, and
    all collisions will be ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you select the **Custom…** preset, then choose either of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NoCollision** under the **Collision Enabled** drop-down menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a collision mode under **Collision Enabled** involving Queries, and be
    sure to check the **Ignore** checkbox for each **Object Type** that you'd like
    it to ignore collisions with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ignored collisions will not fire any events or prevent interpenetrations between
    objects marked as such.
  prefs: []
  type: TYPE_NORMAL
- en: Collision – picking up objects using Overlap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Item pickup is a pretty important thing to get down cleanly. In this recipe,
    we'll outline how to get item pickups working using **Overlap** events on Actor
    Component primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous recipe, *Collisions: Letting Objects pass through each other using
    Ignore*, describes the basics of collisions. You should read it for background
    before beginning this recipe. What we''ll do here is create a **New Object Channel...**
    to identify `Item` class objects so that they can be programmed for overlaps only
    with the player avatar''s collision volume.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by creating a unique collision Channel for the `Item` object's collision
    primitive. Under **Project Settings** | **Collision**, create a new Object Channel
    by going to **New Object Channel…**![How to do it...](img/00104.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new Object Channel as `Item`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take your `Item` actor and select the primitive component on it that is used
    to intersect for pickup with the player avatar. Make the **Object Type** of that
    primitive an `Item` class **Object Type**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Overlap** checkbox against the `Pawn` class **Object Type** as shown
    in the following screenshot:![How to do it...](img/00105.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the **Generate Overlap Events** checkbox is checked.![How to do
    it...](img/00106.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the player actor who will pick up the items, and select the component on
    him that feels for the items. Usually, this will be his `CapsuleComponent`. Check
    **Overlap** with the `Item` object.![How to do it...](img/00107.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the Player overlaps the item, and the item overlaps the player pawn. We
    do have to signal overlaps it both ways (`Item` Overlaps `Pawn` and Pa`w`n Overlaps
    `Item`) for it to work properly. Ensure that **Generate Overlap Events** is also
    checked for the `Pawn` intersecting component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we have to complete the `OnComponentBeginOverlap` event for either the
    item or the Player's pickup volume, using either Blueprints or C++ code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you prefer Blueprints, in the **Events** section of the **Details** pane
    of the Coin's intersectable Component, click on the **+** icon beside the **On
    Component Begin Overlap** event.![How to do it...](img/00108.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `OnComponentBeginOverlap` event that appears in your `Actor` Blueprint
    diagram to wire-in Blueprints code to run when an overlap with the Player's capsule
    volume occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you prefer C++, you can write and attach a C++ function to the `CapsuleComponent`.
    Write a member function in your player''s avatar class with a signature as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**In UE 4.13, the OnOverlapsBegin function''s signature has changed to:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Complete the implementation of the `OnOverlapsBegin()` function in your `.cpp`
    file, making sure to end the function name with `_Implementation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, provide a `PostInitializeComponents()` override to connect the `OnOverlapsBegin()`
    function with overlaps to the capsule in your avatar''s class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Overlap** event raised by the engine allows code to run when two UE4 `Actor`
    Components overlap, without preventing interpenetration of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Collision – preventing interpenetration using Block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blocking means that the `Actor` components will be prevented from interpenetration
    in the engine, and any collision between two primitive shapes will be resolved,
    and not overlapping, after collisions are found.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Begin with a UE4 project that has some objects with Actors having collision
    primitives attached to them (`SphereComponents`, `CapsuleComponents`, or `BoxComponents`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the Blueprint of an actor that you want to block another actor with. For
    example, we want the Player actor to block other Player actor instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark primitives inside the actor that you do not want interpenetrating with
    other components as Blocking those components in the **Details** pane.![How to
    do it...](img/00109.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When objects **Block** one another, they will not be allowed to interpenetrate.
    Any interpenetration will be automatically resolved, and the objects will be pushed
    off each other.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can override the `OnComponentHit` function to run code when two objects
    hit each other. This is distinct from the `OnComponentBeginOverlap` event.
  prefs: []
  type: TYPE_NORMAL
