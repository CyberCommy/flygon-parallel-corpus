- en: String Algorithms and Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many popular string processing algorithms available, depending upon
    the problem being solved. However, one of the most important, popular, and useful
    string processing problems is to find a given substring or pattern from some given
    text. It has various application uses, such as searching an element from a text
    document, plagiarism detection, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study the standard string processing or pattern matching
    algorithms that find out the locations of the given pattern or substring in some
    given text. We will also be discussing the brute-force algorithm, as well as the
    Rabin-Karp, **Knuth-Morris-Pratt** (**KMP**), and Boyer-Moore pattern matching
    algorithms. We will also discuss some basic concepts related to strings. We will
    be discussing all of the algorithms with an easy explanation, including examples
    and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is aimed at discussing algorithms that are focused on being related
    to strings. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basic concepts of strings in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning pattern matching algorithms and their implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing the Rabin-Karp pattern matching algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing the Knuth-Morris-Pratt (KMP) algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing the Boyer-Moore pattern matching algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the programs based on the concepts and algorithms discussed in this chapter
    are provided in the book as well as in the GitHub repository at the following
    link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: String notations and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are basically a sequence of objects, mainly a sequence of characters.
    As with any other data type, such as an int or float, we need to store the data
    and operations that have to be applied to them. String data types allow us to
    store the data, and Python provides a rich set of operations and functions that
    can be applied to the data of the string data type. Most of the operations and
    functions provided by Python 3.7 that can be applied to the strings were described
    in detail in [Chapter 1](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml), *Python
    Objects, Types, and Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are mainly textual data that is generally handled very efficiently.
    The following is an example of a string (S)—`"packt publishing"`.
  prefs: []
  type: TYPE_NORMAL
- en: A substring is also a sequence of characters that's part of the given string.
    For example, `"packt"` is the substring for the string `"packt publishing"`.
  prefs: []
  type: TYPE_NORMAL
- en: A subsequence is a sequence of characters that can be obtained from the given
    string by removing some of the characters from the string but by keeping the order
    of occurrence of the characters. For example, `"pct pblishing"` is a valid subsequence
    for the string `"packt publishing"` that is obtained by removing the characters
    `a`, `k`, and `u`. However, this is not a substring. A subsequence is different
    from a substring, since it can be considered as a generalization of substrings.
  prefs: []
  type: TYPE_NORMAL
- en: The prefix of a string, `s`, is the substring of `s` in that it is present in
    the starting of the string. There is also another string, `u`, that exists in
    the string s after the prefix. For example, the substring `"pack"` is a prefix
    for the string `(s) = "packt publishing"` as it is starting the substring and
    there is another substring after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suffix `(d)` is a substring that is present at the end of the string (s)
    so that there is another nonempty substring existing before substring d. For example,
    the substring `"shing"` is the suffix for the string `"packt publishing"`. Python
    has built-in functions to check whether a string has a given prefix or suffix,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching algorithms are the most important string processing algorithms,
    and we will be discussing them in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pattern matching algorithm is used to determine the index positions where
    a given pattern string (P) is matched in a text string (T). It returns `"pattern
    not found"` if the pattern does not match in the text string. For example, for
    the given string (s) = `"packt publisher"`, and the pattern (p)= `"publisher"`,
    the pattern matching algorithm returns the index position where the pattern is
    matched in the text string.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss four pattern matching algorithms, that is,
    the brute-force method, as well as the Rabin-Karp algorithm, Knuth-Morris-Pratt
    (KMP), and Boyer Moore pattern matching algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The brute-force algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The brute-force algorithm, or naive approach for the pattern matching algorithm,
    is very basic. Using this, we simply test all the possible combinations of the
    input pattern in the given string to find the position of the occurrence of the
    pattern. This algorithm is very naive and is not suitable if the text is very
    long.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we start by comparing the characters of the pattern and the text string
    one by one, and if all the characters of the pattern are matched with the text,
    we return the index position of the text where the first character of the pattern
    is placed. If any character of the pattern is mismatched with the text string,
    we shift the pattern by one place. We continue comparing the pattern and text
    string by shifting the pattern by one index position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the brute-force algorithm works, let''s look at an
    example. Suppose we have a text string (T)= **acbcabccababcaacbcac**, and the
    pattern string (P) is **acbcac**. Now, the objective of the pattern matching algorithm
    is to determine the index position of the pattern string in the given text, T,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/248df9b8-9f4d-4cb4-a404-b08d3cc5cef8.png)'
  prefs: []
  type: TYPE_IMG
- en: We start by comparing the first character of the text, that is, **a**, and the
    characters of the pattern. Here, the initial five characters of the pattern are
    matched, and there is a mismatch in the last character of the pattern. Since there
    is a mismatch, we further shift the pattern by one place.  We again start comparing
    the first character of the pattern and the second character of the text string
    one by one. Here, character **c** of the text string does not match with the character
    **a** of the pattern. Since it is a mismatch, we shift the pattern by one space,
    as shown in the preceding diagram. We continue comparing the characters of the
    pattern and the text string until we traverse the whole text string. In the preceding
    example, we find a match at index position **14**, which is shown with the arrows
    to **aa**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, let''s consider the Python implementation of the brute-force algorithm
    for pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code for the brute-force approach, we start by computing the
    length of the given text strings and pattern. We also initialize the looping variables
    with `0` and set the flag to `False`. This variable is used to continue searching
    for a match of the pattern in the string. If the flag is `False` by the end of
    the text string, it means that there is no match of the pattern at all in the
    text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we start the searching loop from the `0th` index to the end of the text
    string. In this loop, we have a count variable that is used to keep track of the
    length up to which the pattern and the text have been matched. Next, we have another
    nested loop that runs from the `0th` index to the length of the pattern. Here,
    the variable `i` keeps track of the index position in the text string and the
    variable `j` keeps track of the characters in the pattern. Next, we compare the
    characters of the patterns and the text string using the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, we increment the count variable after every match of the character
    of the pattern in the text string. Then, we continue matching the characters of
    the pattern and text string. If the length of the pattern becomes equal to the
    count variable, it means there is a match.
  prefs: []
  type: TYPE_NORMAL
- en: We print the index position of the text string if there is a match of the pattern
    in the text string, and keep the flag variable to `True` as we wish to continue
    searching for more matches of the patterns in the text string. Finally, if the
    value of the variable flag is `False`, it means that there was not a match of
    the pattern in the text string at all.
  prefs: []
  type: TYPE_NORMAL
- en: The best-case and worst-case time complexity for the naive string matching algorithms
    are `O(n)` and `O(m*(n-m+1))`, respectively. The best-case occurs when the pattern
    is not found in the text and the first character of the pattern is not present
    in the text at all, for example, if the text string is `ABAACEBCCDAAEE`, and the
    pattern is `FAA`. Here, as the first character of the pattern will not match in
    the text, it will have the comparisons equal to the length of the text (`n`).
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case occurs when all characters of the text string and the pattern
    are the same, for example, if the text string is `AAAAAAAAAAAAAAAA`, and the pattern
    is `AAAA`. Another worst-case scenario occurs when only the last character is
    different, for example, if the text string is `AAAAAAAAAAAAAAAF` and the pattern
    is `AAAAF`. Thus, worst-case time complexity would be `O(m*(n-m+1))`.
  prefs: []
  type: TYPE_NORMAL
- en: The Rabin-Karp algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rabin-Karp pattern matching algorithm is an improved version of the brute-force
    approach for finding the location of the given pattern in the text string.  The
    performance of the Rabin-Karp algorithm is improved by reducing the number of
    comparisons with the help of hashing. We described hashing in detail in [Chapter
    7](7caf334d-44bb-4c49-bb74-4f6e1ac8a8e4.xhtml), *Hashing and Symbol Tables*. The
    hashing function returns a unique numeric value for a given string.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is faster than the brute-force approach as it avoids unnecessary
    comparisons, character by character. Instead, the hash value of the pattern is
    compared with the hash of the substring of the text string all at once. If the
    hash values are not matched, the pattern is moved one position, and so there is
    no need to compare all the characters of the pattern one by one.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is based on the concept that if the hash values of the two strings
    are equal, then it is assumed that both of these strings are also equal. The main
    problem with this algorithm is that there can be two different strings whose hash
    values are equal. In that case, the algorithm may not work; this situation is
    known as a spurious hit. To avoid this problem, after matching the hash values
    of the pattern and the substring, we ensure that the pattern is actually matched
    by comparing them character by character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rabin-Karp pattern matching algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we preprocess the pattern before starting the search, that is, we compute
    the hash value of the pattern of length `m` and the hash values of all the possible
    substrings of the text of length `m`. So, the total number of possible substrings
    would be `(n-m+1)`. Here, `n` is the length of the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We compare the hash value of the pattern and compare it with the hash value
    of the substrings of the text one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hash values are not matched, then we move the pattern by one position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the hash value of the pattern and the hash value of the substring of the
    text matches, then we compare the pattern and substring character by character
    to ensure that the pattern is actually found in the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We continue the process of steps 2-4 until we reach the end of the given text
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this algorithm, we can compute the numerical hash values using Horner's rule
    or any other hashing function that returns a unique value for the given string.
    We can also compute the hashing value using the sum of the ordinal values of all
    the characters of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example to understand the Rabin-Karp algorithm. Let's say
    we have a text string (T)= `"publisher paakt packt"`, and the pattern (P)= `"packt"`.  First,
    we compute the hash value of the pattern (length `m`) and all the substrings (of
    length `m`) of the text string.
  prefs: []
  type: TYPE_NORMAL
- en: We start comparing the hash of the pattern `"packt"` with the first substring, `"publi" `
    . Since the hash values do not match, we move the pattern by one location, and
    once again we compare the hash value of pattern with the hash value of the next
    substring of the text, `"ublis"`. As these hash values also do not match, we again
    move the pattern by one location. We always move the pattern by one location if
    the hash values do not match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if the hash value of the pattern and the hash value of the substring
    match, we compare the pattern and substring character by character and we return
    the location of the text string. In this example, these values are matched at
    location `17`. It is important to note that there can be a different string whose
    hash value can match with the hash of the pattern. This situation is called a
    spurious hit, and is due to a collision in hashing. The functionality of the Rabin-Karp
    algorithm is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/06dc36ee-ebaf-43b7-b19e-564e36fafb04.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the Rabin-Karp algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to implementing the Rabin-Karp algorithm is to choose the hash
    function. We use the sum of all the ordinal values of the characters of the string
    as the hashing function.
  prefs: []
  type: TYPE_NORMAL
- en: We start by storing the ordinal values of all the characters of the text and
    the pattern. Next, we store the length of the text and the pattern in the `len_text`
    and `len_pattern` variables. Next, we compute the hash value for the pattern by
    summing up the ordinal values of all the characters in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a variable called `len_hash_array` that stores the total number
    of possible substrings of length (equal to the length of the pattern) using `len_text
    - len_pattern + 1`, and we create an array called `hash_text` that stores the
    hash value for all the possible substrings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start a loop that will run for all the possible substrings of the text.
    Initially, we compute the hash value for the first substring by summing the ordinal
    values of all of its characters using `sum(ord_text[:len_pattern])`. Furthermore,
    the hash values for all of the substrings are computed using the hash value of
    its previous substrings as `((hash_text[i-1] - ord_text[i-1]) + ord_text[i+len_pattern-1])`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete Python implementation to compute the hashing values is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After preprocessing the pattern and text, we have precomputed hash values that
    we will use for comparing the pattern and the text.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the main Rabin-Karp algorithm works as follows. First,
    we convert the given text and pattern in string format as the ordinal values can
    only be computed for the strings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the `generate_hash` function to compute the hash values. We also
    store the length of the text and patterns in the `len_text` and `len_pattern`
    variables. We also initialize the `flag` variable to `False` so that it keeps
    track of whether the pattern is present in the text at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start a loop that implements the main concept of the algorithm. This
    loop will run for the length of the `hash_text`, which is the total number of
    possible substrings. Initially, we compare the first hash value of the substring
    with the hash of the pattern by using `if hash_text[i] == hash_pattern`. They
    do not match; we do nothing and look for another substring. If they match, we
    compare the substring and the pattern character by character through a loop by
    using `if pattern[j] == text[i+j]`.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a `count` variable to keep track of how many characters match
    in the pattern and the substring. If the length of the count and length of the
    pattern become equal, this means that all of the characters match, and the index
    location is returned where the pattern was found. Finally, if the `flag` variable
    remains `False`, this means that the pattern does not match at all in the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete Python implementation of the Rabin-Karp algorithm is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Rabin-Karp pattern matching algorithm preprocesses the pattern before the
    searching, that is, it computes the hash value for the pattern that has the complexity
    of `O(m)`.  Also, the worst-case running time complexity of the Rabin-Karp algorithm
    is `O(m *(n-m+1))`.
  prefs: []
  type: TYPE_NORMAL
- en: The worse-case would be when the pattern does not occur in the text at all.
  prefs: []
  type: TYPE_NORMAL
- en: The average-case would occur when the pattern occurs at least once.
  prefs: []
  type: TYPE_NORMAL
- en: The Knuth-Morris-Pratt algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Knuth-Morris-Pratt** (**KMP**) algorithm is a pattern matching algorithm
    that is based on a precomputed prefix function that stores the information of
    an overlapping text portion in the pattern. The KMP algorithm preprocesses this
    pattern to avoid unnecessary comparisons when using the prefix function. The algorithm
    utilizes the prefix function to estimate how much the pattern should be shifted
    to search the pattern in the text string whenever we get a mismatch. The KMP algorithm
    is efficient as it minimizes the comparisons of the given patterns with respect
    to the text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The motivation behind the KMP algorithm can be seen in the following explanatory
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8f518fde-532f-4f1a-855d-94e9c0b80d22.png)'
  prefs: []
  type: TYPE_IMG
- en: The prefix function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `prefix` function (also known as the failure function) finds the pattern
    in the pattern itself. It tries to find how much the previous comparisons can
    be reused due to repetition in the pattern itself when there is a mismatch. It
    has a value that is mainly the longest prefix, which is also a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a `prefix` function for a pattern where all of the
    characters are different, the `prefix` function would have a value of `0`, meaning
    that if we find any mismatch, the pattern would be shifted by the number of characters
    in the pattern. It also means that there is no overlap in the pattern, and no
    previous comparisons would be reused. We start by comparing from the first character
    of the pattern with the text string if it contains only different characters.
    Consider the following example: the pattern **abcde** contains all different characters,
    so it would be shifted to the number of characters in the pattern, and we would
    start comparing the first character of the pattern with the next character of
    the text string, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ef15fd04-c114-4737-9dbe-344b65cf61a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s consider another example to better understand how the `prefix` function
    works for the pattern (P) **abcabbcab** as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0a762ce6-7571-451d-a0cb-378a379fc3f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we start calculating the values of the `prefix` function
    starting from index **1**. We assign value **0** if there is no repetition of
    the characters. In the preceding example, we assign **0** to the `prefix` function
    for the index positions **1** to **3**.  Next, at index position **4**, we can
    see that there is a character, **a**, which is the repetition of the first character
    of the pattern in itself, so we assign value **1** here, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/58b14e31-38ce-4f51-b496-bdf83615502d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we look at the next character at position **5**. It has the longest suffix
    pattern, **ab**, and so it would have a value of **2**, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cd0fc819-6318-4b89-926b-d283d072cd15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we look at the next index position of **6**. Here, the character
    is **b**. This character does not have the longest suffix in the pattern, so it
    has the value **0**. Next, we assign value **0** at index position **7**. Then,
    we look at the index position **8**, and we assign the value **1** as it has the
    longest suffix of length **1**. Finally, at the index position of **9**, we have
    the longest suffix of **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/04aa8d29-9b55-4e3f-9d39-f519846bc1c5.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of the `prefix` function shows how much of the start of the string
    can be reused if there is a mismatch. For example, if the comparison fails at
    the index position of **5**, the `prefix` function value is **2**, which means
    that the two starting characters don't need to be compared.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding KMP algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The KMP pattern matching algorithm uses a pattern that has overlap in the pattern
    itself so that it avoids unnecessary comparisons. The main idea behind the KMP
    algorithm is to detect how much the pattern should be shifted, based on the overlaps
    in the patterns. The algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we precompute the `prefix` function for the given pattern and initialize
    a counter, q, that represents the number of characters that matched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We start by comparing the first character of the pattern with the first character
    of the text string, and if this matches, then we increment the counter, **q**,
    for the pattern and the counter for the text string, and we compare the next character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a mismatch, then we assign the value of the precomputed `prefix`
    function for **q** to the index value of **q**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We continue searching the pattern in the text string until we reach the end
    of the text, that is, if we do not find any matches. If all of the characters
    in the pattern are matched in the text string, we return the position where the
    pattern is matched in the text and continue to search for another match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s consider the following example to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `prefix` function for the given pattern would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/628b4eb1-1001-487f-9197-1dea713c5750.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we start comparing the first character of the pattern with the first character
    of the text string and continue comparing it until we find a match. For example,
    in the following diagram, we start by comparing character **a **of the text string
    with the character **a** of the pattern. As it is matched, we continue comparing
    until we find a mismatch or we have compared the whole pattern. Here, we find
    a mismatch at index position **6**, so now we have to shift the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We find the number of shifts the pattern should take by using the help of the
    `prefix` function. This is because the `prefix` function has the value of **2**
    at the mismatch position (that is, `prefix_function(6)` is **2**), and so we start
    comparing the pattern from index position `2` of the pattern. Due to the efficiency
    of the KMP algorithm, we do not need to compare the character at **1** index position,
    and we compare the characters **c** of the pattern, and character **b** of the
    text. Since these do not match, we shift the pattern by **1** position, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b4b25215-9e10-4cd4-b815-12f07cb088ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, the compared characters are **b** and **a**—these do not match, so we
    shift the pattern by **1** distance. Next, we compare the pattern and text string
    and find a mismatch at index position 10 in the text between characters **b** and
    **c**.  Here, we use the precomputed `prefix` function to shift the pattern, as
    the `prefix_function(4)` is **2**, so we shift the at its index position of **2**,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/44d1fb23-e596-45c4-a474-374590b295a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we shift the pattern by 1 location as there is a mismatch between
    characters **b **and **c**. Next, we compare the characters at index **11** in
    the text, and continue until a mismatch is found. We find a mismatch between characters **b** and
    **c**, as shown in the following diagram. We shift the pattern and move it to
    the index of `0` of the pattern as the `prefix_function(2)` is `0`. We repeat
    the same process until we reach the end of the string. We find a match of the
    pattern in the text string at the index location of **13** in the text string,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bebe5024-3aff-4b76-8623-1c2681510c3d.png)'
  prefs: []
  type: TYPE_IMG
- en: The KMP algorithm has two phases, the preprocessing phase, which is where we compute the
    `prefix` function, It takes the space and time complexity of `O(m)` and further,
    in the second phase, that searching, the KMP algorithm takes time complexity of  `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will discuss the implementation of the KMP algorithm by using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KMP algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python implementation of the KMP algorithm is explained here. We start by
    implementing the `prefix` function for the given pattern. For this, first, we
    compute the length of the pattern by using the `len()` function, and then we initialize
    a list to store the computed values by the `prefix` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start the loop that executes from 2 to the length of the pattern. Then,
    we have a nested loop that is executed until we have processed the whole pattern.
    The variable `k` is initialized to `0`, which is the `prefix` function for the
    first element of the pattern.  If the `k^(th)` element of the pattern is equal
    to the `q^(th)` element, then we increment the value of `k` by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of k is the computed value by the `prefix` function, and so we assign
    it at the index position of the `q` of the pattern. Finally, we return the list
    of the `prefix` function that has the computed value for each character of the
    pattern. The code for the `prefix` function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the `prefix` function, we implement the main KMP matching
    algorithm. We start by computing the length of the text string and the pattern,
    which are stored in the variables `m` and `n`, respectively. The following code
    shows this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Boyer-Moore algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discussed, the main objective of the string pattern matching
    algorithm is to find ways of skipping comparisons as much as possible by avoiding
    unnecessary comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boyer-Moore pattern matching algorithm is another such algorithm (apart
    from the KMP algorithm) that further improves the performance of pattern matching
    by skipping some comparisons using some methods. You need to understand the following
    concepts to be able to use the Boyer-Moore algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: In this algorithm, we shift the pattern in the direction from left to right,
    similar to the KMP algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We compare the characters of the pattern and the text string from the right
    to the left direction, which is the opposite of the KMP algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm skips the unnecessary comparisons by using the good-suffix and
    bad-character shifts concept
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding the Boyer-Moore algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm compares the pattern over the text from right to left.
    It uses the information of the various possible alignments in the pattern by preprocessing
    it. The main idea of this algorithm is that we compare the end characters of the
    pattern with the text. If they do not match, then the pattern can be moved on
    further. If the characters do not match in the end, there is no need to do further
    comparisons. In addition, in this algorithm, we can also see what portion of the
    pattern has matched (with the matched suffix), so we utilize this information
    and align the text and pattern by skipping any unnecessary comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boyer-Moore algorithm has two heuristics to determine the maximum shift
    possible for the pattern when we find a mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: Bad character heuristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good suffix heuristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of a mismatch, each of these heuristics suggests possible shifts,
    and the Boyer-Moore algorithm shifts the pattern by considering the maximum shift
    possible due to bad character and good suffix heuristics. The details of the bad
    character and good suffix heuristics are explained in detail with examples in
    the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Bad character heuristic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm compares the pattern and the text string in the direction
    from right to left. It uses the bad character heuristic to shift the pattern.
    According to the bad character shift concept, if there is a mismatch between the
    character of the pattern and the text, then we check if the mismatched character
    of the text occurs in the pattern or not. If this mismatched character (also known
    as a bad character) does not appear in the pattern, then the pattern will be shifted
    next to this character, and if that character appears somewhere in the pattern, 
    we shift the pattern to align with the occurrence of that character with the bad
    character of the text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this concept by using an example. Consider a text string
    (T) and the pattern = {**acacac**}. We start by comparing the characters from
    right to left, that is, character **b** of the text string and character **c** of
    the pattern. They do not match, so we look for the mismatched character of the
    text string, that is, **b**, in the pattern. Since it does not occur in the pattern,
    we shift the pattern next to the mismatched character, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cc298adf-fb27-4d70-9f29-5148bc40d532.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at another example. We start by comparing characters of the text
    string and the pattern from right to the left, and we get a mismatch for the character
    **d** of the text. Here, the suffix **ac** is matched, but the characters **d**
    and **c** do not match, and the mismatched character **d** does not occur in the
    pattern. Therefore, we shift the pattern to the mismatched character, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9fc8421b-9ed9-4282-bf63-522846e13eb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's consider another example case for the bad character heuristic. Here, the
    suffix **ac **is matched, but the next characters, **a** and **c**, do not match,
    so we search for the occurrences of the mismatched character **a** in the pattern.
    Since it has two occurrences in the pattern, we have two options so that we can
    align the mismatched character, as shown in the following diagram. In such a situation,
    where we have more than one option to shift the pattern, we move the pattern with
    the minimum amount of shifts to avoid any possible match. (In other words, it
    would be the rightmost occurrence of that character in the pattern.) If we would
    have only one occurrence of the mismatched character in the pattern, we can easily
    shift the pattern in such a way that the mismatched character is aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we would prefer option **1** to shift the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/284beb26-731a-441f-a1c3-2eb800c011c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Good suffix heuristic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bad character heuristic does not always provide good suggestions. The Boyer-Moore
    algorithm also uses good suffix heuristic as well to shift the pattern over the
    text string to find out the location of the matched patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good suffix heuristic is based on the matched suffix. Here, we shift the pattern
    to the right in such a way that the matched suffix subpattern is aligned with
    another occurrence of the same suffix in the pattern. It works like this: we start
    by comparing the pattern and the text string from right to left. If we find any
    mismatch, then we check the occurrence of the suffix that we have matched so far.
    This is known as the good suffix. We shift the pattern in such a way that we align
    another occurrence of the good suffix to the text. Good suffix heuristic has mainly
    two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The matching suffix has one or more occurrences in the pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some part of the matching suffix is present in the start of the pattern (this
    means that the suffix of the matched suffix exists as the prefix of the pattern).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s understand these cases with the following examples. Suppose we have
    a pattern, **acabac**. We get a mismatch for the characters **a** and **b**, but
    at this moment in time, we have already matched the suffix, that is, **ac**. Now,
    we search for another occurrence of the good suffix **ac** in the pattern and
    we shift the pattern by aligning that suffix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/19965040-07c0-4fc5-84d1-a785c3b25d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s consider another example, where we have two options to align the shift
    of the pattern so that we get two good suffix strings. Here, we will take the
    option **1** to align the good suffix by considering the option that has the minimum
    shifts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/467f95d8-927f-44e1-9ff8-dc722ba839ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at another example. Here, we get a suffix match of **aac**,
    but we get a mismatch for the characters **b** and **a**.  We search for the good
    suffix **aac**, but we do not find another occurrence in the pattern. However,
    we find that the prefix, **ac**, at the start of the pattern does not match with
    the whole suffix, but it does match with the suffix **ac** of the matched suffix
    **aac**. In such a situation, we shift the pattern by aligning with the suffix
    of **aac** that is also a prefix of the pattern and align that prefix with the
    suffix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/323ab0d1-b503-42f7-ab66-aa97a9fc0299.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another case for the good suffix heuristic is as follows. In this case, we
    match the suffix **aac**, but we mismatch it at characters **b** and **a**. We
    try to search for the matched suffix in the pattern, but there is no occurrence
    of the suffix in the pattern, so in this situation, we shift the pattern after
    the matched suffix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e84ff37e-2ddd-4ece-9883-2011cd8531ed.png)'
  prefs: []
  type: TYPE_IMG
- en: We shift the pattern by the longer distance that is given by the bad character
    heuristics and the good suffix heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: The Boyer-Moore algorithm takes the time of `O(m)` for the preprocessing of
    the pattern, and further searching takes the time complexity of `O(mn)`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Boyer-Moore algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand the implementation of the Boyer-Moore algorithm. Initially,
    we have the text string and the pattern. After initializing the variables, we
    start with a while loop that starts by comparing the last character of the pattern
    to the corresponding character of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the characters are compared from right to left by the use of the nested
    loop from the last index of the pattern to the first character of the pattern.
    This uses `range(len(pattern)-1, -1, -1)`.
  prefs: []
  type: TYPE_NORMAL
- en: The outer while loop keeps tracks of the index in the text string while the
    inner for loop keeps track of the index position in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start comparing the characters by using `pattern[j] != text[i+j]`.
    If they are mismatched, we make the flag variable `False`, denoting that there
    is a mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we check if the good suffix is present or not by using the condition `j
    == len(pattern)-1`. If this condition is true, it means that there is no good
    suffix possible, so we check for the bad character heuristics, that is, if a mismatched
    character is present in the pattern or isn't using the condition `text[i+j] in
    pattern[0:j]`, and if the condition is true, then it means that the bad character
    is present in the pattern. In this case, we move the pattern to align this bad
    character to the other occurrence of this character in the pattern by using `i=i+j-pattern[0:j].rfind(text[i+j])`.
    Here, `(i+j)` is the index of the bad character.
  prefs: []
  type: TYPE_NORMAL
- en: If the bad character is not present in the pattern (it isn't in the `else` part
    of it), we move the whole pattern next to the mismatched character by using the
    index `i=i+j+1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we go into the `else` part of the condition to check the good suffix.
    When we find the mismatch, we further test to see whether we have any subpart
    of a good suffix present in the prefix of the pattern. We do this by using the
    following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, we check whether the length of the good suffix is `1` or not. If
    the length of the good suffix is `1`, we do not consider this shift. If the good
    suffix is more than `1`, we find out the number of shifts by using the good suffix
    heuristics and store this in the `gsshift` variable. This is the pattern to a
    position where the good suffix of a pattern matches with the good suffix of text
    using the instruction `gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])`.
    Furthermore, we computed the number of shifts possible due to the bad character
    heuristic and stored this in the `bcshift` variable. The number of shifts possible
    is `i+j-pattern[0:j].rfind(text[i+j])` when the bad character is present in the
    pattern, and the number of shifts possible would be `i+j+1` in the case of the
    bad character not being present in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shift the pattern on the text string by the maximum number of moves
    given by a bad character and good suffix heuristics by using the instruction `i=max((bcshift,
    gsshift))`. Finally, we check whether the flag variable is `True` or not. If it
    is `True`, this means that the pattern has been found and that the matched index
    has been stored in the `matched_indexes` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete implementation of the Boyer-Moore algorithm is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the most popular and important string processing
    algorithms that have wide applications in real-time scenarios. We started this
    chapter by looking at the basic concepts and definitions related to strings. Next,
    we described the brute-force, Rabin-Karp, KMP, and Boyer-Moore pattern matching
    algorithms in detail for pattern matching problems. We have seen that the brute-force
    pattern matching algorithm is quite slow as it compared the characters of the
    pattern and the text string character by character.
  prefs: []
  type: TYPE_NORMAL
- en: In pattern matching algorithms, we try to find out ways to skip unnecessary
    comparisons and move the pattern over the text as fast as possible to quickly
    find out the positions of the matched patterns. The KMP algorithm finds out the
    unnecessary comparisons by looking at the overlapping substrings in the pattern
    itself to avoid unimportant comparisons. Furthermore, we discussed the Boyer-Moore
    algorithm, which is very efficient when the text and pattern are long. It is the
    most popular algorithm that is being used in practice for pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing data structure design strategies
    and techniques in more detail.
  prefs: []
  type: TYPE_NORMAL
