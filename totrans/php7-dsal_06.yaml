- en: Understanding and Implementing Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our exploration of data structures has so far touched the linear parts only.
    Whether we used arrays, linked lists, stacks, or queues, all are linear data structures.
    We have seen the complexities of linear data structure operations, and most of
    the time, the insertion and deletion can be performed with `O(1)` complexity.
    However, the searching is a little complicated and takes `O(n)` complexity. The
    only exception is a PHP array, which, in fact, works as a hash table and can be
    searched in `O(1)` if the index or keys are managed in such a way. In order to
    solve this problem, we can use a hierarchical data structure instead of the linear
    one. Hierarchical data can solve many issues that a linear data structure cannot
    solve easily. Whenever we are talking about family tree, organization structure,
    and network connectivity diagrams, we are actually talking about hierarchical
    data. Trees are a special **Abstract Data Type** (**ADT** ) that represents hierarchical
    data. Unlike a linked list, which is also an ADT, trees are hierarchical compared
    to the linear nature of linked lists. In this chapter, we will explore the world
    of trees. A perfect example of a tree structure can be a family tree, just like
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tree definition and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tree is a hierarchical collection of nodes or vertices connected by edges.
    Trees cannot have cycles, and only edges will exist between a node and its descended
    nodes or child nodes. Two child nodes of a same parent cannot have any edges in
    between them. Each node can have a parent other than the top node, which is also
    known as the root node. There can be only one root node per tree. Each node can
    have zero or more child nodes. In the following diagram, **A** is the root node,
    and **B** , **C** , and **D** are the child nodes of **A** . We can also say that
    A is the parent node of **B** , **C** , and **D** . **B** , **C** , and **D**
    are known as siblings as they are child nodes from the same parent, **A** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00042.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The node that does not have any children is known as a leaf. In the preceding
    diagram, **K** , **L** , **F** , **G** , **M** , **I** , and **J** are leaf nodes.
    Leaf nodes are also known as external nodes or terminal nodes. A node, other than
    the root, having at least one child, is known as an internal node. Here, **B**
    , **C** , **D** , **E** , and **H** are internal nodes. Here are some other common
    terms we use when describing tree data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Descendent** : This is a node that can be reached from a parent node by repeated
    proceedings. For example, **M** is a descendent of **C** in the previous diagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ancestor** : This is a node that can be reached from a child node to a parent
    node by a repeated way. For example, **B** is the ancestor of **L** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree** : The total number of child nodes of a particular parent node is
    known as its degree. In our example, **A** has degree 3, **B** has degree 1, **C**
    has degree 3, and **D** has degree 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path** : The sequence of nodes and edges from a source node to a target node
    is known as the path between two nodes. The length of the path is the number of
    nodes in the path. In our example, the path between **A** to **M** is **A-C-H-M**
    , and the length of the path is 4:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Height of node** : The height of a node is defined by the number of edges
    between the node and the deepest level of the descendent node. For example, the
    height of node **B** is 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level** : The level represents the generation of nodes. If a parent node
    is in level *n* , its child node will be in the *n+1* level. So, the level is
    defined by 1+ number of edges between the node and the root. Here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root **A** is in **Level 0**
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**B** , **C** , and **D** are in **Level 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E** , **F** , **G** , **H** , **I** , and **J** are in **Level 2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**K** , **L** , and **M** are in **Level 3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height of tree** : The height of a tree is defined by the height of its root
    node. Here, the height of the tree is 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtree** : In a tree structure, each child forms a subtree recursively.
    In other words, a tree consists of many subtrees. For example, **B** forms a subtree
    with **E** , **K** , and **L** , whereas **E** forms a subtree with **K** and
    **L** . In the preceding example, we have identified each in the left-hand side
    in different shades. We can do the same for **C** and **D** and their subtrees
    as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth** : The depth of a node is determined by the number of edges between
    the node and the root node. For example, in our tree image, the depth of **H**
    is 2 and the depth of **L** is 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forest** : A forest is a set of zero or more disjoint trees.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traverse** : This indicates the process of visiting nodes in a specific order.
    We will use this term often in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keys** : A key is a value from the node that is used for searching purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a tree using PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you have learned about different properties of a tree data structure.
    If we compare a tree data structure with a real-life example, we can consider
    our organization structure or family tree to represent the data structure. For
    an organization structure, there is one root node that can be the CEO of the company,
    followed by CXO-level employees, followed by other level employees. Here, we are
    not restricting any degree for a particular node. This means a node can have multiple
    children. So, let''s think of a node structure where we can define the node property,
    its parent node, and its children nodes. It might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the preceding code, we can see that we have declared two public
    properties for data and children. We also have a method to add children to a particular
    node. Here, we are just appending the new child node at the end of the array.
    This will give us an option to add multiple nodes as children for a particular
    node. As a tree is a recursive structure, it will help us build a tree recursively
    and also traverse the tree in a recursive manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the node; let''s build a tree structure that will define the root
    node of the tree and also a method to traverse the whole tree. So, the basic tree
    structure will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows a simple tree class where we can store the root node
    reference and also traverse the tree from any node. In the traverse part, we are
    visiting each child node and then immediately recursively calling the traverse
    method to get the children of the current node. We are passing a level to print
    out a dash (-) at the beginning of the node name so that we can understand the
    child level data easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create the root node and assign it to the tree as a root. The code
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created the first node as CEO, and then created the tree and assigned
    the CEO node as the root node of the tree. Now, it is time to grow our tree from
    the root node. Since we choose the example of the CEO, we will now add CXOs and
    other employees under the CEO. Here is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are creating four new nodes (CTO, CFO, CMO, and COO) at the beginning
    and assigning them as child nodes of the CEO node. Then we are creating Senior
    Architect and here is the Software engineer node followed by the user interface
    designer and Quality assurance engineer. We have assigned the senior software
    engineer node to be a child node of the senior architect node and senior architect
    to be a child node of CTO, along with user interface engineer and quality assurance
    engineer. The last line is to display the tree from the root. This will output
    the following lines in our command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we consider the preceding output, we have `CEO` at level 0\. `CTO` , `CFO`
    , `CMO` , and `COO` are at level 1\. `Senior Architect` , `User Interface Designer`
    , and `Quality Assurance Engineer` are at level 2 and `Software Engineer` is at
    level 3.
  prefs: []
  type: TYPE_NORMAL
- en: We have constructed a basic tree data structure using PHP. Now, we will explore
    the different types of trees we have.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of tree structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types of tree data structures present in the programming world.
    We will explore some of the most used tree structures here.
  prefs: []
  type: TYPE_NORMAL
- en: Binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binary is the most basic form of tree structure where each node has a maximum
    of two child nodes. The child nodes are known as left and right nodes. A binary
    tree will look like the one shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary search tree (BST) is a special type of binary tree where the nodes
    are stored in a sorted manner. It is sorted in such a way that at any given point,
    a node value must be greater than or equal to the left child node value and smaller
    than the right child node value. Each node has to satisfy this property to consider
    it as a binary search tree. Since the nodes are sorted in a particular order,
    the binary search algorithm can be applied to search items in a BST in logarithmic
    time. It is always better than linear searching, which takes **O(n)** time, and
    we will explore it in the next chapter. Here is an example of a binary search
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Self-balanced binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A self-balanced binary search tree or height-balance binary search tree is
    a special type of binary search tree that attempts to keep the height or number
    of levels of the tree as small as possible all the time by adjusting automatically.
    For example, the following diagram shows a binary search tree on the left and
    a the self-balanced binary search tree on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A height-balanced binary tree is always better as it helps search operations
    faster compared to a regular BST. There are different implementations of self-balanced
    or height-balanced binary search trees. Some of the popular ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AA tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AVL tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red-black tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scapegoat tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splay tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2-3 tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss few of the height-balanced trees in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: AVL tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An AVL tree is a self-balancing binary search tree where the heights of two
    child subtrees of a node will differ by a maximum of 1\. If the height increases,
    in any case, there will be a rebalance to make the height difference to 1\. This
    gives the AVL tree an added advantage of logarithmic complexity for different
    operations. Here is an example of an AVL tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Red-black tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A red-black tree is a self-balanced binary search tree with some extra properties,
    which is the color. Each node in the binary tree stores one extra bit of information,
    which is known as color and can have either red or black as values. Like an AVL
    tree, a red-black tree is also used for real-time applications as the average
    and worst case complexity is also logarithmic. A sample red-black tree looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: B-tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A B-tree is a special type of binary tree, which is self-balanced. This is not
    the same as a self-balanced binary search tree. The key difference is that in
    a B-tree, we can have any number of nodes as child nodes, not just two. A B-tree
    is used for a large set of data and is mainly used in filesystems and databases.
    The complexity of different operations in a B-tree is logarithmic.
  prefs: []
  type: TYPE_NORMAL
- en: N-ary Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An N-ary tree is a special type of tree where a node can have maximum N children.
    This is also known as a k-way tree or M-ary tree. A binary tree is an N-ary tree
    where the value of N is 2.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We always get confused with binary trees and binary search trees. As we have
    seen in the definition, BST is a sorted binary tree. If it is sorted, then we
    can have the performance improvement compared to a regular binary tree. Each binary
    tree node can have a maximum of two child nodes, which are known as the left child
    node and right child node. However, based on the type of binary tree, there can
    be zero, one, or two child nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also classify binary trees into different categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full binary tree:** A full binary tree is a tree that has either zero or
    two child nodes on each node. A full binary tree is also known as a proper tree
    or a plane binary tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perfect binary tree** : A perfect binary tree is a binary tree in which all
    internal nodes have exactly two child nodes and all leaves have the same level
    or depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete binary tree:** A complete binary tree is a binary tree in which
    all levels, except the last level, are completely filled and all nodes are as
    far left as possible. The following diagram shows the full binary tree, complete
    binary tree, and perfect binary tree:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Image00049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create a binary tree (not a binary search tree). The key factor
    to have in a binary tree is that we must have two placeholders for the left child
    node and the right child node, along with the data we want to store in the node.
    A simple implementation of a binary node will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows that we have a class with tree properties to store
    data, left and right. When we are constructing a new node, we are adding the node
    value to the data property, and left and right is kept `NULL` as we are not sure
    if we need those or not. We also have an `addChildren` method to add left children
    and right children to a particular node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a binary tree class where we can define the root node as
    well as the traversal method similar to our basic tree implementation earlier
    in this chapter. The difference between two implementations is the traversal process.
    In our previous example, we used `foreach` to traverse each child node as we did
    not know how many nodes are there. Since each node in the binary tree can have
    a maximum of two nodes and they are named as left and right, we can only traverse
    the left node and then the right node for each particular node visit. The changed
    code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks very similar to the basic tree class we had earlier in this chapter.
    Now, let''s fill up the binary tree with some nodes. Usually, in any football
    or cricket tournament, we have knockout rounds where two teams play with each
    other, the winner moves forward, and it continues to the final. We can have a
    similar structure as a binary tree for our example. So, let''s create some binary
    nodes and structure them in a hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we created a node called final and made it as a root node. Then, we
    created two semifinal nodes and four quarter final nodes. Two semifinal nodes
    each have two quarter final nodes as left and right child nodes. The final node
    has two semifinal nodes as left and right child nodes. The `addChildren` method
    is doing the children assignment job for the nodes. In the last line, we traversed
    the tree and displayed the data hierarchically. If we run this code in the command
    line, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating a binary tree using a PHP array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can implement a binary tree using a PHP array. Since a binary tree has a
    maximum of zero to two child nodes, we can use the maximum child nodes as 2 and
    construct a formula to find the child nodes of a given node. Let''s number the
    nodes in a binary tree from top to bottom and left to right. So, the root node
    will have number **0** , the left child **1** , and right child **2** , and this
    will follow until each node is numbered, just like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00050.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We can easily see that for node **0** , the left child is **1,** and the right
    child **2** . For node **1** , the left child is **3,** and the right child is
    **4** , and it goes on. We can easily put this in a formula:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *i* is our node number, then:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Left node = 2 X i + 1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right node = 2 X (i + 1)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create our example for the match schedule part using a PHP array.
    If we rank it as per our discussion, then it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we will create an array with auto-indexing, starting from 0\. This
    array will be used as a binary tree representation. Now, we will modify our `BinaryTree`
    class to use this array instead of our node class, with left and right child nodes
    as well as the traversal method. Now, we will traverse based on the node number
    instead of the actual node reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from preceding implementation, the traverse part uses the node
    positioning instead of a reference. This node position is nothing but the array
    indexes. So, we can directly access the array index and check whether it''s empty
    or not. If not, we can continue to go deeper using the recursive way. If we want
    to create the binary tree using the array and print the array values, we have
    to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code in the command line, we will see following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can use a simple `while` loop to iterate through the array and visit each
    node instead of proceeding recursively. In all our recursive examples, we will
    see that some are more efficient if we use them the iterative way. We can also
    just use them directly instead of creating a class for the binary tree.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A BST is a binary tree that is built in such way that the tree is always sorted.
    This means the left child node has a value less than or equal to the parent node
    value, and right child node will have the value greater than the parent node value.
    So, whenever we need to search a value, either we will search left or search right.
    As it is sorted, we have to search one part of the tree, not both, and this continues
    recursively. For its dividing nature, the searching becomes very fast, and we
    can achieve logarithmic complexity for the search. For example, if we have *n*
    number of nodes, we will search either the first half or second half of the nodes.
    Once we are in the first or second half, we can divide it again into two halves,
    which means our half now becomes a quarter, and it goes on and on until we reach
    the final node. As we are not moving to each node to search, it is not going to
    take `O(n)` complexity for the operation. In the next chapter, we will do the
    complexity analysis of a binary search and will see why the binary search tree
    has a search complexity of `O(log n)` . Unlike the binary tree, we cannot add
    any node to or remove any node from the tree without reconstructing the BST properties.
  prefs: []
  type: TYPE_NORMAL
- en: If node **X** has two children, then the successor of node **X** is the smallest
    value that belongs to the tree, which is greater than the value of **X** . In
    other words, the successor is the minimum value of the right subtree. On the other
    hand, the predecessor is the maximum value of the left subtree. Now, we will focus
    more on the different operations of a BST and the steps we need to consider to
    perform those operations correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the operations of a BST.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are inserting a new node in the binary search tree, we have to consider
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new node as a leaf (no left child or right child).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start with the root node and set it as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the node is empty, make the new node as the root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the new value is less than the current node or more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If less, go to the left and set the left as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If more, go to the right and set the right as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to *step 3* until all the nodes are visited and the new node is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Searching a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are searching a new node in a binary search tree, we have to consider
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the root node and set it as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node is empty, return false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node value is the search value, return true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the searching value is less than the current node or more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If less, go to the left and set the left as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If more, go to the right and set the right as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to *step 3* until all the nodes are visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the minimum value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a binary search tree stores data in a sorted way, we can always find the
    smaller data in the left nodes and the bigger ones in the right node. So, finding
    the minimum value will require us to visit all the left nodes from the root node
    until we find the left-most node and its value. Here are the steps for finding
    the minimum value:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the root node and set it as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node is empty, return false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the left and set the left as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node does not have a left node, go to *step 5* ; otherwise, continue
    to *step 4* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to *step 3* until all the left nodes are visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the maximum value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for finding the maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the root node and set it as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node is empty, return false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the right and set the right as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node does not have a right node, go to *step 5* ; otherwise,
    continue to *step 4* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to *step 3* until all the right nodes are visited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are deleting a node, we have to consider that the node can be an internal
    node or a leaf. If it''s a leaf, it has zero children. However, if the node is
    internal, it can have one or two children. In such a case, we need to take extra
    steps to make sure the tree is constructed right after the deletion. That is why
    deleting a node from BST is always a challenging job compared to other operations.
    Here are the things to consider for a node deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: If the node has no child, make the node NULL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the node has only one child, make the child take node's place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the node has two children, then find the successor of the node and replace
    it to the current node's place. Remove the successor node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have discussed most of the possible operations for a binary search tree.
    Now, we will implement the binary search tree step-by-step, starting with insert,
    search, finding minimum and maximum, and at the end, the delete operation. Let's
    get started with the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a binary search tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, a node can have two children and itself can represent a tree in
    a recursive manner. We will define our node class to be more functional and have
    all the required functionalities to find the maximum value, minimum value, predecessors,
    and successors. Later on, we will add the delete functionality as well for a node.
    Let''s check the following code for a node class for a BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The node class looks straightforward and matches with our steps defined in the
    previous section. Each new node is a leaf and hence, does not have a left or right
    node at the moment of creation. As we know that we can find the smaller value
    at the left of the node to find the minimum, we are reaching to the left-most
    node and right-most node for the maximum value. For a successor, we are finding
    the minimum value of a node from the right subtree of a given node and the maximum
    value of a node from the left subtree for the predecessor part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a BST structure to add new nodes in the tree so that we can follow
    the insert principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the preceding code, we have only one property for the BST class,
    which will mark the root node. During the construction of the BST object, we are
    passing a single value, which will be used as the root of the tree. The `isEmpty`
    method checks whether the tree is empty or not. The `insert` method allows us
    to add a new node in the tree. The logic checks whether the value is greater than
    or less than the root node and follows the principle of the BST to insert the
    new node in the right position. If the value is already inserted, we will ignore
    it and avoid adding to the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a `traverse` method to go through the nodes and see the data in
    an ordered format (first left, then the node, and then the right node value).
    It has a designated name, and we will explore that in the next section. For now,
    let''s prepare a sample code to use the BST class and add a few numbers and check
    whether the numbers are stored in a proper way. If the BST is working, then the
    traverse will show a sorted list of numbers, no matter how we insert them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the preceding code, `10` is our root node, and then, we added
    new nodes randomly. At the end, we invoked the traverse method to show the nodes
    and how they are stored in the binary search tree. Here is the output of the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual tree will look like this visually, which looks exactly like what
    is expected from the BST implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will add the search part in our BST class. We want to find whether
    the value exists in the tree or not. If the value is not in our BST, it will return
    false and the node otherwise. Here is the simple search functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we are searching a value in the tree
    from the node and following either left or right of the tree iteratively. If no
    node is found with the value, the leaf of the node is returned, which is `NULL.`
    We can test the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output. Since `14` is not in our list, it will
    say `Not Found` , and for `36` , it will show `Found` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will move to our most complex part of the coding, the deletion of a
    node. We need to implement each of the cases where a node can have zero, one,
    or two child nodes. The following image shows us the three conditions we need
    to satisfy for deleting a node and making sure the binary search tree remains
    a binary search tree after the operation. We have to be careful when we are dealing
    with a node that has two child nodes. Since we need to go back and forth between
    nodes, we need to know which node is the parent node for the current node. As
    a result, we need to add an additional property to track the parent node for any
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the change of code we are adding to our `Node` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block now also creates a parent relationship with the newly created
    node to its immediate parent. We also want to attach our delete functionality
    with the individual node so that we can find a node and then just remove it using
    the `delete` method. Here is the code for the delete functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first condition checks whether the node is a leaf or not. If the node is
    a leaf, then we are just making the parent node to remove the reference of the
    child node (either the left or right one). That way, the node will be disconnected
    from the tree, which satisfies our first condition of having zero children.
  prefs: []
  type: TYPE_NORMAL
- en: The next conditions actually checks our third condition where we are having
    two children of a node. In such a case, we are getting the successor of the node,
    assigning the successor value to the node itself, and removing the successor node.
    It is simply a copy-paste of the data from the successor.
  prefs: []
  type: TYPE_NORMAL
- en: The next two condition check whether the node has a single child, as shown in
    our *Case 2* diagram earlier. Since the node has only one child, it can be either
    the left child or the right child. So, the condition checks whether the single
    child is the left child of the node. If so, we need to point the left child to
    the node's parent left or right reference based on the position of the node itself
    with its parent. The same rule is applied for the right node. Here, the right
    node reference is set to its parent's left or right child, not to a reference
    based on the position of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have updated our node class, we need to make some changes to our BST
    class for insertion and also for removal of a node. The insertion code will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code looks similar to the one we used previously, with one minor change.
    Now, we are sending the current node reference when we are creating a new node.
    This current node will be used as a parent node for the new node. The `new Node($data,
    $node)` code actually does the trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'For removing a node, we can first do a search and then delete the searched
    node using our `delete` method in the node class. As a result, the `remove` function
    itself is going to be very small, just like the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As the code shows, we are first searching the data. If the node exists, we
    are removing it using the `delete` method. Now, let''s run our previous example
    with a `remove` call and see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are just removing `15` from our tree and then traversing the tree from the
    root. We will now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can see that 15 is not a part of our BST anymore. In such a way, we can remove
    any node, and if we traverse using the same method, we will see a sorted list.
    If we look at our preceding output, we can see that the output is shown in the
    ascending order. There is a reason behind it, and we will explore it in the next
    topic-different tree traversal way.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a great tool for visualized binary search tree operations at [http://btv.melezinek.cz/binary-search-tree.html](http://btv.melezinek.cz/binary-search-tree.html)
    . It is a good starting for learners to understand the different operations visually.
  prefs: []
  type: TYPE_NORMAL
- en: Tree traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tree traversal refers to the way we visit each node in a given tree. Based on
    how we do the traversing, we can follow three different ways of traversing. These
    traversals are very important in many different ways. Polish notation conversion
    for expression evaluation is one of the most popular examples of using tree traversals.
  prefs: []
  type: TYPE_NORMAL
- en: In-order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In-order tree traversal visits the left node first, then the root node, and
    followed by the right node. This continues recursively for each node. The left
    node stores a smaller value compared to the root node value and right node stores
    a bigger value than the root node. As a result, when we are applying in-order
    traversing, we are obtaining a sorted list. That is why, so far, our binary tree
    traversal was showing a sorted list of numbers. That traversal part is actually
    the example of an in-order tree traversal. The in-order tree traversal follows
    these principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left subtree by recursively calling the in-order function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the data part of the root (or current node).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the right subtree by recursively calling the in-order function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding tree will show A, B, C, D, E, F, G, H, and I as output since it
    is being traversed in-order.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pre-order traversal, the root node is visited first, followed by the left
    node and then the right node. The principles of pre-order traversal are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the data part of the root (or current node).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the left subtree by recursively calling the pre-order function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the right subtree by recursively calling the pre-order function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding tree will have F, B, A, D, C, E, G, I, and H as output as it is
    being traversed in pre-order.
  prefs: []
  type: TYPE_NORMAL
- en: Post-order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In post-order traversal, the root node is visited last. The first left node
    is visited and then the right node. The principles of post-order traversal are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left subtree by recursively calling the post-order function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the right subtree by recursively calling the post-order function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the data part of the root (or current node).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Image00055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding tree will have the output A, C, E, D, B, H, I, G, and F since
    it is traversed in a post-order way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the traversal logic in our BST class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the three different traversal methods for our previous binary
    search tree, here is the code to run the traversal part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output in our command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Complexity of different tree data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen different tree types and their operations. It is not possible
    to go through each of the tree types and their different operations, as this will
    be out of the scope of the book. We want to get the minimal idea about the other
    tree structures and their operation complexities. Here is a chart with average
    and worst case complexities of different operations and spaces for different types
    of trees. We might need to choose different tree structures based on our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the non-linear data structure in detail. You learned
    that trees are hierarchical data structures and that there are different tree
    types, operations, and complexities. We have also seen how to define a binary
    search tree. This will be very useful for implementing different searching techniques
    and data storage. In our next chapter, we will shift our focus from data structures
    to algorithms. We will focus on the first type of algorithm--the sorting algorithms.
  prefs: []
  type: TYPE_NORMAL
